---
File: ./components/await.md
---

---

## title: Await

# `<Await>`

To get started with streaming data, check out the [Streaming Guide][streaming_guide].

The `<Await>` component is responsible for resolving deferred loader promises accessed from [`useLoaderData`][use_loader_data].

```tsx
import { Await } from '@remix-run/react';

<Suspense fallback={<div>Loading...</div>}>
  <Await resolve={somePromise}>{(resolvedValue) => <p>{resolvedValue}</p>}</Await>
</Suspense>;
```

## Props

### `resolve`

The resolve prop takes a promise from [`useLoaderData`][use_loader_data] to resolve when the data has streamed in.

```tsx
<Await resolve={somePromise} />
```

When the promise is not resolved, a parent suspense boundary's fallback will be rendered.

```tsx
<Suspense fallback={<div>Loading...</div>}>
  <Await resolve={somePromise} />
</Suspense>
```

When the promise is resolved, the `children` will be rendered.

### `children`

The `children` can be a render callback or a React element.

```tsx
<Await resolve={somePromise}>{(resolvedValue) => <p>{resolvedValue}</p>}</Await>
```

If the `children` props is a React element, the resolved value will be accessible through [`useAsyncValue`][use_async_value] in the subtree.

```tsx
<Await resolve={somePromise}>
  <SomeChild />
</Await>
```

```tsx
import { useAsyncValue } from '@remix-run/react';

function SomeChild() {
  const value = useAsyncValue();
  return <p>{value}</p>;
}
```

### `errorElement`

The `errorElement` prop can be used to render an error boundary when the promise rejects.

```tsx
<Await errorElement={<div>Oops!</div>} />
```

The error can be accessed in the subtree with [`useAsyncError`][use_async_error]

```tsx
<Await errorElement={<SomeChild />} />
```

```tsx
import { useAsyncError } from '@remix-run/react';

function SomeChild() {
  const error = useAsyncError();
  return <p>{error.message}</p>;
}
```

[streaming_guide]: ../guides/streaming
[use_loader_data]: ../hooks/use-loader-data
[use_async_value]: ../hooks/use-async-value
[use_async_error]: ../hooks/use-async-error

---

## File: ./components/form.md

---

## title: Form

# `<Form>`

A progressively enhanced HTML [`<form>`][form_element] that submits data to actions via `fetch`, activating pending states in `useNavigation` which enables advanced user interfaces beyond a basic HTML form. After a form's action completes, all data on the page is automatically revalidated from the server to keep the UI in sync with the data.

Because it uses the HTML form API, server rendered pages are interactive at a basic level before JavaScript loads. Instead of Remix managing the submission, the browser manages the submission as well as the pending states (like the spinning favicon). After JavaScript loads, Remix takes over enabling web application user experiences.

Form is most useful for submissions that should also change the URL or otherwise add an entry to the browser history stack. For forms that shouldn't manipulate the browser history stack, use [`<fetcher.Form>`][fetcher_form].

```tsx
import { Form } from '@remix-run/react';

function NewEvent() {
  return (
    <Form action="/events" method="post">
      <input name="title" type="text" />
      <input name="description" type="text" />
    </Form>
  );
}
```

## Props

### `action`

The URL to submit the form data to.

If `undefined`, this defaults to the closest route in context. If a parent route renders a `<Form>` but the URL matches deeper child routes, the form will post to the parent route. Likewise, a form inside the child route will post to the child route. This differs from a native [`<form>`][form_element] that will always point to the full URL.

<docs-info>Please see the [Splat Paths][relativesplatpath] section on the `useResolvedPath` docs for a note on the behavior of the `future.v3_relativeSplatPath` future flag for relative `<Form action>` behavior within splat routes</docs-info>

### `method`

This determines the [HTTP verb][http_verb] to be used: `DELETE`, `GET`, `PATCH`, `POST`, and `PUT`. The default is `GET`.

```tsx
<Form method="post" />
```

Native [`<form>`][form_element] only supports `GET` and `POST`, so you should avoid the other verbs if you'd like to support [progressive enhancement][progressive_enhancement]

### `encType`

The encoding type to use for the form submission.

```tsx
<Form encType="multipart/form-data" />
```

Defaults to `application/x-www-form-urlencoded`, use `multipart/form-data` for file uploads.

### `navigate`

You can tell the form to skip the navigation and use a [fetcher][use_fetcher] internally by specifying `<Form navigate={false}>`. This is essentially a shorthand for `useFetcher()` + `<fetcher.Form>` where you don't care about the resulting data and only want to kick off a submission and access the pending state via [`useFetchers()`][use_fetchers].

```tsx
<Form method="post" navigate={false} />
```

### `fetcherKey`

When using a non-navigating `Form`, you may also optionally specify your own fetcher `key` to use.

```tsx
<Form method="post" navigate={false} fetcherKey="my-key" />
```

### `preventScrollReset`

If you are using [`<ScrollRestoration>`][scroll_restoration_component], this lets you prevent the scroll position from being reset to the top of the window when the form is submitted.

```tsx
<Form preventScrollReset />
```

### `replace`

Replaces the current entry in the history stack, instead of pushing the new entry.

```tsx
<Form replace />
```

### `reloadDocument`

If true, it will submit the form with the browser instead of client side routing. The same as a native `<form>`.

```tsx
<Form reloadDocument />
```

This is recommended over [`<form>`][form_element]. When the `action` prop is omitted, `<Form>` and `<form>` will sometimes call different actions depending on what the current URL is since `<form>` uses the current URL as the default, but `<Form>` uses the URL for the route the form is rendered in.

### `viewTransition`

The `viewTransition` prop enables a [View Transition][view-transitions] for this navigation by wrapping the final state update in [`document.startViewTransition()`][document-start-view-transition]. If you need to apply specific styles for this view transition, you will also need to leverage the [`useViewTransitionState()`][use-view-transition-state].

## Notes

### `?index`

Because index routes and their parent route share the same URL, the `?index` param is used to differentiate between them.

```tsx
<Form action="/accounts?index" method="post" />
```

| action url        | route action                     |
| ----------------- | -------------------------------- |
| `/accounts?index` | `app/routes/accounts._index.tsx` |
| `/accounts`       | `app/routes/accounts.tsx`        |

See also:

- [`?index` query param][index_query_param]

## Additional Resources

**Videos:**

- [Data Mutations with Form + action][data_mutations_with_form_action]
- [Multiple Forms and Single Button Mutations][multiple_forms_and_single_button_mutations]
- [Clearing Inputs After Form Submissions][clearing_inputs_after_form_submissions]

**Related Discussions:**

- [Fullstack Data Flow][fullstack_data_flow]
- [Pending UI][pending_ui]
- [Form vs. Fetcher][form_vs_fetcher]

**Related APIs:**

- [`useActionData`][use_action_data]
- [`useNavigation`][use_navigation]
- [`useSubmit`][use_submit]

[use_navigation]: ../hooks/use-navigation
[scroll_restoration_component]: ./scroll-restoration
[index_query_param]: ../guides/index-query-param
[http_verb]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods
[form_element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form
[use_action_data]: ../hooks/use-action-data
[use_submit]: ../hooks/use-submit
[data_mutations_with_form_action]: https://www.youtube.com/watch?v=Iv25HAHaFDs&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6
[multiple_forms_and_single_button_mutations]: https://www.youtube.com/watch?v=w2i-9cYxSdc&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6
[clearing_inputs_after_form_submissions]: https://www.youtube.com/watch?v=bMLej7bg5Zo&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6
[fullstack_data_flow]: ../discussion/data-flow
[pending_ui]: ../discussion/pending-ui
[form_vs_fetcher]: ../discussion/form-vs-fetcher
[use_fetcher]: ../hooks/use-fetcher
[use_fetchers]: ../hooks/use-fetchers
[fetcher_form]: ../hooks/use-fetcher#fetcherform
[progressive_enhancement]: ../discussion/progressive-enhancement
[view-transitions]: https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API
[document-start-view-transition]: https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition
[use-view-transition-state]: ../hooks/use-view-transition-state
[relativesplatpath]: ../hooks/use-resolved-path#splat-paths

---

## File: ./components/index.md

---

title: Components
order: 5

---

---

## File: ./components/link.md

---

## title: Link

# `<Link>`

A `<a href>` wrapper to enable navigation with client-side routing.

```tsx
import { Link } from '@remix-run/react';

<Link to="/dashboard">Dashboard</Link>;
```

<docs-info>Please see the [Splat Paths][relativesplatpath] section on the `useResolvedPath` docs for a note on the behavior of the `future.v3_relativeSplatPath` future flag for relative `<Link to>` behavior within splat routes</docs-info>

## Props

### `to: string`

The most basic usage takes an href string:

```tsx
<Link to="/some/path" />
```

### `to: Partial<Path>`

You can also pass a `Partial<Path>` value:

```tsx
<Link
  to={{
    pathname: '/some/path',
    search: '?query=string',
    hash: '#hash',
  }}
/>
```

### `discover`

Defines the route discovery behavior when using [`future.v3_lazyRouteDiscovery`][lazy-route-discovery].

```tsx
<>
  <Link /> {/* defaults to "render" */}
  <Link discover="none" />
</>
```

- **render** - default, discover the route when the link renders
- **none** - don't eagerly discover, only discover if the link is clicked

### `prefetch`

Defines the data and module prefetching behavior for the link.

```tsx
<>
  <Link /> {/* defaults to "none" */}
  <Link prefetch="none" />
  <Link prefetch="intent" />
  <Link prefetch="render" />
  <Link prefetch="viewport" />
</>
```

- **none** - default, no prefetching
- **intent** - prefetches when the user hovers or focuses the link
- **render** - prefetches when the link renders
- **viewport** - prefetches when the link is in the viewport, very useful for mobile

Prefetching is done with HTML `<link rel="prefetch">` tags. They are inserted after the link.

```tsx
<nav>
  <a href="..." />
  <a href="..." />
  <link rel="prefetch" /> {/* might conditionally render */}
</nav>
```

Because of this, if you are using `nav :last-child` you will need to use `nav :last-of-type` so the styles don't conditionally fall off your last link (and any other similar selectors).

### `preventScrollReset`

If you are using [`<ScrollRestoration>`][scroll-restoration-component], this lets you prevent the scroll position from being reset to the top of the window when the link is clicked.

```tsx
<Link to="?tab=one" preventScrollReset />
```

This does not prevent the scroll position from being restored when the user comes back to the location with the back/forward buttons, it just prevents the reset when the user clicks the link.

<details>

<summary>Discussion</summary>

An example when you might want this behavior is a list of tabs that manipulate the url search params that aren't at the top of the page. You wouldn't want the scroll position to jump up to the top because it might scroll the toggled content out of the viewport!

```text
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ                         ‚îú‚îÄ‚îÄ‚îê
      ‚îÇ                         ‚îÇ  ‚îÇ
      ‚îÇ                         ‚îÇ  ‚îÇ scrolled
      ‚îÇ                         ‚îÇ  ‚îÇ out of view
      ‚îÇ                         ‚îÇ  ‚îÇ
      ‚îÇ                         ‚îÇ ‚óÑ‚îò
    ‚îå‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îê
    ‚îÇ                             ‚îú‚îÄ‚îê
    ‚îÇ                             ‚îÇ ‚îÇ viewport
    ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ ‚îÇ
    ‚îÇ   ‚îÇ  tab   tab   tab    ‚îÇ   ‚îÇ ‚îÇ
    ‚îÇ   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ‚îÇ ‚îÇ
    ‚îÇ   ‚îÇ                     ‚îÇ   ‚îÇ ‚îÇ
    ‚îÇ   ‚îÇ                     ‚îÇ   ‚îÇ ‚îÇ
    ‚îÇ   ‚îÇ content             ‚îÇ   ‚îÇ ‚îÇ
    ‚îÇ   ‚îÇ                     ‚îÇ   ‚îÇ ‚îÇ
    ‚îÇ   ‚îÇ                     ‚îÇ   ‚îÇ ‚îÇ
    ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ ‚îÇ
    ‚îÇ                             ‚îÇ‚óÑ‚îò
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

```

</details>

### `relative`

Defines the relative path behavior for the link.

```tsx
<Link to=".." />; // default: "route"
<Link relative="route" />;
<Link relative="path" />;
```

- **route** - default, relative to the route hierarchy so `..` will remove all URL segments of the current route pattern
- **path** - relative to the path so `..` will remove one URL segment

### `reloadDocument`

Will use document navigation instead of client side routing when the link is clicked, the browser will handle the transition normally (as if it were an `<a href>`).

```tsx
<Link to="/logout" reloadDocument />
```

### `replace`

The `replace` prop will replace the current entry in the history stack instead of pushing a new one onto it.

```tsx
<Link replace />
```

```
# with a history stack like this
A -> B

# normal link click pushes a new entry
A -> B -> C

# but with `replace`, B is replaced by C
A -> C
```

### `state`

Adds persistent client side routing state to the next location.

```tsx
<Link to="/somewhere/else" state={{ some: 'value' }} />
```

The location state is accessed from the `location`.

```tsx
function SomeComp() {
  const location = useLocation();
  location.state; // { some: "value" }
}
```

This state is inaccessible on the server as it is implemented on top of [`history.state`][history-state].

## `viewTransition`

The `viewTransition` prop enables a [View Transition][view-transitions] for this navigation by wrapping the final state update in [`document.startViewTransition()`][document-start-view-transition]:

```jsx
<Link to={to} viewTransition>
  Click me
</Link>
```

If you need to apply specific styles for this view transition, you will also need to leverage the [`useViewTransitionState()`][use-view-transition-state]:

```jsx
function ImageLink(to) {
  const isTransitioning = useViewTransitionState(to);
  return (
    <Link to={to} viewTransition>
      <p
        style={{
          viewTransitionName: isTransitioning ? 'image-title' : '',
        }}
      >
        Image Number {idx}
      </p>
      <img
        src={src}
        alt={`Img ${idx}`}
        style={{
          viewTransitionName: isTransitioning ? 'image-expand' : '',
        }}
      />
    </Link>
  );
}
```

[scroll-restoration-component]: ./scroll-restoration
[history-state]: https://developer.mozilla.org/en-US/docs/Web/API/History/state
[view-transitions]: https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API
[document-start-view-transition]: https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition
[use-view-transition-state]: ../hooks/use-view-transition-state
[relativesplatpath]: ../hooks/use-resolved-path#splat-paths
[lazy-route-discovery]: ../guides/lazy-route-discovery

---

## File: ./components/links.md

---

title: Links
toc: false

---

# `<Links />`

The `<Links/>` component renders all of the [`<link>`][link_element] tags created by your route module [`links`][links] export. You should render it inside the [`<head>`][head_element] of your HTML, usually in `app/root.tsx`.

```tsx filename=app/root.tsx lines=[7]
import { Links } from '@remix-run/react';

export default function Root() {
  return (
    <html>
      <head>
        <Links />
      </head>
      <body></body>
    </html>
  );
}
```

[link_element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link
[head_element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head
[links]: ../route/links

---

## File: ./components/live-reload.md

---

title: LiveReload
toc: false

---

# `<LiveReload />`

This component connects your app to the Remix asset server and automatically reloads the page when files change in development. In production, it renders `null`, so you can safely render it always in your root route.

```tsx filename=app/root.tsx lines=[8]
import { LiveReload } from '@remix-run/react';

export default function Root() {
  return (
    <html>
      <head />
      <body>
        <LiveReload />
      </body>
    </html>
  );
}
```

## Props

### `origin`

Specify a custom origin for the Live Reload protocol. The url provided should use the `http` protocol, that will be upgraded to `ws` protocol internally. This is useful when using a reverse proxy in front of the Remix dev server. The default value is the `REMIX_DEV_ORIGIN` environment variable, or `window.location.origin` only if `REMIX_DEV_ORIGIN` is not set.

### `port`

Specify a custom port for the Live Reload protocol. The default value is the port derived from `REMIX_DEV_ORIGIN` environment variable, or `8002` only if `REMIX_DEV_ORIGIN` is not set.

### `timeoutMs`

The `timeoutMs` prop allows specifying a custom timeout for the Live Reload protocol, in milliseconds. This is the delay before trying to reconnect if the Web Socket connection is lost. The default value is `1000`.

---

## File: ./components/meta.md

---

title: Meta
toc: false

---

# `<Meta />`

This component renders all of the [`<meta>`][meta_element] tags created by your route module [`meta`][meta] export. You should render it inside the [`<head>`][head_element] of your HTML, usually in `app/root.tsx`.

```tsx filename=app/root.tsx lines=[7]
import { Meta } from '@remix-run/react';

export default function Root() {
  return (
    <html>
      <head>
        <Meta />
      </head>
      <body></body>
    </html>
  );
}
```

[meta_element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta
[head_element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head
[meta]: ../route/meta

---

## File: ./components/nav-link.md

---

## title: NavLink

# `<NavLink>`

Wraps [`<Link>`][link-component] with additional props for styling active and pending states.

```tsx
import { NavLink } from '@remix-run/react';

<NavLink
  to="/messages"
  className={({ isActive, isPending }) => (isPending ? 'pending' : isActive ? 'active' : '')}
>
  Messages
</NavLink>;
```

## Automatic Attributes

### `.active`

An `active` class is added to a `<NavLink>` component when it is active, so you can use CSS to style it.

```tsx
<NavLink to="/messages" />
```

```css
a.active {
  color: red;
}
```

### `aria-current`

When a `NavLink` is active it will automatically apply `<a aria-current="page">` to the underlying anchor tag. See [`aria-current`][aria-current] on MDN.

### `.pending`

A `pending` class is added to a `<NavLink>` component when it is pending during a navigation, so you can use CSS to style it.

```tsx
<NavLink to="/messages" />
```

```css
a.pending {
  color: red;
}
```

### `.transitioning`

A `transitioning` class is added to a [`<NavLink viewTransition>`][view-transition-prop] component when it is transitioning during a navigation, so you can use CSS to style it.

```tsx
<NavLink to="/messages" viewTransition />
```

```css
a.transitioning {
  view-transition-name: my-transition;
}
```

## Props

### `className` callback

Calls back with the active and pending states to allow customizing the class names applied.

```tsx
<NavLink
  to="/messages"
  className={({ isActive, isPending }) => (isPending ? 'pending' : isActive ? 'active' : '')}
>
  Messages
</NavLink>
```

### `style` callback

Calls back with the active and pending states to allow customizing the styles applied.

```tsx
<NavLink
  to="/messages"
  style={({ isActive, isPending }) => {
    return {
      fontWeight: isActive ? 'bold' : '',
      color: isPending ? 'red' : 'black',
    };
  }}
>
  Messages
</NavLink>
```

### `children` callback

Calls back with the active and pending states to allow customizing the content of the `<NavLink>`.

```tsx
<NavLink to="/tasks">
  {({ isActive, isPending }) => <span className={isActive ? 'active' : ''}>Tasks</span>}
</NavLink>
```

### `end`

The `end` prop changes the matching logic for the `active` and `pending` states to only match to the "end" of the `NavLinks`'s `to` path. If the URL is longer than `to`, it will no longer be considered active.

| Link                          | URL          | isActive |
| ----------------------------- | ------------ | -------- |
| `<NavLink to="/tasks" />`     | `/tasks`     | true     |
| `<NavLink to="/tasks" />`     | `/tasks/123` | true     |
| `<NavLink to="/tasks" end />` | `/tasks`     | true     |
| `<NavLink to="/tasks" end />` | `/tasks/123` | false    |

`<NavLink to="/">` is an exceptional case because _every_ URL matches `/`. To avoid this matching every single route by default, it effectively ignores the `end` prop and only matches when you're at the root route.

### `caseSensitive`

Adding the `caseSensitive` prop changes the matching logic to make it case-sensitive.

| Link                                         | URL           | isActive |
| -------------------------------------------- | ------------- | -------- |
| `<NavLink to="/SpOnGe-bOB" />`               | `/sponge-bob` | true     |
| `<NavLink to="/SpOnGe-bOB" caseSensitive />` | `/sponge-bob` | false    |

## `viewTransition`

The `viewTransition` prop enables a [View Transition][view-transitions] for this navigation by wrapping the final state update in [`document.startViewTransition()`][document-start-view-transition]. By default, during the transition a [`transitioning` class][transitioning-class] will be added to the [`<a>` element][a-element] that you can use to customize the view transition.

```css
a.transitioning p {
  view-transition-name: 'image-title';
}

a.transitioning img {
  view-transition-name: 'image-expand';
}
```

```tsx
<NavLink to={to} viewTransition>
  <p>Image Number {idx}</p>
  <img src={src} alt={`Img ${idx}`} />
</NavLink>
```

You may also use the [`className`][class-name-prop]/[`style`][style-prop] props or the render props passed to [`children`][children-prop] to further customize based on the `isTransitioning` value.

```tsx
<NavLink to={to} viewTransition>
  {({ isTransitioning }) => (
    <>
      <p
        style={{
          viewTransitionName: isTransitioning ? 'image-title' : '',
        }}
      >
        Image Number {idx}
      </p>
      <img
        src={src}
        alt={`Img ${idx}`}
        style={{
          viewTransitionName: isTransitioning ? 'image-expand' : '',
        }}
      />
    </>
  )}
</NavLink>
```

### `<Link>` props

All other props of [`<Link>`][link-component] are supported.

[link-component]: ./link
[aria-current]: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current
[view-transition-prop]: #unstableviewtransition
[view-transitions]: https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API
[document-start-view-transition]: https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition
[transitioning-class]: #transitioning
[a-element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a
[class-name-prop]: #classname-callback
[style-prop]: #style-callback
[children-prop]: #children-callback

---

## File: ./components/outlet.md

---

## title: Outlet

# `<Outlet>`

Renders the matching child route of a parent route.

```tsx
import { Outlet } from '@remix-run/react';

export default function SomeParent() {
  return (
    <div>
      <h1>Parent Content</h1>

      <Outlet />
    </div>
  );
}
```

## Props

### `context`

Provides a context value to the element tree below the outlet. Use when the parent route needs to provide values to child routes.

```tsx
<Outlet context={myContextValue} />
```

See also: [`useOutletContext`][use-outlet-context]

[use-outlet-context]: ../hooks/use-outlet-context

---

## File: ./components/prefetch-page-links.md

---

title: PrefetchPageLinks
toc: false

---

# `<PrefetchPageLinks />`

This component enables prefetching of all assets for a page to enable an instant navigation to that page. It does this by rendering `<link rel="prefetch">` and `<link rel="modulepreload"/>` tags for all the assets (data, modules, css) of a given page.

`<Link rel="prefetch">` uses this internally, but you can render it to prefetch a page for any other reason.

```tsx
<PrefetchPageLinks page="/absolute/path/to/your-path" />
```

**Note:** You need to use an absolute path.

---

## File: ./components/scripts.md

---

title: Scripts
toc: false

---

# `<Scripts />`

This component renders the client runtime of your app. You should render it inside the [`<body>`][body-element] of your HTML, usually in [`app/root.tsx`][root].

```tsx filename=app/root.tsx lines=[8]
import { Scripts } from '@remix-run/react';

export default function Root() {
  return (
    <html>
      <head />
      <body>
        <Scripts />
      </body>
    </html>
  );
}
```

If you don't render the `<Scripts/>` component, your app will still work like a traditional web app without JavaScript, relying solely on HTML and browser behaviors.

## Props

The `<Scripts>` component can pass through certain attributes to the underlying `<script>` tags such as:

- `<Scripts crossOrigin>` for hosting your static assets on a different server than your app.
- `<Scripts nonce>` to support a [content security policy for scripts][csp] with [nonce-sources][csp-nonce] for your `<script>` tags.

You cannot pass through attributes such as `async`/`defer`/`src`/`type`/`noModule` because they are managed by Remix internally.

[body-element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body
[csp]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src
[csp-nonce]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#sources
[root]: ../file-conventions/root

---

## File: ./components/scroll-restoration.md

---

## title: ScrollRestoration

# `<ScrollRestoration>`

This component will emulate the browser's scroll restoration on location changes after [`loader`][loader]s have completed. This ensures the scroll position is restored to the right spot, at the right time, even across domains.

You should only render one of these, right before the [`<Scripts/>`][scripts_component] component.

```tsx lines=[3,11]
import { Scripts, ScrollRestoration } from '@remix-run/react';

export default function Root() {
  return (
    <html>
      <body>
        {/* ... */}
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}
```

## Props

### `getKey`

Optional. Defines the key used to restore scroll positions.

```tsx
<ScrollRestoration
  getKey={(location, matches) => {
    // default behavior
    return location.key;
  }}
/>
```

<details>

<summary>Discussion</summary>

Using `location.key` emulates the browser's default behavior. The user can navigate to the same URL multiple times in the stack and each entry gets its own scroll position to restore.

Some apps may want to override this behavior and restore position based on something else. Consider a social app that has four primary pages:

- "/home"
- "/messages"
- "/notifications"
- "/search"

If the user starts at "/home", scrolls down a bit, clicks "messages" in the navigation menu, then clicks "home" in the navigation menu (not the back button!) there will be three entries in the history stack:

```
1. /home
2. /messages
3. /home
```

By default, React Router (and the browser) will have two different scroll positions stored for `1` and `3` even though they have the same URL. That means as the user navigated from `2` ‚Üí `3` the scroll position goes to the top instead of restoring to where it was in `1`.

A solid product decision here is to keep the users scroll position on the home feed no matter how they got there (back button or new link clicks). For this, you'd want to use the `location.pathname` as the key.

```tsx
<ScrollRestoration
  getKey={(location, matches) => {
    return location.pathname;
  }}
/>
```

Or you may want to only use the pathname for some paths, and use the normal behavior for everything else:

```tsx
<ScrollRestoration
  getKey={(location, matches) => {
    const paths = ['/home', '/notifications'];
    return paths.includes(location.pathname)
      ? // home and notifications restore by pathname
        location.pathname
      : // everything else by location like the browser
        location.key;
  }}
/>
```

</details>

### `nonce`

`<ScrollRestoration>` renders an inline [`<script>`][script_element] to prevent scroll flashing. The `nonce` prop will be passed down to the script tag to allow CSP nonce usage.

```tsx
<ScrollRestoration nonce={cspNonce} />
```

## Preventing Scroll Reset

When navigating to new locations, the scroll position is reset to the top of the page. You can prevent the "scroll to top" behavior from your links and forms:

```tsx
<Link preventScrollReset={true} />;
<Form preventScrollReset={true} />;
```

See also: [`<Form preventScrollReset>`][form_prevent_scroll_reset], [`<Link preventScrollReset>`][link_prevent_scroll_reset]

[loader]: ../route/loader
[scripts_component]: ./scripts
[script_element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script
[form_prevent_scroll_reset]: ../components/form#preventscrollreset
[link_prevent_scroll_reset]: ../components/link#preventscrollreset

---

## File: ./discussion/component-data.md

---

title: Component Data
hidden: true

---

# Component Data

---

## File: ./discussion/concurrency.md

---

## title: Network Concurrency Management

# Network Concurrency Management

When building web applications, managing network requests can be a daunting task. The challenges of ensuring up-to-date data and handling simultaneous requests often lead to complex logic in the application to deal with interruptions and race conditions. Remix simplifies this process by automating network management, mirroring and expanding the intuitive behavior of web browsers.

To help understand how Remix works, remember from [Fullstack Data Flow][fullstack_data_flow] that after `form` submissions, Remix will fetch fresh data from the loaders. This is called revalidation.

## Natural Alignment with Browser Behavior

Remix's handling of network concurrency is heavily inspired by the default behavior of web browsers when processing documents:

- **Browser Link Navigation**: When you click on a link in a browser and then click on another before the page transition completes, the browser prioritizes the most recent `action`. It cancels the initial request, focusing solely on the latest link clicked.

  - **Remix's Approach**: Remix manages client-side navigation the same way. When a link is clicked within a Remix application, it initiates fetch requests for each loader tied to the target URL. If another navigation interrupts the initial navigation, Remix cancels the previous fetch requests, ensuring that only the latest requests proceed.

- **Browser Form Submission**: If you initiate a form submission in a browser and then quickly submit another form again, the browser disregards the first submission, processing only the latest one.

  - **Remix's Approach**: Remix mimics this behavior when working with forms. If a form is submitted and another submission occurs before the first completes, Remix cancels the original fetch requests. It then waits for the latest submission to complete before triggering page revalidation again.

## Concurrent Submissions and Revalidation

While standard browsers are limited to one request at a time for navigations and form submissions, Remix elevates this behavior. Unlike navigation, with [`useFetcher`][use_fetcher] multiple requests can be in flight simultaneously.

Remix is designed to handle multiple form submissions to server `action`s and concurrent revalidation requests efficiently. It ensures that as soon as new data is available, the state is updated promptly. However, Remix also safeguards against potential pitfalls by refraining from committing stale data when other `action`s introduce race conditions.

For instance, if three form submissions are in progress, and one completes, Remix updates the UI with that data immediately without waiting for the other two so that the UI remains responsive and dynamic. As the remaining submissions finalize, Remix continues to update the UI, ensuring that the most recent data is displayed.

To help understand some visualizations, below is a key for the symbols used in the diagrams:

- `|`: Submission begins
- ‚úì: Action complete, data revalidation begins
- ‚úÖ: Revalidated data is committed to the UI
- ‚ùå: Request cancelled

```text
submission 1: |----‚úì-----‚úÖ
submission 2:    |-----‚úì-----‚úÖ
submission 3:             |-----‚úì-----‚úÖ
```

However, if a subsequent submission's revalidation completes before an earlier one, Remix discards the earlier data, ensuring that only the most up-to-date information is reflected in the UI.

```text
submission 1: |----‚úì---------‚ùå
submission 2:    |-----‚úì-----‚úÖ
submission 3:             |-----‚úì-----‚úÖ
```

Because the revalidation from submission (2) started later and landed earlier than submission (1), the requests from submission (1) are cancelled and only the data from submission (2) is committed to the UI. It was requested later so its more likely to contain the updated values from both (1) and (2).

## Potential for Stale Data

It's unlikely your users will ever experience this, but there are still chances for the user to see stale data in very rare conditions with inconsistent infrastructure. Even though Remix cancels requests for stale data, they will still end up making it to the server. Cancelling a request in the browser simply releases browser resources for that request, it can't "catch up" and stop it from getting to the server. In extremely rare conditions, a cancelled request may change data after the interrupting `action`'s revalidation lands. Consider this diagram:

```text
     üëá interruption with new submission
|----‚ùå----------------------‚úì
       |-------‚úì-----‚úÖ
                             üëÜ
                  initial request reaches the server
                  after the interrupting submission
                  has completed revalidation
```

The user is now looking at different data than what is on the server. Note that this problem is both extremely rare and exists with default browser behavior, too. The chance of the initial request reaching the server later than both the submission and revalidation of the second is unexpected on any network and server infrastructure. If this is a concern in with your infrastructure, you can send time stamps with your form submissions and write server logic to ignore stale submissions.

## Example

In UI components like combo boxes, each keystroke can trigger a network request. Managing such rapid, consecutive requests can be tricky, especially when ensuring that the displayed results match the most recent query. However, with Remix, this challenge is automatically handled, ensuring that users see the correct results without developers having to micromanage the network.

```tsx filename=app/routes/city-search.tsx
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno

export async function loader({ request }: LoaderFunctionArgs) {
  const { searchParams } = new URL(request.url);
  const cities = await searchCities(searchParams.get('q'));
  return json(cities);
}

export function CitySearchCombobox() {
  const fetcher = useFetcher<typeof loader>();

  return (
    <fetcher.Form action="/city-search">
      <Combobox aria-label="Cities">
        <ComboboxInput
          name="q"
          onChange={(event) =>
            // submit the form onChange to get the list of cities
            fetcher.submit(event.target.form)
          }
        />

        {/* render with the loader's data */}
        {fetcher.data ? (
          <ComboboxPopover className="shadow-popup">
            {fetcher.data.length > 0 ? (
              <ComboboxList>
                {fetcher.data.map((city) => (
                  <ComboboxOption key={city.id} value={city.name} />
                ))}
              </ComboboxList>
            ) : (
              <span>No results found</span>
            )}
          </ComboboxPopover>
        ) : null}
      </Combobox>
    </fetcher.Form>
  );
}
```

All the application needs to know is how to query the data and how to render it, Remix handles the network.

## Conclusion

Remix offers developers an intuitive, browser-based approach to managing network requests. By mirroring browser behaviors and enhancing them where needed, it simplifies the complexities of concurrency, revalidation, and potential race conditions. Whether you're building a simple webpage or a sophisticated web application, Remix ensures that your user interactions are smooth, reliable, and always up-to-date.

[fullstack_data_flow]: ./data-flow
[use_fetcher]: ../hooks/use-fetcher

---

## File: ./discussion/cookies-and-sessions.md

---

title: Cookies and Sessions
hidden: true

---

---

## File: ./discussion/data-flow.md

---

title: Fullstack Data Flow
order: 4

---

# Fullstack Data Flow

One of the primary features of Remix is the way it automatically keeps your UI in sync with persistent server state. It happens in three steps:

1. Route loaders provide data to the UI
2. Forms post data to route actions that update persistent state
3. Loader data on the page is automatically revalidated

<img class="tutorial rounded-xl" src="/blog-images/posts/remix-data-flow/loader-action-component.png" />

## Route Module Exports

Let's consider a user account edit route. The route module has three exports that we'll fill in and talk about:

```tsx filename=routes/account.tsx
export async function loader() {
  // provides data to the component
}

export default function Component() {
  // renders the UI
}

export async function action() {
  // updates persistent data
}
```

## Route Loader

Route files can export a [`loader`][loader] function that provides data to the route component. When the user navigates to a matching route, the data is first loaded and then the page is rendered.

```tsx filename=routes/account.tsx lines=[1-2,4-12]
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno

export async function loader({ request }: LoaderFunctionArgs) {
  const user = await getUser(request);
  return json({
    displayName: user.displayName,
    email: user.email,
  });
}

export default function Component() {
  // ...
}

export async function action() {
  // ...
}
```

## Route Component

The default export of the route file is the component that renders. It reads the loader data with [`useLoaderData`][use_loader_data]:

```tsx lines=[3,15-30]
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData, Form } from '@remix-run/react';

export async function loader({ request }: LoaderFunctionArgs) {
  const user = await getUser(request);
  return json({
    displayName: user.displayName,
    email: user.email,
  });
}

export default function Component() {
  const user = useLoaderData<typeof loader>();
  return (
    <Form method="post" action="/account">
      <h1>Settings for {user.displayName}</h1>

      <input name="displayName" defaultValue={user.displayName} />
      <input name="email" defaultValue={user.email} />

      <button type="submit">Save</button>
    </Form>
  );
}

export async function action() {
  // ...
}
```

## Route Action

Finally, the action on the route matching the form's action attribute is called when the form is submitted. In this example it's the same route. The values in the form fields will be available on the standard [`request.formData()`][request_form_data] API. Note the `name` attribute on the inputs is coupled to the [`formData.get(fieldName)`][form_data_get] getter.

```tsx lines=[2,35-47]
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData, Form } from '@remix-run/react';

export async function loader({ request }: LoaderFunctionArgs) {
  const user = await getUser(request);
  return json({
    displayName: user.displayName,
    email: user.email,
  });
}

export default function Component() {
  const user = useLoaderData<typeof loader>();
  return (
    <Form method="post" action="/account">
      <h1>Settings for {user.displayName}</h1>

      <input name="displayName" defaultValue={user.displayName} />
      <input name="email" defaultValue={user.email} />

      <button type="submit">Save</button>
    </Form>
  );
}

export async function action({ request }: ActionFunctionArgs) {
  const formData = await request.formData();
  const user = await getUser(request);

  await updateUser(user.id, {
    email: formData.get('email'),
    displayName: formData.get('displayName'),
  });

  return json({ ok: true });
}
```

## Submission and Revalidation

When the user submits the form:

1. Remix sends the form data to the route action via `fetch` and pending states become available through hooks like `useNavigation` and `useFetcher`.
2. After the action completes, loaders are revalidated to get the new server state.
3. `useLoaderData` returns the updated values from the server and the pending states go back to idle.

In this way, the UI is kept in sync with server state without writing any code for that synchronization.

There are various ways to submit a form besides an HTML form element (like in response to drag and drop, or an onChange event). There is also a lot more to talk about around form validation, error handling, pending states, etc. We'll get to all of that later, but this is the gist of data flow in Remix.

## Before JavaScript Loads

When you send HTML from the server, it's best to have it work even before JavaScript loads. Typical data flows in Remix do this automatically. The flow is the same, but the browser does some of the work.

When the user submits the form before JavaScript loads:

1. The browser submits the form to the action (instead of `fetch`) and the browsers pending states activate (spinning favicon)
2. After the action completes, loaders are called
3. Remix renders the page and sends HTML to the browser

[loader]: ../route/loader
[use_loader_data]: ../hooks/use-loader-data
[request_form_data]: https://developer.mozilla.org/en-US/docs/Web/API/Request/formData
[form_data_get]: https://developer.mozilla.org/en-US/docs/Web/API/FormData/get

---

## File: ./discussion/error-handling.md

---

title: Error Handling
hidden: true

---

# Error Handling

- unexpected
  - automatically handled
  - granular w/ route boundaries
  - granular w/ `<Await>` boundaries
- expected
  - 404s
  - 401s
  - 503s
  - can send data!

---

## File: ./discussion/formdata.md

---

title: Working with FormData
hidden: true

---

# Working with FormData

---

## File: ./discussion/form-validation.md

---

title: Form Validation
hidden: true

---

# Form Validation

---

## File: ./discussion/form-vs-fetcher.md

---

## title: Form vs. fetcher

# Form vs. fetcher

Developing in Remix offers a rich set of tools that can sometimes overlap in functionality, creating a sense of ambiguity for newcomers. The key to effective development in Remix is understanding the nuances and appropriate use cases for each tool. This document seeks to provide clarity on when and why to use specific APIs.

## APIs in Focus

- [`<Form>`][form_component]
- [`useActionData`][use_action_data]
- [`useFetcher`][use_fetcher]
- [`useNavigation`][use_navigation]

Understanding the distinctions and intersections of these APIs is vital for efficient and effective Remix development.

### URL Considerations

The primary criterion when choosing among these tools is whether you want the URL to change or not:

- **URL Change Desired**: When navigating or transitioning between pages, or after certain actions like creating or deleting records. This ensures that the user's browser history accurately reflects their journey through your application.

  - **Expected Behavior**: In many cases, when users hit the back button, they should be taken to the previous page. Other times the history entry may be replaced but the URL change is important nonetheless.

- **No URL Change Desired**: For actions that don't significantly change the context or primary content of the current view. This might include updating individual fields or minor data manipulations that don't warrant a new URL or page reload. This also applies to loading data with fetchers for things like popovers, combo boxes, etc.

### Specific Use Cases

#### When the URL Should Change

These actions typically reflect significant changes to the user's context or state:

- **Creating a New Record**: After creating a new record, it's common to redirect users to a page dedicated to that new record, where they can view or further modify it.

- **Deleting a Record**: If a user is on a page dedicated to a specific record and decides to delete it, the logical next step is to redirect them to a general page, such as a list of all records.

For these cases, developers should consider using a combination of [`<Form>`][form_component], [`useActionData`][use_action_data], and [`useNavigation`][use_navigation]. Each of these tools can be coordinated to handle form submission, invoke specific actions, retrieve action-related data, and manage navigation respectively.

#### When the URL Shouldn't Change

These actions are generally more subtle and don't require a context switch for the user:

- **Updating a Single Field**: Maybe a user wants to change the name of an item in a list or update a specific property of a record. This action is minor and doesn't necessitate a new page or URL.

- **Deleting a Record from a List**: In a list view, if a user deletes an item, they likely expect to remain on the list view, with that item no longer in the list.

- **Creating a Record in a List View**: When adding a new item to a list, it often makes sense for the user to remain in that context, seeing their new item added to the list without a full page transition.

- **Loading Data for a Popover or Combobox**: When loading data for a popover or combobox, the user's context remains unchanged. The data is loaded in the background and displayed in a small, self-contained UI element.

For such actions, [`useFetcher`][use_fetcher] is the go-to API. It's versatile, combining functionalities of the other four APIs, and is perfectly suited for tasks where the URL should remain unchanged.

## API Comparison

As you can see, the two sets of APIs have a lot of similarities:

| Navigation/URL API      | Fetcher API          |
| ----------------------- | -------------------- |
| `<Form>`                | `<fetcher.Form>`     |
| `useActionData()`       | `fetcher.data`       |
| `navigation.state`      | `fetcher.state`      |
| `navigation.formAction` | `fetcher.formAction` |
| `navigation.formData`   | `fetcher.formData`   |

## Examples

### Creating a New Record

```tsx filename=app/routes/recipes/new.tsx lines=[18,22-23,28]
import type { ActionFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { redirect } from '@remix-run/node'; // or cloudflare/deno
import { Form, useActionData, useNavigation } from '@remix-run/react';

export async function action({ request }: ActionFunctionArgs) {
  const formData = await request.formData();
  const errors = await validateRecipeFormData(formData);
  if (errors) {
    return json({ errors });
  }
  const recipe = await db.recipes.create(formData);
  return redirect(`/recipes/${recipe.id}`);
}

export function NewRecipe() {
  const { errors } = useActionData<typeof action>();
  const navigation = useNavigation();
  const isSubmitting = navigation.formAction === '/recipes/new';

  return (
    <Form method="post">
      <label>
        Title: <input name="title" />
        {errors?.title ? <span>{errors.title}</span> : null}
      </label>
      <label>
        Ingredients: <textarea name="ingredients" />
        {errors?.ingredients ? <span>{errors.ingredients}</span> : null}
      </label>
      <label>
        Directions: <textarea name="directions" />
        {errors?.directions ? <span>{errors.directions}</span> : null}
      </label>
      <button type="submit">{isSubmitting ? 'Saving...' : 'Create Recipe'}</button>
    </Form>
  );
}
```

The example leverages [`<Form>`][form_component], [`useActionData`][use_action_data], and [`useNavigation`][use_navigation] to facilitate an intuitive record creation process.

Using `<Form>` ensures direct and logical navigation. After creating a record, the user is naturally guided to the new recipe's unique URL, reinforcing the outcome of their action.

`useActionData` bridges server and client, providing immediate feedback on submission issues. This quick response enables users to rectify any errors without hindrance.

Lastly, `useNavigation` dynamically reflects the form's submission state. This subtle UI change, like toggling the button's label, assures users that their actions are being processed.

Combined, these APIs offer a balanced blend of structured navigation and feedback.

### Updating a Record

Now consider we're looking at a list of recipes that have delete buttons on each item. When a user clicks the delete button, we want to delete the recipe from the database and remove it from the list without navigating away from the list.

First consider the basic route setup to get a list of recipes on the page:

```tsx filename=app/routes/recipes/_index.tsx
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData } from '@remix-run/react';

export async function loader({ request }: LoaderFunctionArgs) {
  return json({
    recipes: await db.recipes.findAll({ limit: 30 }),
  });
}

export default function Recipes() {
  const { recipes } = useLoaderData<typeof loader>();
  return (
    <ul>
      {recipes.map((recipe) => (
        <RecipeListItem key={recipe.id} recipe={recipe} />
      ))}
    </ul>
  );
}
```

Now we'll look at the action that deletes a recipe and the component that renders each recipe in the list.

```tsx filename=app/routes/recipes/_index.tsx lines=[7,13,19]
export async function action({ request }: ActionFunctionArgs) {
  const formData = await request.formData();
  const id = formData.get('id');
  await db.recipes.delete(id);
  return json({ ok: true });
}

const RecipeListItem: FunctionComponent<{
  recipe: Recipe;
}> = ({ recipe }) => {
  const fetcher = useFetcher();
  const isDeleting = fetcher.state !== 'idle';

  return (
    <li>
      <h2>{recipe.title}</h2>
      <fetcher.Form method="post">
        <button disabled={isDeleting} type="submit">
          {isDeleting ? 'Deleting...' : 'Delete'}
        </button>
      </fetcher.Form>
    </li>
  );
};
```

Using [`useFetcher`][use_fetcher] in this scenario works perfectly. Instead of navigating away or refreshing the entire page, we want in-place updates. When a user deletes a recipe, the action called and the fetcher manages the corresponding state transitions.

The key advantage here is the maintenance of context. The user stays on the list when the deletion completes. The fetcher's state management capabilities are leveraged to give real-time feedback: it toggles between `"Deleting..."` and `"Delete"`, providing a clear indication of the ongoing process.

Furthermore, with each fetcher having the autonomy to manage its own state, operations on individual list items become independent, ensuring that actions on one item don't affect the others (though revalidation of the page data is a shared concern that is covered in [Network Concurrency Management][network_concurrency_management]).

In essence, `useFetcher` offers a seamless mechanism for actions that don't necessitate a change in the URL or navigation, enhancing the user experience by providing real-time feedback and context preservation.

### Mark Article as Read

Imagine you want to mark that an article has been read by the current user, after they've been on the page for a while and scrolled to the bottom. You could make a hook that looks something like this:

```tsx
function useMarkAsRead({ articleId, userId }) {
  const marker = useFetcher();

  useSpentSomeTimeHereAndScrolledToTheBottom(() => {
    marker.submit(
      { userId },
      {
        action: `/article/${articleId}/mark-as-read`,
        method: 'post',
      },
    );
  });
}
```

### User Avatar Details Popup

Anytime you show the user avatar, you could put a hover effect that fetches data from a loader and displays it in a popup.

```tsx filename=app/routes/users.$id.details.tsx
export async function loader({ params }: LoaderFunctionArgs) {
  return json(await fakeDb.user.find({ where: { id: params.id } }));
}

function UserAvatar({ partialUser }) {
  const userDetails = useFetcher<typeof loader>();
  const [showDetails, setShowDetails] = useState(false);

  useEffect(() => {
    if (showDetails && userDetails.state === 'idle' && !userDetails.data) {
      userDetails.load(`/users/${user.id}/details`);
    }
  }, [showDetails, userDetails]);

  return (
    <div onMouseEnter={() => setShowDetails(true)} onMouseLeave={() => setShowDetails(false)}>
      <img src={partialUser.profileImageUrl} />
      {showDetails ? (
        userDetails.state === 'idle' && userDetails.data ? (
          <UserPopup user={userDetails.data} />
        ) : (
          <UserPopupLoading />
        )
      ) : null}
    </div>
  );
}
```

## Conclusion

Remix offers a range of tools to cater to varied developmental needs. While some functionalities might seem to overlap, each tool has been crafted with specific scenarios in mind. By understanding the intricacies and ideal applications of `<Form>`, `useActionData`, `useFetcher`, and `useNavigation`, developers can create more intuitive, responsive, and user-friendly web applications.

[form_component]: ../components/form
[use_action_data]: ../hooks/use-action-data
[use_fetcher]: ../hooks/use-fetcher
[use_navigation]: ../hooks/use-navigation
[network_concurrency_management]: ./concurrency

---

## File: ./discussion/hot-module-replacement.md

---

## title: Hot Module Replacement

# Hot Module Replacement

Hot Module Replacement is a technique for updating modules in your app without needing to reload the page.
It's a great developer experience, and Remix supports it out of the box.

Notably, HMR does its best to preserve browser state across updates.
If you have form within a modal, and you fill out all the fields traditional live reload would hard refresh the page.
So you'd lose all the data in the form.
Every time you make a change, you'd have to open up the modal _again_ and fill out the form _again_. üò≠

But with HMR, all that state is preserved _across updates_. ‚ú®

## React Fast Refresh

React already has mechanisms for updating the DOM via its [virtual DOM][virtual-dom] in response to user interactions like clicking a button.
Wouldn't it be great if React could handle updating the DOM in response to code changes too?

That's exactly what [React Fast Refresh][react-refresh] is all about!
Of course, React is all about components, not general JavaScript code, so RFR by itself only handles hot updates for exported React components.

But React Fast Refresh does have some limitations that you should be aware of.

### Class Component State

React Fast Refresh does not preserve state for class components.
This includes higher-order components that internally return classes:

```tsx
export class ComponentA extends Component {} // ‚ùå

export const ComponentB = HOC(ComponentC); // ‚ùå Won't work if HOC returns a class component

export function ComponentD() {} // ‚úÖ
export const ComponentE = () => {}; // ‚úÖ
export default function ComponentF() {} // ‚úÖ
```

### Named Function Components

Function components must be named, not anonymous, for React Fast Refresh to track changes:

```tsx
export default () => {}; // ‚ùå
export default function () {} // ‚ùå

const ComponentA = () => {};
export default ComponentA; // ‚úÖ

export default function ComponentB() {} // ‚úÖ
```

### Supported Exports

React Fast Refresh can only handle component exports. While Remix manages special route exports like [`action`][action], [`headers`][headers], [`links`][links], [`loader`][loader], and [`meta`][meta] for you, any user-defined exports will cause full reloads:

```tsx
// These exports are handled by the Remix Vite plugin
// to be HMR-compatible
export const meta = { title: 'Home' }; // ‚úÖ
export const links = [{ rel: 'stylesheet', href: 'style.css' }]; // ‚úÖ

// These exports are removed by the Remix Vite plugin
// so they never affect HMR
export const headers = { 'Cache-Control': 'max-age=3600' }; // ‚úÖ
export const loader = async () => {}; // ‚úÖ
export const action = async () => {}; // ‚úÖ

// This is not a Remix export, nor a component export,
// so it will cause a full reload for this route
export const myValue = 'some value'; // ‚ùå

export default function Route() {} // ‚úÖ
```

üëÜ Routes probably shouldn't be exporting random values like that anyway.
If you want to reuse values across routes, stick them in their own non-route module:

```ts filename=my-custom-value.ts
export const myValue = 'some value';
```

### Changing Hooks

React Fast Refresh cannot track changes for a component when hooks are being added or removed from it, causing full reloads just for the next render. After the hooks have been updated, changes should result in hot updates again. For example, if you add [`useLoaderData`][use-loader-data] to your component, you may lose state local to that component for that render.

Additionally, if you are destructuring a hook's return value, React Fast Refresh will not be able to preserve state for the component if the destructured key is removed or renamed.
For example:

```tsx
export const loader = async () => {
  return json({ stuff: 'some things' });
};

export default function Component() {
  const { stuff } = useLoaderData<typeof loader>();
  return (
    <div>
      <input />
      <p>{stuff}</p>
    </div>
  );
}
```

If you change the key `stuff` to `things`:

```diff
  export const loader = async () => {
-   return json({ stuff: "some things" })
+   return json({ things: "some things" })
  }

  export default Component() {
-   const { stuff } = useLoaderData<typeof loader>()
+   const { things } = useLoaderData<typeof loader>()
    return (
      <div>
        <input />
-       <p>{stuff}</p>
+       <p>{things}</p>
      </div>
    )
  }
```

then React Fast Refresh will not be able to preserve state `<input />` ‚ùå.

As a workaround, you could refrain from destructuring and instead use the hook's return value directly:

```tsx
export const loader = async () => {
  return json({ stuff: 'some things' });
};

export default function Component() {
  const data = useLoaderData<typeof loader>();
  return (
    <div>
      <input />
      <p>{data.stuff}</p>
    </div>
  );
}
```

Now if you change the key `stuff` to `things`:

```diff
  export const loader = async () => {
-   return json({ stuff: "some things" })
+   return json({ things: "some things" })
  }

  export default Component() {
    const data = useLoaderData<typeof loader>()
    return (
      <div>
        <input />
-       <p>{data.stuff}</p>
+       <p>{data.things}</p>
      </div>
    )
  }
```

Then React Fast Refresh will preserve state for the `<input />`, though you may need to use component keys as described in the next section if the stateful element (e.g. `<input />`) is a sibling of the changed element.

### Component Keys

In some cases, React cannot distinguish between existing components being changed and new components being added. [React needs `key`s][react-keys] to disambiguate these cases and track changes when sibling elements are modified.

[virtual-dom]: https://reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom
[react-refresh]: https://github.com/facebook/react/tree/main/packages/react-refresh
[action]: ../route/action
[headers]: ../route/headers
[links]: ../route/links
[loader]: ../route/loader
[meta]: ../route/meta
[use-loader-data]: ../hooks/use-loader-data
[react-keys]: https://react.dev/learn/rendering-lists#why-does-react-need-keys

---

## File: ./discussion/html-forms.md

---

title: HTML Form APIs
hidden: true

---

# HTML Form APIs

---

## File: ./discussion/index.md

---

title: Discussion Topics
order: 2

---

---

## File: ./discussion/introduction.md

---

title: Introduction, Technical Explanation
order: 1

---

# Introduction, Technical Explanation

Built on top of [React Router][react_router], Remix is four things:

1. A compiler
2. A server-side HTTP handler
3. A server framework
4. A browser framework

## Compiler

Everything in Remix starts with the compiler: `remix vite:build`. Using [Vite], this creates a few things:

1. A server HTTP handler, usually in `build/server/index.js` (it's configurable) that includes all routes and modules together to be able to render on the server and handle any other server-side requests for resources.
2. A browser build, usually in `build/client/*`. This includes automatic code splitting by route, fingerprinted asset imports (like CSS and images), etc. Anything needed to run an application in the browser.
3. An asset manifest. Both the client and the server use this manifest to know the entire dependency graph. This is useful for preloading resources in the initial server render as well as prefetching them for client-side transitions. This is how Remix is able to eliminate the render+fetch waterfalls so common in web apps today.

With these build artifacts, an application can be deployed to any hosting service that runs JavaScript.

## HTTP Handler and Adapters

While Remix runs on the server, it is not actually a server. It's just a handler that is given to an actual JavaScript server.

It's built on the [Web Fetch API][fetch] instead of Node.js. This enables Remix to run in any Node.js server like [Vercel][vercel], [Netlify][netlify], [Architect][arc], etc. as well as non-Node.js environments like [Cloudflare Workers][cf] and [Deno Deploy][deno].

This is what Remix looks like when running in an express app:

```ts lines=[2,6-9]
const remix = require('@remix-run/express');
const express = require('express');

const app = express();

app.all(
  '*',
  remix.createRequestHandler({
    build: require('./build/server'),
  }),
);
```

Express (or Node.js) is the actual server, Remix is just a handler on that server. The `"@remix-run/express"` package is called an adapter. Remix handlers are server agnostic. Adapters make them work for a specific server by converting the server's request/response API into the Fetch API on the way in, and then adapting the Fetch Response coming from Remix into the server's response API. Here's some pseudocode of what an adapter does:

```ts
export function createRequestHandler({ build }) {
  // creates a Fetch API request handler from the server build
  const handleRequest = createRemixRequestHandler(build);

  // returns an express.js specific handler for the express server
  return async (req, res) => {
    // adapts the express.req to a Fetch API request
    const request = createRemixRequest(req);

    // calls the app handler and receives a Fetch API response
    const response = await handleRequest(request);

    // adapts the Fetch API response to the express.res
    sendRemixResponse(res, response);
  };
}
```

Real adapters do a bit more than that, but that's the gist of it. Not only does this enable you to deploy Remix anywhere, but it also lets you incrementally adopt it in an existing JavaScript server since you can have routes outside of Remix that your server continues to handle before getting to Remix.

Additionally, if Remix doesn't have an adapter for your server already, you can look at the source of one of the adapters and build your own.

## Server Framework

If you're familiar with server-side MVC web frameworks like Rails and Laravel, Remix is the View and Controller, but it leaves the Model up to you. There are a lot of great databases, ORMs, mailers, etc. in the JavaScript ecosystem to fill that space. Remix also has helpers around the Fetch API for cookie and session management.

Instead of having a split between View and Controller, Remix Route modules take on both responsibilities.

Most server-side frameworks are "model focused". A controller manages _multiple URLs_ for a single model.

Remix is _UI focused_. Routes can handle an entire URL or just a segment of the URL. When a route maps to just a segment, the nested URL segments become nested layouts in the UI. In this way, each layout (view) can be its own controller and then Remix will aggregate the data and components to build the complete UI.

More often than not, a Remix route module can contain both the UI and the interactions with the models in the same file, which leads to really nice developer ergonomics and productivity.

Route modules have three primary exports: `loader`, `action`, and `default` (component).

```tsx
// Loaders only run on the server and provide data
// to your component on GET requests
export async function loader() {
  return json(await db.projects.findAll());
}

// The default export is the component that will be
// rendered when a route matches the URL. This runs
// both on the server and the client
export default function Projects() {
  const projects = useLoaderData<typeof loader>();
  const actionData = useActionData<typeof action>();

  return (
    <div>
      {projects.map((project) => (
        <Link key={project.slug} to={project.slug}>
          {project.title}
        </Link>
      ))}

      <Form method="post">
        <input name="title" />
        <button type="submit">Create New Project</button>
      </Form>
      {actionData?.errors ? <ErrorMessages errors={actionData.errors} /> : null}

      {/* outlets render the nested child routes
          that match the URL deeper than this route,
          allowing each layout to co-locate the UI and
          controller code in the same file */}
      <Outlet />
    </div>
  );
}

// Actions only run on the server and handle POST
// PUT, PATCH, and DELETE. They can also provide data
// to the component
export async function action({ request }: ActionFunctionArgs) {
  const form = await request.formData();
  const errors = validate(form);
  if (errors) {
    return json({ errors });
  }
  await createProject({ title: form.get('title') });
  return json({ ok: true });
}
```

You can actually use Remix as just a server-side framework without using any browser JavaScript at all. The route conventions for data loading with `loader`, mutations with `action` and HTML forms, and components that render at URLs, can provide the core feature set of a lot of web projects.

In this way, **Remix scales down**. Not every page in your application needs a bunch of JavaScript in the browser and not every user interaction requires any extra flair than the browser's default behaviors. In Remix, you can build it the simple way first, and then scale up without changing the fundamental model. Additionally, the majority of the app works before JavaScript loads in the browser, which makes Remix apps resilient to choppy network conditions by design.

If you're not familiar with traditional back-end web frameworks, you can think of Remix routes as React components that are already their own API route and already know how to load and submit data to themselves on the server.

## Browser Framework

Once Remix has served the document to the browser, it "hydrates" the page with the browser build's JavaScript modules. This is where we talk a lot about Remix "emulating the browser".

When the user clicks a link, instead of making a round trip to the server for the entire document and all the assets, Remix simply fetches the data for the next page and updates the UI.

Additionally, when users submit a `<Form>` to update data, instead of doing a normal HTML document request, the browser runtime will make a fetch to the server instead and automatically revalidate all data on the page and update it with React.

This has many performance benefits over making a full-document request:

1. Assets don't need to be re-downloaded (or pulled from cache)
2. Assets don't need to be parsed by the browser again
3. The data fetched is much smaller than the entire document (sometimes orders of magnitude)
4. Because Remix enhances HTML APIs (`<a>` and `<form>`), your app tends to work even before JavaScript has loaded on the page

Remix also has some built in optimizations for client-side navigation. It knows which layouts will persist between the two URLs, so it only fetches the data for the ones that are changing. A full document request would require all data to be fetched on the server, wasting resources on your back end and slowing down your app.

This approach also has UX benefits like not resetting the scroll position of a sidebar nav and allowing you to move focus to something that makes more sense than the top of the document.

Remix can also prefetch all resources for a page when the user is about to click a link. The browser framework knows about the compiler's asset manifest. It can match the URL of the link, read the manifest, and then prefetch all data, JavaScript modules, and even CSS resources for the next page. This is how Remix apps feel fast even when networks are slow.

Remix then provides client side APIs, so you can create rich user experiences without changing the fundamental model of HTML and browsers.

Taking our route module from before, here are a few small, but useful UX improvements to the form that you can only do with JavaScript in the browser:

1. Disable the button when the form is being submitted
2. Focus the input when server-side form validation fails
3. Animate in the error messages

```tsx lines=[4-6,8-12,23-26,30-32] nocopy
export default function Projects() {
  const projects = useLoaderData<typeof loader>();
  const actionData = useActionData<typeof action>();
  const { state } = useNavigation();
  const busy = state === 'submitting';
  const inputRef = React.useRef();

  React.useEffect(() => {
    if (actionData.errors) {
      inputRef.current.focus();
    }
  }, [actionData]);

  return (
    <div>
      {projects.map((project) => (
        <Link key={project.slug} to={project.slug}>
          {project.title}
        </Link>
      ))}

      <Form method="post">
        <input ref={inputRef} name="title" />
        <button type="submit" disabled={busy}>
          {busy ? 'Creating...' : 'Create New Project'}
        </button>
      </Form>

      {actionData?.errors ? (
        <FadeIn>
          <ErrorMessages errors={actionData.errors} />
        </FadeIn>
      ) : null}

      <Outlet />
    </div>
  );
}
```

What's most interesting about this code sample is that it is **only additive**. The entire interaction is still fundamentally the same thing and even works at a basic level before JavaScript loads, the only difference is the user feedback will be provided by the browser (spinning favicon, etc.) instead of the app (`useNavigation().state`).

Because Remix reaches into the controller level of the backend, it can do this seamlessly.

And while it doesn't reach as far back into the stack as server-side frameworks like Rails and Laravel, it does reach way farther up the stack into the browser to make the transition from the back end to the front end seamless.

For example. Building a plain HTML form and server-side handler in a back-end heavy web framework is just as easy to do as it is in Remix. But as soon as you want to cross over into an experience with animated validation messages, focus management, and pending UI, it requires a fundamental change in the code. Typically, people build an API route and then bring in a splash of client-side JavaScript to connect the two. With Remix, you simply add some code around the existing "server side view" without changing how it works fundamentally. The browser runtime takes over the server communication to provide an enhanced user experience beyond the default browser behaviors.

We borrowed an old term and called this Progressive Enhancement in Remix. Start small with a plain HTML form (Remix scales down) and then scale the UI up when you have the time and ambition.

[vite]: https://vitejs.dev
[cf]: https://workers.cloudflare.com/
[deno]: https://deno.com/deploy/docs
[fetch]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[vercel]: https://vercel.com
[netlify]: https://netlify.com
[arc]: https://arc.codes
[react_router]: https://reactrouter.com

---

## File: ./discussion/multiple-forms.md

---

title: Multiple Forms on a Page
hidden: true

---

# Multiple Forms on a Page

---

## File: ./discussion/nested-routes.md

---

title: Layouts and Nested Routes
hidden: true

---

# Layouts and Nested Routes

---

## File: ./discussion/pending-ui.md

---

title: Pending UI
order: 8

---

# Pending and Optimistic UI

The difference between a great user experience on the web and mediocre one is how well the developer implements network-aware user interface feedback by providing visual cues during network-intensive actions. There are three main types of pending UI: busy indicators, optimistic UI, and skeleton fallbacks. This document provides guidelines for selecting and implementing the appropriate feedback mechanism based on specific scenarios.

## Pending UI Feedback Mechanisms

**Busy Indicators**: Busy indicators display visual cues to users while an action is being processed by the server. This feedback mechanism is used when the application cannot predict the outcome of the action and must wait for the server's response before updating the UI.

**Optimistic UI**: Optimistic UI enhances perceived speed and responsiveness by immediately updating the UI with an expected state before the server's response is received. This approach is used when the application can predict the outcome of an action based on context and user input, allowing for an immediate response to actions.

**Skeleton Fallbacks**: Skeleton fallbacks are used when the UI is initially loading, providing users with a visual placeholder that outlines the structure of the upcoming content. This feedback mechanism is particularly useful to render something useful as soon as possible.

## Guiding Principles for Feedback Selection

Use Optimistic UI:

- **Next State Predictability**: The application can accurately predict the next state of the UI based on the user's action.
- **Error Handling**: Robust error handling mechanisms are in place to address potential errors that may occur during the process.
- **URL Stability**: The action does not result in a change of the URL, ensuring that the user remains within the same page.

Use Busy Indicators:

- **Next State Uncertainty**: The outcome of the action cannot be reliably predicted, necessitating waiting for the server's response.
- **URL Change**: The action leads to a change in the URL, indicating navigation to a new page or section.
- **Error Boundaries**: The error handling approach primarily relies on error boundaries that manage exceptions and unexpected behavior.
- **Side Effects**: The action triggers side effects that involve critical processes, such as sending email, processing payments, etc.

Use Skeleton Fallbacks:

- **Initial Loading**: The UI is in the process of loading, providing users with a visual indication of upcoming content structure.
- **Critical Data**: The data is not critical for the initial rendering of the page, allowing the skeleton fallback to be displayed while the data is loading.
- **App-Like Feel**: The application is designed to resemble the behavior of a standalone app, allowing for immediate transitions to the fallbacks.

## Examples

### Page Navigation

**Busy Indicator**: You can indicate the user is navigating to a new page with [`useNavigation`][use_navigation]:

```tsx
import { useNavigation } from '@remix-run/react';

function PendingNavigation() {
  const navigation = useNavigation();
  return navigation.state === 'loading' ? <div className="spinner" /> : null;
}
```

### Pending Links

**Busy Indicator**: You can indicate on the nav link itself that the user is navigating to it with the [`<NavLink className>`][nav_link_component_classname] callback.

```tsx lines=[10-12]
import { NavLink } from '@remix-run/react';

export function ProjectList({ projects }) {
  return (
    <nav>
      {projects.map((project) => (
        <NavLink
          key={project.id}
          to={project.id}
          className={({ isPending }) => (isPending ? 'pending' : null)}
        >
          {project.name}
        </NavLink>
      ))}
    </nav>
  );
}
```

Or add a spinner next to it by inspecting params:

```tsx lines=[1,4,10-12]
import { useParams } from '@remix-run/react';

export function ProjectList({ projects }) {
  const params = useParams();
  return (
    <nav>
      {projects.map((project) => (
        <NavLink key={project.id} to={project.id}>
          {project.name}
          {params.projectId === project.id ? <Spinner /> : null}
        </NavLink>
      ))}
    </nav>
  );
}
```

While localized indicators on links are nice, they are incomplete. There are many other ways a navigation can be triggered: form submissions, back and forward button clicks in the browser, action redirects, and imperative `navigate(path)` calls, so you'll typically want a global indicator to capture everything.

### Record Creation

**Busy Indicator**: It's typically best to wait for a record to be created instead of using optimistic UI since things like IDs and other fields are unknown until it completes. Also note this action redirects to the new record from the action.

```tsx filename=app/routes/create-project.tsx lines=[2,13,21-22,26,35]
import type { ActionFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { redirect } from '@remix-run/node'; // or cloudflare/deno
import { useNavigation } from '@remix-run/react';

export async function action({ request }: ActionFunctionArgs) {
  const formData = await request.formData();
  const project = await createRecord({
    name: formData.get('name'),
    owner: formData.get('owner'),
  });
  return redirect(`/projects/${project.id}`);
}

export default function CreateProject() {
  const navigation = useNavigation();

  // important to check you're submitting to the action
  // for the pending UI, not just any action
  const isSubmitting = navigation.formAction === '/create-project';

  return (
    <Form method="post" action="/create-project">
      <fieldset disabled={isSubmitting}>
        <label>
          Name: <input type="text" name="projectName" />
        </label>
        <label>
          Owner: <UserSelect />
        </label>
        <button type="submit">Create</button>
      </fieldset>
      {isSubmitting ? <BusyIndicator /> : null}
    </Form>
  );
}
```

You can do the same with [`useFetcher`][use_fetcher], which is useful if you aren't changing the URL (maybe adding the record to a list)

```tsx lines=[5]
import { useFetcher } from '@remix-run/react';

function CreateProject() {
  const fetcher = useFetcher();
  const isSubmitting = fetcher.state === 'submitting';

  return (
    <fetcher.Form method="post" action="/create-project">
      {/* ... */}
    </fetcher.Form>
  );
}
```

### Record Updates

**Optimistic UI**: When the UI simply updates a field on a record, optimistic UI is a great choice. Many, if not most user interactions in a web app tend to be updates, so this is a common pattern.

```tsx lines=[6-8,19,22]
import { useFetcher } from '@remix-run/react';

function ProjectListItem({ project }) {
  const fetcher = useFetcher();

  const starred = fetcher.formData
    ? // use optimistic value if submitting
      fetcher.formData.get('starred') === '1'
    : // fall back to the database state
      project.starred;

  return (
    <>
      <div>{project.name}</div>
      <fetcher.Form method="post">
        <button
          type="submit"
          name="starred"
          // use optimistic value to allow interruptions
          value={starred ? '0' : '1'}
        >
          {/* üëá display optimistic value */}
          {starred ? '‚òÖ' : '‚òÜ'}
        </button>
      </fetcher.Form>
    </>
  );
}
```

## Deferred Data Loading

**Skeleton Fallback**: When data is deferred, you can add fallbacks with [`<Suspense>`][suspense_component]. This allows the UI to render without waiting for the data to load, speeding up the perceived and actual performance of the application.

```tsx lines=[11-14,24-28]
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { defer } from '@remix-run/node'; // or cloudflare/deno
import { Await } from '@remix-run/react';
import { Suspense } from 'react';

export async function loader({ params }: LoaderFunctionArgs) {
  const reviewsPromise = getReviews(params.productId);
  const product = await getProduct(params.productId);
  return defer({
    product: product,
    reviews: reviewsPromise,
  });
}

export default function ProductRoute() {
  const { product, reviews } = useLoaderData<typeof loader>();
  return (
    <>
      <ProductPage product={product} />

      <Suspense fallback={<ReviewsSkeleton />}>
        <Await resolve={reviews}>{(reviews) => <Reviews reviews={reviews} />}</Await>
      </Suspense>
    </>
  );
}
```

When creating skeleton fallbacks, consider the following principles:

- **Consistent Size:** Ensure that the skeleton fallbacks match the dimensions of the actual content. This prevents sudden layout shifts, providing a smoother and more visually cohesive loading experience. In terms of web performance, this trade-off minimizes [Cumulative Layout Shift][cumulative_layout_shift] (CLS) in favor of improving [First Contentful Paint][first_contentful_paint] (FCP). You can minimize the trade with accurate dimensions in the fallback.
- **Critical Data:** Avoid using fallbacks for essential information‚Äîthe main content of the page. This is especially important for SEO and meta tags. If you delay showing critical data, accurate meta tags can't be provided, and search engines won't correctly index your page.
- **App-Like Feel**: For web application UI that doesn't have SEO concerns, it can be beneficial to use skeleton fallbacks more extensively. This creates an interface that resembles the behavior of a standalone app. When users click on links, they get an instantaneous transition to the skeleton fallbacks.
- **Link Prefetching:** Using [`<Link prefetch="intent">`][link-component-prefetch] can often skip the fallbacks completely. When users hover or focus on the link, this method preloads the needed data, allowing the network a quick moment to fetch content before the user clicks. This often results in an immediate navigation to the next page.

## Conclusion

Creating network-aware UI via busy indicators, optimistic UI, and skeleton fallbacks significantly improves the user experience by showing visual cues during actions that require network interaction. Getting good at this is the best way to build applications your users trust.

[use_navigation]: ../hooks/use-navigation
[nav_link_component_classname]: ../components/nav-link#classname-callback
[use_fetcher]: ../hooks/use-fetcher
[suspense_component]: https://react.dev/reference/react/Suspense
[cumulative_layout_shift]: https://web.dev/cls
[first_contentful_paint]: https://web.dev/fcp
[link-component-prefetch]: ../components/link#prefetch

---

## File: ./discussion/progressive-enhancement.md

---

title: Progressive Enhancement
order: 7

---

# Progressive Enhancement

> Progressive enhancement is a strategy in web design that puts emphasis on web content first, allowing everyone to access the basic content and functionality of a web page, whilst users with additional browser features or faster Internet access receive the enhanced version instead.

<cite>- [Wikipedia][wikipedia]</cite>

Coined in 2003 by Steven Champeon & Nick Finck, the phrase emerged during a time of varied CSS and JavaScript support across different browsers, with many users actually browsing the web with JavaScript disabled.

Today, we are fortunate to develop for a much more consistent web and where the majority of users have JavaScript enabled.

However, we still believe in the core principles of progressive enhancement in Remix. It leads to fast and resilient apps with simple development workflows.

**Performance**: While it's easy to think that only 5% of your users have slow connections, the reality is that 100% of your users have slow connections 5% of the time.

**Resilience**: Everybody has JavaScript disabled until it's loaded.

**Simplicity**: Building your apps in a progressively enhanced way with Remix is actually simpler than building a traditional SPA.

## Performance

Sending HTML from the server allows your app to do more things in parallel than a typical Single Page App (SPA), making the initial loading experience and subsequent navigations faster.

Typical SPAs send a blank document and only start doing work when JavaScript has loaded.

```
HTML        |---|
JavaScript      |---------|
Data                      |---------------|
                            page rendered üëÜ
```

A Remix app can start doing work the moment the request hits the server and stream the response so that the browser can start downloading JavaScript, other assets, and data in parallel.

```
               üëá first byte
HTML        |---|-----------|
JavaScript      |---------|
Data        |---------------|
              page rendered üëÜ
```

## Resilience and Accessibility

While your users probably don't browse the web with JavaScript disabled, everybody has JavaScript disabled until it has finished loading. As soon as you begin server rendering your UI, you need to account for what happens when they try to interact with your app before JavaScript has loaded.

Remix embraces progressive enhancement by building its abstraction on top of HTML. This means that you can build your app in a way that works without JavaScript, and then layer on JavaScript to enhance the experience.

The simplest case is a `<Link to="/account">`. These render an `<a href="/account">` tag that works without JavaScript. When JavaScript loads, Remix will intercept clicks and handle the navigation with client side routing. This gives you more control over the UX instead of just spinning favicons in the browser tab--but it works either way.

Now consider a simple add to cart button.

```tsx
export function AddToCart({ id }) {
  return (
    <Form method="post" action="/add-to-cart">
      <input type="hidden" name="id" value={id} />
      <button type="submit">Add To Cart</button>
    </Form>
  );
}
```

Whether JavaScript has loaded or not doesn't matter, this button will add the product to the cart.

When JavaScript loads, Remix will intercept the form submission and handle it client side. This allows you to add your own pending UI, or other client side behavior.

## Simplicity

When you start to rely on basic features of the web like HTML and URLs, you will find that you reach for client side state and state management much less.

Consider the button from before, with no fundamental change to the code, we can pepper in some client side behavior:

```tsx lines=[1,4,7,10-12,14]
import { useFetcher } from '@remix-run/react';

export function AddToCart({ id }) {
  const fetcher = useFetcher();

  return (
    <fetcher.Form method="post" action="/add-to-cart">
      <input name="id" value={id} />
      <button type="submit">{fetcher.state === 'submitting' ? 'Adding...' : 'Add To Cart'}</button>
    </fetcher.Form>
  );
}
```

This feature continues to work the very same as it did before when JavaScript is loading, but once JavaScript loads:

- `useFetcher` no longer causes a navigation like `<Form>` does, so the user can stay on the same page and keep shopping
- The app code determines the pending UI instead of spinning favicons in the browser

It's not about building it two different ways‚Äìonce for JavaScript and once without‚Äìit's about building it in iterations. Start with the simplest version of the feature and ship it; then iterate to an enhanced user experience.

Not only will the user get a progressively enhanced experience, but the app developer gets to "progressively enhance" the UI without changing the fundamental design of the feature.

Another example where progressive enhancement leads to simplicity is with the URL. When you start with a URL, you don't need to worry about client side state management. You can just use the URL as the source of truth for the UI.

```tsx
export function SearchBox() {
  return (
    <Form method="get" action="/search">
      <input type="search" name="query" />
      <SearchIcon />
    </Form>
  );
}
```

This component doesn't need any state management. It just renders a form that submits to `/search`. When JavaScript loads, Remix will intercept the form submission and handle it client side. This allows you to add your own pending UI, or other client side behavior. Here's the next iteration:

```tsx lines=[1,4-6,11]
import { useNavigation } from '@remix-run/react';

export function SearchBox() {
  const navigation = useNavigation();
  const isSearching = navigation.location.pathname === '/search';

  return (
    <Form method="get" action="/search">
      <input type="search" name="query" />
      {isSearching ? <Spinner /> : <SearchIcon />}
    </Form>
  );
}
```

No fundamental change in architecture, simply a progressive enhancement for both the user and the code.

See also: [State Management][state_management]

[wikipedia]: https://en.wikipedia.org/wiki/Progressive_enhancement
[state_management]: ./state-management

---

## File: ./discussion/react-router.md

---

title: React Router
order: 6

---

# React Router

While Remix works as a multipage app, when JavaScript is loaded, it uses client side routing for a full Single Page App user experience, with all the speed and network efficiency that comes along with it.

Remix is built on top of [React Router][react_router] and maintained by the same team. This means that you can use all the features of React Router in your Remix app.

This also means that the 90% of Remix is really just React Router: a very old, very stable library that is perhaps the largest dependency in the React ecosystem. Remix simply adds a server behind it.

## Importing Components and Hooks

Remix re-exports all the components and hooks from React Router DOM, so you don't need to install React Router yourself.

üö´ Don't do this:

```tsx bad
import { useLocation } from 'react-router-dom';
```

‚úÖ Do this:

```tsx good
import { useLocation } from '@remix-run/react';
```

## Extended Behavior

Some of the components and hooks have been extended to work with Remix's server-rendering and data fetching features. For example, `Link` can prefetch data and resources in Remix, where the React Router version cannot.

üö´ Don't do this:

```tsx bad
import { Link } from 'react-router-dom';

// this won't do anything
<Link prefetch="intent" />;
```

‚úÖ Do this:

```tsx good
import { Link } from '@remix-run/react';

// this will prefetch data and assets
<Link prefetch="intent" />;
```

[react_router]: https://reactrouter.com

---

## File: ./discussion/resubmissions.md

---

## title: Form Resubmissions

# Form Resubmissions

When you use `<Form method="post">` in Remix, as opposed to using the native HTML `<form method="post">`, Remix does not adhere to the default browser behavior for resubmitting forms during navigation events like clicking back, forward, or refreshing.

## The Browser's Default Behavior

In a standard browser environment, form submissions are navigation events. This means that when a user clicks the back button, the browser will typically resubmit the form. For example:

1. User visits `/buy`
2. Submits a form to `/checkout`
3. Navigates to `/order/123`

The browser history stack would look like this:

```
GET /buy > POST /checkout > *GET /order/123
```

If the user clicks the back button, the history becomes:

```
GET /buy - *POST /checkout < GET /order/123
```

In this situation, the browser resubmits the form data, which could lead to issues such as charging a credit card twice.

## Redirecting from `action`s

A common practice to avoid this issue is to issue a redirect after the POST request. This removes the POST action from the browser's history. The history stack would then look like this:

```
GET /buy > POST /checkout, Redirect > GET /order/123
```

With this approach, clicking the back button would not resubmit the form:

```
GET /buy - *GET /order/123
```

## Specific Scenarios to Consider

While accidental resubmissions generally don't happen in Remix, there are specific scenarios where they might.

- You used `<form>` instead of `<Form>`
- You used `<Form reloadDocument>`
- You are not rendering `<Scripts/>`
- JavaScript is disabled by the user
- JavaScript had not loaded when the form was submitted

It's advisable to implement a redirect from the action to avoid unintended resubmissions.

## Additional Resources

**Guides**

- [Form Validation][form_validation]

**API**

- [`<Form>`][form]
- [`useActionData`][use_action_data]
- [`redirect`][redirect]

[form_validation]: ../guides/form-validation
[form]: ../components/form
[use_action_data]: ../hooks/use-action-data
[redirect]: ../utils/redirect

---

## File: ./discussion/routes.md

---

title: Route Configuration
order: 3

---

# Route Configuration

One of the foundational concepts in Remix's routing system is the use of nested routes, an approach that traces its roots back to Ember.js. With nested routes, segments of the URL are coupled to both data dependencies and the UI's component hierarchy. A URL like `/sales/invoices/102000` not only reveals a clear path in the application but also delineates the relationships and dependencies for different components.

## Modular Design

Nested routes provide clarity by segmenting URLs into multiple parts. Each segment directly correlates with a particular data requirement and component. For instance, in the URL `/sales/invoices/102000`, each segment - `sales`, `invoices`, and `102000` - can be associated with specific data points and UI sections, making it intuitive to manage in the codebase.

A feature of nested routing is the ability for several routes in the nested route tree to match a single URL. This granularity ensures that each route is primarily focused on its specific URL segment and related slice of UI. This approach champions the principles of modularity and separation of concerns, ensuring each route remains focused on its core responsibilities.

<iframe src="/_docs/routing" class="w-full aspect-[1/1] rounded-lg overflow-hidden pb-4"></iframe>

## Parallel Loading

In some web applications, the sequential loading of data and assets can sometimes lead to an artificially slow user experience. Even when data dependencies aren't interdependent, they may be loaded sequentially because they are coupled to rendering hierarchy, creating an undesirable chain of requests.

Remix leverages its nested routing system to optimize load times. When a URL matches multiple routes, Remix will load the required data and assets for all matching routes in parallel. By doing this, Remix effectively sidesteps the conventional pitfall of chained request sequences.

This strategy, combined with modern browsers' capability to handle multiple concurrent requests efficiently, positions Remix as a front-runner in delivering highly responsive and swift web applications. It's not just about making your data fetching fast; it's about fetching it in an organized way to provide the best possible experience for the end user.

## Conventional Route Configuration

Remix introduces a key convention to help streamline the routing process: the `app/routes` folder. When a developer introduces a file within this folder, Remix inherently understands it as a route. This convention simplifies the process of defining routes, associating them with URLs, and rendering the associated components.

Here's a sample directory that uses the routes folder convention:

```text
app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ _index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ about.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts._index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts.$city.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts.trending.tsx
‚îÇ   ‚îî‚îÄ‚îÄ concerts.tsx
‚îî‚îÄ‚îÄ root.tsx
```

All the routes that start with `app/routes/concerts.` will be child routes of `app/routes/concerts.tsx`.

| URL                        | Matched Route                      | Layout                    |
| -------------------------- | ---------------------------------- | ------------------------- |
| `/`                        | `app/routes/_index.tsx`            | `app/root.tsx`            |
| `/about`                   | `app/routes/about.tsx`             | `app/root.tsx`            |
| `/concerts`                | `app/routes/concerts._index.tsx`   | `app/routes/concerts.tsx` |
| `/concerts/trending`       | `app/routes/concerts.trending.tsx` | `app/routes/concerts.tsx` |
| `/concerts/salt-lake-city` | `app/routes/concerts.$city.tsx`    | `app/routes/concerts.tsx` |

## Conventional Route Folders

For routes that require additional modules or assets, a folder inside of `app/routes` with a `route.tsx` file can be used. This method:

- **Co-locates Modules**: It gathers all elements connected to a particular route, ensuring logic, styles, and components are closely knit.
- **Simplifies Imports**: With related modules in one place, managing imports becomes straightforward, enhancing code maintainability.
- **Facilitates Automatic Code Organization**: Using the `route.tsx` setup inherently promotes a well-organized codebase, beneficial as the application scales.

The same routes from above could instead be organized like this:

```text
app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ _index/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signup-form.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.tsx
‚îÇ   ‚îú‚îÄ‚îÄ about/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ header.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ favorites-cookie.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts.$city/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts._index/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ featured.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.tsx
‚îÇ   ‚îî‚îÄ‚îÄ concerts.trending/
‚îÇ       ‚îú‚îÄ‚îÄ card.tsx
‚îÇ       ‚îú‚îÄ‚îÄ route.tsx
‚îÇ       ‚îî‚îÄ‚îÄ sponsored.tsx
‚îî‚îÄ‚îÄ root.tsx
```

You can read more about the specific patterns in the file names and other features in the [Route File Conventions][route-file-conventions] reference.

Only the folders directly beneath `app/routes` will be registered as a route. Deeply nested folders are ignored. The file at `app/routes/about/header/route.tsx` will not create a route.

```text bad lines=[4]
app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îî‚îÄ‚îÄ about/
‚îÇ       ‚îú‚îÄ‚îÄ header/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ route.tsx
‚îÇ       ‚îî‚îÄ‚îÄ route.tsx
‚îî‚îÄ‚îÄ root.tsx
```

## Manual Route Configuration

While the `app/routes` folder offers a convenient convention for developers, Remix appreciates that [one size doesn't fit all][routes-disclaimer]. There are times when the provided convention might not align with specific project requirements or a developer's preferences. In such cases, Remix allows for manual route configuration via [`vite.config.ts`][vite-routes]. This flexibility ensures developers can structure their application in a way that makes sense for their project.

<docs-warning>If you have not yet migrated to [Vite][remix-vite] and are still using the [Classic Remix Compiler][classic-remix-compiler], you can configure routes manually in your [`remix.config.js`][remix-config] file.</docs-warning>

A common way to structure an app is by top-level features folders. Consider that routes related to a particular theme, like concerts, likely share several modules. Organizing them under a single folder makes sense:

```text
app/
‚îú‚îÄ‚îÄ about/
‚îÇ   ‚îî‚îÄ‚îÄ route.tsx
‚îú‚îÄ‚îÄ concerts/
‚îÇ   ‚îú‚îÄ‚îÄ card.tsx
‚îÇ   ‚îú‚îÄ‚îÄ city.tsx
‚îÇ   ‚îú‚îÄ‚îÄ favorites-cookie.ts
‚îÇ   ‚îú‚îÄ‚îÄ home.tsx
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îú‚îÄ‚îÄ sponsored.tsx
‚îÇ   ‚îî‚îÄ‚îÄ trending.tsx
‚îú‚îÄ‚îÄ home/
‚îÇ   ‚îú‚îÄ‚îÄ header.tsx
‚îÇ   ‚îî‚îÄ‚îÄ route.tsx
‚îî‚îÄ‚îÄ root.tsx
```

To configure this structure into the same URLs as the previous examples, you can use the `routes` function in `vite.config.ts`:

```ts filename=vite.config.ts
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [
    remix({
      routes(defineRoutes) {
        return defineRoutes((route) => {
          route('/', 'home/route.tsx', { index: true });
          route('about', 'about/route.tsx');
          route('concerts', 'concerts/layout.tsx', () => {
            route('', 'concerts/home.tsx', { index: true });
            route('trending', 'concerts/trending.tsx');
            route(':city', 'concerts/city.tsx');
          });
        });
      },
    }),
  ],
});
```

Remix's route configuration approach blends convention with flexibility. You can use the `app/routes` folder for an easy, organized way to set up your routes. If you want more control, dislike the file names, or have unique needs, there's `vite.config.ts`. It is expected that many apps forgo the routes folder convention in favor of `vite.config.ts`.

[route-file-conventions]: ../file-conventions/routes
[remix-config]: ../file-conventions/remix-config
[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ../guides/vite
[vite-routes]: ../file-conventions/vite-config#routes
[routes-disclaimer]: ../file-conventions/routes#disclaimer

---

## File: ./discussion/runtimes.md

---

title: Runtimes, Adapters, Templates, and Deployment
order: 2

---

# Runtimes, Adapters, Templates, and Deployment

Deploying a Remix application has four layers:

1. A JavaScript Runtime like Node.js
2. A JavaScript web server like Express.js
3. A server adapter like `@remix-run/express`
4. A web host or platform

Depending on your web host, you may have fewer layers. For example, deploying to Cloudflare Pages takes care of 2, 3, and 4 all at once. Deploying Remix inside an Express app will have all four, and using the "Remix App Server" combines 2 and 3!

You can wire all of these up yourself, or start with a Remix Template.

Let's talk about what each part does.

## JavaScript Runtimes

Remix can be deployed to any JavaScript runtime like Node.js, Shopify Oxygen, Cloudflare Workers/Pages, Fastly Compute, Deno, Bun, etc.

Each runtime has varying support for the standard Web APIs that Remix is built on, so Remix runtime package is required to polyfill any missing features of the runtime. These polyfills include web standard APIs like Request, Response, crypto, and more. This allows you to use the same APIs on the server as in the browser.

The following runtimes packages are available:

- [`@remix-run/cloudflare-pages`][remix_run_cloudflare_pages]
- [`@remix-run/cloudflare-workers`][remix_run_cloudflare_workers]
- [`@remix-run/deno`][remix_run_deno]
- [`@remix-run/node`][remix_run_node]

The majority of the APIs you interact with in your app are not imported directly from these packages, so your code is fairly portable between runtimes. However, occasionally you'll import something from these packages for a specific feature that isn't a standard Web API.

For example, you might want to store cookies on the file system, or in Cloudflare KV storage. These are specific features of runtimes that aren't shared with other runtimes:

```tsx
// store sessions in cloudflare KV storage
import { createWorkersKVSessionStorage } from '@remix-run/cloudflare';

// store sessions on the file system in node
import { createFileSessionStorage } from '@remix-run/node';
```

But if you're storing a session in the cookie itself, this is supported in all runtimes:

```tsx
import { createCookieSessionStorage } from '@remix-run/node'; // or cloudflare/deno
```

## Adapters

Remix is not an HTTP server, but rather a handler inside an existing HTTP server. Adapters allow the Remix handler to run inside the HTTP server. Some JavaScript runtimes, especially Node.js, have multiple ways to create an HTTP server. For example, in Node.js you can use Express.js, fastify, or raw `http.createServer`.

Each of these servers has its own Request/Response API. The adapter's job is to convert the incoming request to a Web Fetch Request, run the Remix handler, and then adapt the Web Fetch Response back to the host server's response API.

Here's some pseudocode that illustrates the flow.

```tsx
// import the app build created by `remix build`
import build from './build/index.js';

// an express http server
const app = express();

// and here your Remix app is "just a request handler"
app.all('*', createRequestHandler({ build }));

// This is pseudo code, but illustrates what adapters do:
export function createRequestHandler({ build }) {
  // creates a Fetch API request handler from the server build
  const handleRequest = createRemixRequestHandler(build);

  // returns an express.js specific handler for the express server
  return async (req, res) => {
    // adapts the express.req to a Fetch API request
    const request = createRemixRequest(req);

    // calls the app handler and receives a Fetch API response
    const response = await handleRequest(request);

    // adapts the Fetch API response to the express.res
    sendRemixResponse(res, response);
  };
}
```

### Remix App Server

For convenience, the Remix App Server is a basic express server for new projects, tinkering, or projects that don't have any specific needs from a server like Express and are deployed to Node.js environments.

See [`@remix-run/serve`][serve]

## Templates

Remix is designed to be incredibly flexible with just enough opinions to connect the UI to the back end, but it doesn't bring opinions on the database you use, how you cache data, or where and how your app is deployed.

Remix templates are starting points for app development with all of these extra opinions baked in, created by the community.

You can use a template with the `--template` flag in the Remix CLI that points to a repository on GitHub:

```
npx create-remix@latest --template <org>/<repo>
```

You can read more about templates in the [Templates Guide][templates_guide].

Once you've picked a template or [set up an app from scratch][quickstart], you're ready to start building your app!

[templates]: https://remix.guide/templates
[serve]: ../other-api/serve
[quickstart]: ../start/quickstart
[templates_guide]: ../guides/templates
[remix_run_cloudflare_pages]: https://npm.im/@remix-run/cloudflare-pages
[remix_run_cloudflare_workers]: https://npm.im/@remix-run/cloudflare-workers
[remix_run_deno]: https://npm.im/@remix-run/deno
[remix_run_node]: https://npm.im/@remix-run/node

---

## File: ./discussion/server-vs-client.md

---

title: Server vs. Client Code Execution
order: 5

---

# Server vs. Client Code Execution

Remix runs your app on the server as well as in the browser. However, it doesn't run all of your code in both places.

During the build step, the compiler creates both a server build and a client build. The server build bundles up everything into a single module (or multiple modules when using [server bundles][server-bundles]), but the client build splits your app up into multiple bundles to optimize loading in the browser. It also removes server code from the bundles.

The following route exports and the dependencies used within them are removed from the client build:

- [`action`][action]
- [`headers`][headers]
- [`loader`][loader]

Consider this route module from the last section:

```tsx filename=routes/settings.tsx
import type { ActionFunctionArgs, HeadersFunction, LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData } from '@remix-run/react';

import { getUser, updateUser } from '../user';

export const headers: HeadersFunction = () => ({
  'Cache-Control': 'max-age=300, s-maxage=3600',
});

export async function loader({ request }: LoaderFunctionArgs) {
  const user = await getUser(request);
  return json({
    displayName: user.displayName,
    email: user.email,
  });
}

export default function Component() {
  const user = useLoaderData<typeof loader>();
  return (
    <Form action="/account">
      <h1>Settings for {user.displayName}</h1>

      <input name="displayName" defaultValue={user.displayName} />
      <input name="email" defaultValue={user.email} />

      <button type="submit">Save</button>
    </Form>
  );
}

export async function action({ request }: ActionFunctionArgs) {
  const formData = await request.formData();
  const user = await getUser(request);

  await updateUser(user.id, {
    email: formData.get('email'),
    displayName: formData.get('displayName'),
  });

  return json({ ok: true });
}
```

The server build will contain the entire module in the final bundle. However, the client build will remove the `action`, `headers` and `loader`, along with the dependencies, resulting in this:

```tsx filename=routes/settings.tsx
import { useLoaderData } from '@remix-run/react';

export default function Component() {
  const user = useLoaderData();
  return (
    <Form action="/account">
      <h1>Settings for {user.displayName}</h1>

      <input name="displayName" defaultValue={user.displayName} />
      <input name="email" defaultValue={user.email} />

      <button type="submit">Save</button>
    </Form>
  );
}
```

## Splitting Up Client and Server Code

Out of the box, Vite doesn't support mixing server-only code with client-safe code in the same module.
Remix is able to make an exception for routes because we know which exports are server-only and can remove them from the client.

There are a few ways to isolate server-only code in Remix.
The simplest approach is to use [`.server`][file_convention_server] and [`.client`][file_convention_client] modules.

#### `.server` modules

While not strictly necessary, [`.server` modules][file_convention_server] are a good way to explicitly mark entire modules as server-only.
The build will fail if any code in a `.server` file or `.server` directory accidentally ends up in the client module graph.

```txt
app
‚îú‚îÄ‚îÄ .server üëà marks all files in this directory as server-only
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts
‚îÇ   ‚îî‚îÄ‚îÄ db.ts
‚îú‚îÄ‚îÄ cms.server.ts üëà marks this file as server-only
‚îú‚îÄ‚îÄ root.tsx
‚îî‚îÄ‚îÄ routes
    ‚îî‚îÄ‚îÄ _index.tsx
```

`.server` modules must be within your Remix app directory.

<docs-warning>`.server` directories are only supported when using [Remix Vite][remix-vite]. The [Classic Remix Compiler][classic-remix-compiler] only supports `.server` files.</docs-warning>

#### `.client` modules

You may depend on client libraries that are unsafe to even bundle on the server ‚Äî maybe it tries to access [`window`][window_global] by simply being imported.

You can remove the contents of these modules from the server build by appending `*.client.ts` to the file name or nesting them within a `.client` directory.

<docs-warning>`.client` directories are only supported when using [Remix Vite][remix-vite]. The [Classic Remix Compiler][classic-remix-compiler] only supports `.client` files.</docs-warning>

#### vite-env-only

If you want to mix server-only code and client-safe code in the same module, you
can use <nobr>[vite-env-only][vite-env-only]</nobr>.
This Vite plugin allows you to explicitly mark any expression as server-only so that it gets
replaced with `undefined` in the client.

For example, once you've added the plugin to your [Vite config][vite-config], you can wrap any server-only exports with `serverOnly$`:

```tsx
import { serverOnly$ } from 'vite-env-only';

import { db } from '@/.server/db';

export const getPosts = serverOnly$(async () => {
  return db.posts.findMany();
});

export const PostPreview = ({ title, description }) => {
  return (
    <article>
      <h2>{title}</h2>
      <p>{description}</p>
    </article>
  );
};
```

This example would be compiled into the following code for the client:

```tsx
export const getPosts = undefined;

export const PostPreview = ({ title, description }) => {
  return (
    <article>
      <h2>{title}</h2>
      <p>{description}</p>
    </article>
  );
};
```

[action]: ../route/action
[headers]: ../route/headers
[loader]: ../route/loader
[file_convention_client]: ../file-conventions/-client
[file_convention_server]: ../file-conventions/-server
[window_global]: https://developer.mozilla.org/en-US/docs/Web/API/Window/window
[server-bundles]: ../guides/server-bundles
[vite-config]: ../file-conventions/vite-config
[vite-env-only]: https://github.com/pcattori/vite-env-only
[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ../guides/vite

---

## File: ./discussion/state-management.md

---

title: State Management
order: 9

---

# State Management

State management in React typically involves maintaining a synchronized cache of server data on the client side. However, with Remix, most of the traditional caching solutions become redundant because of how it inherently handles data synchronization.

## Understanding State Management in React

In a typical React context, when we refer to "state management", we're primarily discussing how we synchronize server state with the client. A more apt term could be "cache management" because the server is the source of truth and the client state is mostly functioning as a cache.

Popular caching solutions in React include:

- **Redux:** A predictable state container for JavaScript apps.
- **React Query:** Hooks for fetching, caching, and updating asynchronous data in React.
- **Apollo:** A comprehensive state management library for JavaScript that integrates with GraphQL.

In certain scenarios, using these libraries may be warranted. However, with Remix's unique server-focused approach, their utility becomes less prevalent. In fact, most Remix applications forgo them entirely.

## How Remix Simplifies State

As discussed in [Fullstack Data Flow][fullstack_data_flow] Remix seamlessly bridges the gap between the backend and frontend via mechanisms like loaders, actions, and forms with automatic synchronization through revalidation. This offers developers the ability to directly use server state within components without managing a cache, the network communication, or data revalidation, making most client-side caching redundant.

Here's why using typical React state patterns might be an antipattern in Remix:

1. **Network-related State:** If your React state is managing anything related to the network‚Äîsuch as data from loaders, pending form submissions, or navigational states‚Äîit's likely that you're managing state that Remix already manages:

   - **[`useNavigation`][use_navigation]**: This hook gives you access to `navigation.state`, `navigation.formData`, `navigation.location`, etc.
   - **[`useFetcher`][use_fetcher]**: This facilitates interaction with `fetcher.state`, `fetcher.formData`, `fetcher.data` etc.
   - **[`useLoaderData`][use_loader_data]**: Access the data for a route.
   - **[`useActionData`][use_action_data]**: Access the data from the latest action.

2. **Storing Data in Remix:** A lot of data that developers might be tempted to store in React state has a more natural home in Remix, such as:

   - **URL Search Params:** Parameters within the URL that hold state.
   - **Cookies:** Small pieces of data stored on the user's device.
   - **Server Sessions:** Server-managed user sessions.
   - **Server Caches:** Cached data on the server side for quicker retrieval.

3. **Performance Considerations:** At times, client state is leveraged to avoid redundant data fetching. With Remix, you can use the [`Cache-Control`][cache_control_header] headers within `loader`s, allowing you to tap into the browser's native cache. However, this approach has its limitations and should be used judiciously. It's usually more beneficial to optimize backend queries or implement a server cache. This is because such changes benefit all users and do away with the need for individual browser caches.

As a developer transitioning to Remix, it's essential to recognize and embrace its inherent efficiencies rather than applying traditional React patterns. Remix offers a streamlined solution to state management leading to less code, fresh data, and no state synchronization bugs.

## Examples

### Network Related State

For examples on using Remix's internal state to manage network related state, refer to [Pending UI][pending_ui].

### URL Search Params

Consider a UI that lets the user customize between list view or detail view. Your instinct might be to reach for React state:

```tsx bad lines=[2,6,9]
export function List() {
  const [view, setView] = React.useState('list');
  return (
    <div>
      <div>
        <button onClick={() => setView('list')}>View as List</button>
        <button onClick={() => setView('details')}>View with Details</button>
      </div>
      {view === 'list' ? <ListView /> : <DetailView />}
    </div>
  );
}
```

Now consider you want the URL to update when the user changes the view. Note the state synchronization:

```tsx bad lines=[10,19,27]
import { useNavigate, useSearchParams } from '@remix-run/react';

export function List() {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const [view, setView] = React.useState(searchParams.get('view') || 'list');

  return (
    <div>
      <div>
        <button
          onClick={() => {
            setView('list');
            navigate(`?view=list`);
          }}
        >
          View as List
        </button>
        <button
          onClick={() => {
            setView('details');
            navigate(`?view=details`);
          }}
        >
          View with Details
        </button>
      </div>
      {view === 'list' ? <ListView /> : <DetailView />}
    </div>
  );
}
```

Instead of synchronizing state, you can simply read and set the state in the URL directly with boring old HTML forms.

```tsx good lines=[5,9-16]
import { Form, useSearchParams } from '@remix-run/react';

export function List() {
  const [searchParams] = useSearchParams();
  const view = searchParams.get('view') || 'list';

  return (
    <div>
      <Form>
        <button name="view" value="list">
          View as List
        </button>
        <button name="view" value="details">
          View with Details
        </button>
      </Form>
      {view === 'list' ? <ListView /> : <DetailView />}
    </div>
  );
}
```

### Persistent UI State

Consider a UI that toggles a sidebar's visibility. We have three ways to handle the state:

1. React state
2. Browser local storage
3. Cookies

In this discussion, we'll break down the trade-offs associated with each method.

#### React State

React state provides a simple solution for temporary state storage.

**Pros**:

- **Simple**: Easy to implement and understand.
- **Encapsulated**: State is scoped to the component.

**Cons**:

- **Transient**: Doesn't survive page refreshes, returning to the page later, or unmounting and remounting the component.

**Implementation**:

```tsx
function Sidebar({ children }) {
  const [isOpen, setIsOpen] = React.useState(false);
  return (
    <div>
      <button onClick={() => setIsOpen((open) => !open)}>{isOpen ? 'Close' : 'Open'}</button>
      <aside hidden={!isOpen}>{children}</aside>
    </div>
  );
}
```

#### Local Storage

To persist state beyond the component lifecycle, browser local storage is a step-up.

**Pros**:

- **Persistent**: Maintains state across page refreshes and component mounts/unmounts.
- **Encapsulated**: State is scoped to the component.

**Cons**:

- **Requires Synchronization**: React components must sync up with local storage to initialize and save the current state.
- **Server Rendering Limitation**: The [`window`][window_global] and [`localStorage`][local_storage_global] objects are not accessible during server-side rendering, so state must be initialized in the browser with an effect.
- **UI Flickering**: On initial page loads, the state in local storage may not match what was rendered by the server and the UI will flicker when JavaScript loads.

**Implementation**:

```tsx
function Sidebar({ children }) {
  const [isOpen, setIsOpen] = React.useState(false);

  // synchronize initially
  useLayoutEffect(() => {
    const isOpen = window.localStorage.getItem('sidebar');
    setIsOpen(isOpen);
  }, []);

  // synchronize on change
  useEffect(() => {
    window.localStorage.setItem('sidebar', isOpen);
  }, [isOpen]);

  return (
    <div>
      <button onClick={() => setIsOpen((open) => !open)}>{isOpen ? 'Close' : 'Open'}</button>
      <aside hidden={!isOpen}>{children}</aside>
    </div>
  );
}
```

In this approach, state must be initialized within an effect. This is crucial to avoid complications during server-side rendering. Directly initializing the React state from `localStorage` will cause errors since `window.localStorage` is unavailable during server rendering. Furthermore, even if it were accessible, it wouldn't mirror the user's browser local storage.

```tsx bad lines=[4]
function Sidebar() {
  const [isOpen, setIsOpen] = React.useState(
    // error: window is not defined
    window.localStorage.getItem('sidebar'),
  );

  // ...
}
```

By initializing the state within an effect, there's potential for a mismatch between the server-rendered state and the state stored in local storage. This discrepancy will lead to brief UI flickering shortly after the page renders and should be avoided.

#### Cookies

Cookies offer a comprehensive solution for this use case. However, this method introduces added preliminary setup before making the state accessible within the component.

**Pros**:

- **Server Rendering**: State is available on the server for rendering and even for server actions.
- **Single Source of Truth**: Eliminates state synchronization hassles.
- **Persistence**: Maintains state across page loads and component mounts/unmounts. State can even persist across devices if you switch to a database-backed session.
- **Progressive Enhancement**: Functions even before JavaScript loads.

**Cons**:

- **Boilerplate**: Requires more code because of the network.
- **Exposed**: The state is not encapsulated to a single component, other parts of the app must be aware of the cookie.

**Implementation**:

First we'll need to create a cookie object:

```tsx
import { createCookie } from '@remix-run/node';
export const prefs = createCookie('prefs');
```

Next we set up the server action and loader to read and write the cookie:

```tsx
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno

import { prefs } from './prefs-cookie';

// read the state from the cookie
export async function loader({ request }: LoaderFunctionArgs) {
  const cookieHeader = request.headers.get('Cookie');
  const cookie = (await prefs.parse(cookieHeader)) || {};
  return json({ sidebarIsOpen: cookie.sidebarIsOpen });
}

// write the state to the cookie
export async function action({ request }: ActionFunctionArgs) {
  const cookieHeader = request.headers.get('Cookie');
  const cookie = (await prefs.parse(cookieHeader)) || {};
  const formData = await request.formData();

  const isOpen = formData.get('sidebar') === 'open';
  cookie.sidebarIsOpen = isOpen;

  return json(isOpen, {
    headers: {
      'Set-Cookie': await prefs.serialize(cookie),
    },
  });
}
```

After the server code is set up, we can use the cookie state in our UI:

```tsx
function Sidebar({ children }) {
  const fetcher = useFetcher();
  let { sidebarIsOpen } = useLoaderData<typeof loader>();

  // use optimistic UI to immediately change the UI state
  if (fetcher.formData?.has('sidebar')) {
    sidebarIsOpen = fetcher.formData.get('sidebar') === 'open';
  }

  return (
    <div>
      <fetcher.Form method="post">
        <button name="sidebar" value={sidebarIsOpen ? 'closed' : 'open'}>
          {sidebarIsOpen ? 'Close' : 'Open'}
        </button>
      </fetcher.Form>
      <aside hidden={!sidebarIsOpen}>{children}</aside>
    </div>
  );
}
```

While this is certainly more code that touches more of the application to account for the network requests and responses, the UX is greatly improved. Additionally, state comes from a single source of truth without any state synchronization required.

In summary, each of the discussed methods offers a unique set of benefits and challenges:

- **React state**: Offers simple but transient state management.
- **Local Storage**: Provides persistence but with synchronization requirements and UI flickering.
- **Cookies**: Delivers robust, persistent state management at the cost of added boilerplate.

None of these are wrong, but if you want to persist the state across visits, cookies offer the best user experience.

### Form Validation and Action Data

Client-side validation can augment the user experience, but similar enhancements can be achieved by leaning more towards server-side processing and letting it handle the complexities.

The following example illustrates the inherent complexities of managing network state, coordinating state from the server, and implementing validation redundantly on both the client and server sides. It's just for illustration, so forgive any obvious bugs or problems you find.

```tsx bad lines=[2,14,30,41,66]
export function Signup() {
  // A multitude of React State declarations
  const [isSubmitting, setIsSubmitting] = React.useState(false);

  const [userName, setUserName] = React.useState('');
  const [userNameError, setUserNameError] = React.useState(null);

  const [password, setPassword] = React.useState(null);
  const [passwordError, setPasswordError] = React.useState('');

  // Replicating server-side logic in the client
  function validateForm() {
    setUserNameError(null);
    setPasswordError(null);
    const errors = validateSignupForm(userName, password);
    if (errors) {
      if (errors.userName) {
        setUserNameError(errors.userName);
      }
      if (errors.password) {
        setPasswordError(errors.password);
      }
    }
    return Boolean(errors);
  }

  // Manual network interaction handling
  async function handleSubmit() {
    if (validateForm()) {
      setSubmitting(true);
      const res = await postJSON('/api/signup', {
        userName,
        password,
      });
      const json = await res.json();
      setIsSubmitting(false);

      // Server state synchronization to the client
      if (json.errors) {
        if (json.errors.userName) {
          setUserNameError(json.errors.userName);
        }
        if (json.errors.password) {
          setPasswordError(json.errors.password);
        }
      }
    }
  }

  return (
    <form
      onSubmit={(event) => {
        event.preventDefault();
        handleSubmit();
      }}
    >
      <p>
        <input
          type="text"
          name="username"
          value={userName}
          onChange={() => {
            // Synchronizing form state for the fetch
            setUserName(event.target.value);
          }}
        />
        {userNameError ? <i>{userNameError}</i> : null}
      </p>

      <p>
        <input
          type="password"
          name="password"
          onChange={(event) => {
            // Synchronizing form state for the fetch
            setPassword(event.target.value);
          }}
        />
        {passwordError ? <i>{passwordError}</i> : null}
      </p>

      <button disabled={isSubmitting} type="submit">
        Sign Up
      </button>

      {isSubmitting ? <BusyIndicator /> : null}
    </form>
  );
}
```

The backend endpoint, `/api/signup`, also performs validation and sends error feedback. Note that some essential validation, like detecting duplicate usernames, can only be done server-side using information the client doesn't have access to.

```tsx bad
export async function signupHandler(request: Request) {
  const errors = await validateSignupRequest(request);
  if (errors) {
    return json({ ok: false, errors: errors });
  }
  await signupUser(request);
  return json({ ok: true, errors: null });
}
```

Now, let's contrast this with a Remix-based implementation. The action remains consistent, but the component is vastly simplified due to the direct utilization of server state via [`useActionData`][use_action_data], and leveraging the network state that Remix inherently manages.

```tsx filename=app/routes/signup.tsx good lines=[23-25]
import type { ActionFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useActionData, useNavigation } from '@remix-run/react';

export async function action({ request }: ActionFunctionArgs) {
  const errors = await validateSignupRequest(request);
  if (errors) {
    return json({ ok: false, errors: errors });
  }
  await signupUser(request);
  return json({ ok: true, errors: null });
}

export function Signup() {
  const navigation = useNavigation();
  const actionData = useActionData<typeof action>();

  const userNameError = actionData?.errors?.userName;
  const passwordError = actionData?.errors?.password;
  const isSubmitting = navigation.formAction === '/signup';

  return (
    <Form method="post">
      <p>
        <input type="text" name="username" />
        {userNameError ? <i>{userNameError}</i> : null}
      </p>

      <p>
        <input type="password" name="password" />
        {passwordError ? <i>{passwordError}</i> : null}
      </p>

      <button disabled={isSubmitting} type="submit">
        Sign Up
      </button>

      {isSubmitting ? <BusyIndicator /> : null}
    </Form>
  );
}
```

The extensive state management from our previous example is distilled into just three code lines. We eliminate the necessity for React state, change event listeners, submit handlers, and state management libraries for such network interactions.

Direct access to the server state is made possible through `useActionData`, and network state through `useNavigation` (or `useFetcher`).

As bonus party trick, the form is functional even before JavaScript loads. Instead of Remix managing the network operations, the default browser behaviors step in.

If you ever find yourself entangled in managing and synchronizing state for network operations, Remix likely offers a more elegant solution.

[fullstack_data_flow]: ./data-flow
[use_navigation]: ../hooks/use-navigation
[use_fetcher]: ../hooks/use-fetcher
[use_loader_data]: ../hooks/use-loader-data
[use_action_data]: ../hooks/use-action-data
[cache_control_header]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control
[pending_ui]: ./pending-ui
[window_global]: https://developer.mozilla.org/en-US/docs/Web/API/Window/window
[local_storage_global]: https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage

---

## File: ./discussion/testing.md

---

title: Testing
hidden: true

---

# Testing

---

## File: ./file-conventions/asset-imports.md

---

title: Asset Imports
toc: false

---

# Asset URL Imports

Any files inside the `app` folder can be imported into your modules. Remix will:

1. Copy the file to your browser build directory
2. Fingerprint the file for long-term caching
3. Return the public URL to your module to be used while rendering

It's most common for stylesheets, but can be used for any file type with [a defined loader][remix-loaders].

```tsx
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

import banner from './images/banner.jpg';
import styles from './styles/app.css';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: styles }];

export default function Page() {
  return (
    <div>
      <h1>Some Page</h1>
      <img src={banner} />
    </div>
  );
}
```

[remix-loaders]: https://github.com/remix-run/remix/blob/main/packages/remix-dev/compiler/utils/loaders.ts

---

## File: ./file-conventions/entry.client.md

---

title: entry.client
toc: false

---

# entry.client

By default, Remix will handle hydrating your app on the client for you. If you want to customize this behavior, you can run `npx remix reveal` to generate a `app/entry.client.tsx` (or `.jsx`) that will take precedence. This file is the entry point for the browser and is responsible for hydrating the markup generated by the server in your [server entry module][server_entry_module], however you can also initialize any other client-side code here.

Typically, this module uses `ReactDOM.hydrateRoot` to hydrate the markup that was already generated on the server in your [server entry module][server_entry_module].

Here's a basic example:

```tsx filename=app/entry.client.tsx
import { RemixBrowser } from '@remix-run/react';
import { startTransition, StrictMode } from 'react';
import { hydrateRoot } from 'react-dom/client';

startTransition(() => {
  hydrateRoot(
    document,
    <StrictMode>
      <RemixBrowser />
    </StrictMode>,
  );
});
```

This is the first piece of code that runs in the browser. You can initialize client side libraries, add client only providers, etc.

[server_entry_module]: ./entry.server

---

## File: ./file-conventions/entry.server.md

---

title: entry.server
toc: false

---

# entry.server

By default, Remix will handle generating the HTTP Response for you. If you want to customize this behavior, you can run `npx remix reveal` to generate an `app/entry.server.tsx` (or `.jsx`) that will take precedence. The `default` export of this module is a function that lets you create the response, including HTTP status, headers, and HTML, giving you full control over the way the markup is generated and sent to the client.

This module should render the markup for the current page using a `<RemixServer>` element with the `context` and `url` for the current request. This markup will (optionally) be re-hydrated once JavaScript loads in the browser using the [browser entry module][browser-entry-module].

## `handleDataRequest`

You can export an optional `handleDataRequest` function that will allow you to modify the response of a data request. These are the requests that do not render HTML, but rather return the loader and action data to the browser once client-side hydration has occurred.

```tsx
export function handleDataRequest(
  response: Response,
  { request, params, context }: LoaderFunctionArgs | ActionFunctionArgs,
) {
  response.headers.set('X-Custom-Header', 'value');
  return response;
}
```

## `handleError`

By default, Remix will log encountered server-side errors to the console. If you'd like more control over the logging, or would like to also report these errors to an external service, then you can export an optional `handleError` function which will give you control (and will disable the built-in error logging).

```tsx
export function handleError(
  error: unknown,
  { request, params, context }: LoaderFunctionArgs | ActionFunctionArgs,
) {
  if (!request.signal.aborted) {
    sendErrorToErrorReportingService(error);
    console.error(formatErrorForJsonLogging(error));
  }
}
```

_Note that you generally want to avoid logging when the request was aborted, since Remix's cancellation and race-condition handling can cause a lot of requests to be aborted._

### Streaming Rendering Errors

When you are streaming your HTML responses via [`renderToPipeableStream`][rendertopipeablestream] or [`renderToReadableStream`][rendertoreadablestream], your own `handleError` implementation will only handle errors encountered during the initial shell render. If you encounter a rendering error during subsequent streamed rendering you will need to handle these errors manually since the Remix server has already sent the Response by that point.

- For `renderToPipeableStream`, you can handle these errors in the `onError` callback function. You will need to toggle a boolean in `onShellReady` so you know if the error was a shell rendering error (and can be ignored) or an async rendering error (and must be handled).
  - For an example, please refer to the default [`entry.server.tsx`][node-streaming-entry-server] for Node.
- For `renderToReadableStream`, you can handle these errors in the `onError` callback function
  - For an example, please refer to the default [`entry.server.tsx`][cloudflare-streaming-entry-server] for Cloudflare

### Thrown Responses

Note that this does not handle thrown `Response` instances from your `loader`/`action` functions. The intention of this handler is to find bugs in your code which result in unexpected thrown errors. If you are detecting a scenario and throwing a 401/404/etc. `Response` in your `loader`/`action` then it's an expected flow that is handled by your code. If you also wish to log, or send those to an external service, that should be done at the time you throw the response.

[browser-entry-module]: ./entry.client
[rendertopipeablestream]: https://react.dev/reference/react-dom/server/renderToPipeableStream
[rendertoreadablestream]: https://react.dev/reference/react-dom/server/renderToReadableStream
[node-streaming-entry-server]: https://github.com/remix-run/remix/blob/main/packages/remix-dev/config/defaults/entry.server.node.tsx
[cloudflare-streaming-entry-server]: https://github.com/remix-run/remix/blob/main/packages/remix-dev/config/defaults/entry.server.cloudflare.tsx

---

## File: ./file-conventions/index.md

---

title: File Conventions
order: 3

---

---

## File: ./file-conventions/remix-config.md

---

title: remix.config.js
hidden: true

---

# remix.config.js

<docs-warning>`remix.config.js` is only relevant when using the [Classic Remix Compiler][classic-remix-compiler]. When using [Remix Vite][remix-vite], this file should not be present in your project. Instead, Remix configuration should be provided to the Remix plugin in your [Vite config][vite-config].</docs-warning>

This file has a few build and development configuration options, but does not actually run on your server.

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  appDirectory: 'app',
  assetsBuildDirectory: 'public/build',
  future: {
    /* any enabled future flags */
  },
  ignoredRouteFiles: ['**/*.css'],
  publicPath: '/build/',
  routes(defineRoutes) {
    return defineRoutes((route) => {
      route('/somewhere/cool/*', 'catchall.tsx');
    });
  },
  serverBuildPath: 'build/index.js',
};
```

## appDirectory

The path to the `app` directory, relative to remix.config.js. Defaults to
`"app"`.

```js filename=remix.config.js
// default
exports.appDirectory = './app';

// custom
exports.appDirectory = './elsewhere';
```

## assetsBuildDirectory

The path to the browser build, relative to remix.config.js. Defaults to
"public/build". Should be deployed to static hosting.

## browserNodeBuiltinsPolyfill

The Node.js polyfills to include in the browser build. Polyfills are provided by [JSPM][jspm] and configured via [esbuild-plugins-node-modules-polyfill].

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  browserNodeBuiltinsPolyfill: {
    modules: {
      buffer: true, // Provide a JSPM polyfill
      fs: 'empty', // Provide an empty polyfill
    },
    globals: {
      Buffer: true,
    },
  },
};
```

When using this option and targeting non-Node.js server platforms, you may also want to configure Node.js polyfills for the server via [`serverNodeBuiltinsPolyfill`][server-node-builtins-polyfill].

## cacheDirectory

The path to a directory Remix can use for caching things in development,
relative to `remix.config.js`. Defaults to `".cache"`.

## future

The `future` config lets you opt-into future breaking changes via [Future Flags][future-flags]. Please see the [Current Future Flags][current-future-flags] section for a list of all available Future Flags.

## ignoredRouteFiles

This is an array of globs (via [minimatch][minimatch]) that Remix will match to
files while reading your `app/routes` directory. If a file matches, it will be
ignored rather than treated like a route module. This is useful for ignoring
CSS/test files you wish to colocate.

## publicPath

The URL prefix of the browser build with a trailing slash. Defaults to
`"/build/"`. This is the path the browser will use to find assets.

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  publicPath: '/assets/',
};
```

If you wish to serve static assets from a separate domain you may also specify an absolute path:

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  publicPath: 'https://static.example.com/assets/',
};
```

## postcss

Whether to process CSS using [PostCSS][postcss] if a PostCSS config file is present. Defaults to `true`.

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  postcss: false,
};
```

## routes

A function for defining custom routes, in addition to those already defined
using the filesystem convention in `app/routes`. Both sets of routes will be merged.

```js filename=remix.config.js
exports.routes = async (defineRoutes) => {
  // If you need to do async work, do it before calling `defineRoutes`, we use
  // the call stack of `route` inside to set nesting.

  return defineRoutes((route) => {
    // A common use for this is catchall routes.
    // - The first argument is the React Router path to match against
    // - The second is the relative filename of the route handler
    route('/some/path/*', 'catchall.tsx');

    // if you want to nest routes, use the optional callback argument
    route('some/:path', 'some/route/file.js', () => {
      // - path is relative to parent path
      // - filenames are still relative to the app directory
      route('relative/path', 'some/other/file');
    });
  });
};
```

## server

A server entrypoint, relative to the root directory that becomes your server's
main module. If specified, Remix will compile this file along with your
application into a single file to be deployed to your server. This file can use
either a `.js` or `.ts` file extension.

## serverBuildPath

The path to the server build file, relative to `remix.config.js`. This file
should end in a `.js` extension and should be deployed to your server. Defaults
to `"build/index.js"`.

## serverConditions

The order of conditions to use when resolving server dependencies' `exports`
field in `package.json`.

## serverDependenciesToBundle

A list of regex patterns that determines if a module is transpiled and included
in the server bundle. This can be useful when consuming ESM only packages in a
CJS build, or when consuming packages with [CSS side effect
imports][css_side_effect_imports].

For example, the `unified` ecosystem is all ESM-only. Let's also say we're using
a `@sindresorhus/slugify` which is ESM-only as well. Here's how you would be
able to consume those packages in a CJS app without having to use dynamic
imports:

```js filename=remix.config.js lines=[8-13]
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  appDirectory: 'app',
  assetsBuildDirectory: 'public/build',
  publicPath: '/build/',
  serverBuildPath: 'build/index.js',
  ignoredRouteFiles: ['**/*.css'],
  serverDependenciesToBundle: [/^rehype.*/, /^remark.*/, /^unified.*/, '@sindresorhus/slugify'],
};
```

If you want to bundle all server dependencies, you can set
`serverDependenciesToBundle` to `"all"`.

## serverMainFields

The order of main fields to use when resolving server dependencies. Defaults to
`["main", "module"]` when `serverModuleFormat` is set to `"cjs"`. Defaults to
`["module", "main"]` when `serverModuleFormat` is set to `"esm"`.

## serverMinify

Whether to minify the server build in production or not. Defaults to `false`.

## serverModuleFormat

The output format of the server build, which can either be `"cjs"` or `"esm"`.
Defaults to `"esm"`.

## serverNodeBuiltinsPolyfill

The Node.js polyfills to include in the server build when targeting non-Node.js server platforms. Polyfills are provided by [JSPM][jspm] and configured via [esbuild-plugins-node-modules-polyfill].

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  serverNodeBuiltinsPolyfill: {
    modules: {
      buffer: true, // Provide a JSPM polyfill
      fs: 'empty', // Provide an empty polyfill
    },
    globals: {
      Buffer: true,
    },
  },
};
```

When using this option, you may also want to configure Node.js polyfills for the browser via [`browserNodeBuiltinsPolyfill`][browser-node-builtins-polyfill].

## serverPlatform

The platform the server build is targeting, which can either be `"neutral"` or
`"node"`. Defaults to `"node"`.

## tailwind

Whether to support [Tailwind functions and directives][tailwind_functions_and_directives] in CSS files if `tailwindcss` is installed. Defaults to `true`.

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  tailwind: false,
};
```

## watchPaths

An array, string, or async function that defines custom directories, relative to the project root, to watch while running [remix dev][remix_dev]. These directories are in addition to [`appDirectory`][app_directory].

```js filename=remix.config.js
exports.watchPaths = async () => {
  return ['./some/path/*'];
};

// also valid
exports.watchPaths = ['./some/path/*'];
```

## File Name Conventions

There are a few conventions that Remix uses you should be aware of.

<docs-info>[Dilum Sanjaya][dilum_sanjaya] made [an awesome visualization][an_awesome_visualization] of how routes in the file system map to the URL in your app that might help you understand these conventions.</docs-info>

[minimatch]: https://npm.im/minimatch
[dilum_sanjaya]: https://twitter.com/DilumSanjaya
[an_awesome_visualization]: https://interactive-remix-routing-v2.netlify.app
[remix_dev]: ../other-api/dev#remix-dev
[app_directory]: #appdirectory
[css_side_effect_imports]: ../styling/css-imports
[postcss]: https://postcss.org
[tailwind_functions_and_directives]: https://tailwindcss.com/docs/functions-and-directives
[jspm]: https://github.com/jspm/jspm-core
[esbuild-plugins-node-modules-polyfill]: https://npm.im/esbuild-plugins-node-modules-polyfill
[browser-node-builtins-polyfill]: #browsernodebuiltinspolyfill
[server-node-builtins-polyfill]: #servernodebuiltinspolyfill
[future-flags]: ../start/future-flags
[current-future-flags]: ../start/future-flags#current-future-flags
[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ../guides/vite
[vite-config]: ./vite-config

---

## File: ./file-conventions/root.md

---

title: root
toc: false

---

# Root Route

The "root" route (`app/root.tsx`) is the only _required_ route in your Remix application because it is the parent to all routes in your `routes/` directory and is in charge of rendering the root `<html>` document.

Beyond that, it's mostly just like any other route and supports all of the standard route exports:

- [`headers`][headers]
- [`meta`][meta]
- [`links`][links]
- [`loader`][loader]
- [`clientLoader`][clientloader]
- [`action`][action]
- [`clientAction`][clientaction]
- [`default`][component]
- [`ErrorBoundary`][errorboundary]
- [`HydrateFallback`][hydratefallback]
- [`handle`][handle]
- [`shouldRevalidate`][shouldrevalidate]

Because the root route manages your document, it is the proper place to render a handful of "document-level" components Remix provides. These components are to be used once inside your root route and they include everything Remix figured out or built in order for your page to render properly.

```tsx filename=app/root.tsx
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno
import { Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react';

import globalStylesheetUrl from './global-styles.css';

export const links: LinksFunction = () => {
  return [{ rel: 'stylesheet', href: globalStylesheetUrl }];
};

export default function App() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        {/* All `meta` exports on all routes will render here */}
        <Meta />

        {/* All `link` exports on all routes will render here */}
        <Links />
      </head>
      <body>
        {/* Child routes render here */}
        <Outlet />

        {/* Manages scroll position for client-side transitions */}
        {/* If you use a nonce-based content security policy for scripts, you must provide the `nonce` prop. Otherwise, omit the nonce prop as shown here. */}
        <ScrollRestoration />

        {/* Script tags go here */}
        {/* If you use a nonce-based content security policy for scripts, you must provide the `nonce` prop. Otherwise, omit the nonce prop as shown here. */}
        <Scripts />

        {/* Sets up automatic reload when you change code */}
        {/* and only does anything during development */}
        {/* If you use a nonce-based content security policy for scripts, you must provide the `nonce` prop. Otherwise, omit the nonce prop as shown here. */}
        <LiveReload />
      </body>
    </html>
  );
}
```

## Layout Export

Because the root route manages the document for all routes, it also supports an additional optional `Layout` export. You can read the details in this [RFC][layout-rfc] but the layout route serves 2 purposes:

- Avoid duplicating your document/"app shell" across your root component, `HydrateFallback`, and `ErrorBoundary`
- Avoids React from re-mounting your app shell elements when switching between the root component/`HydrateFallback`/`ErrorBoundary` which can cause a FOUC if React removes and re-adds `<link rel="stylesheet">` tags from your `<Links>` component.

```tsx filename=app/root.tsx lines=[10-31]
import { Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react';

export function Layout({ children }) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
      </head>
      <body>
        {/* children will be the root Component, ErrorBoundary, or HydrateFallback */}
        {children}
        <Scripts />
        <ScrollRestoration />
        <LiveReload />
      </body>
    </html>
  );
}

export default function App() {
  return <Outlet />;
}

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    return (
      <>
        <h1>
          {error.status} {error.statusText}
        </h1>
        <p>{error.data}</p>
      </>
    );
  }

  return (
    <>
      <h1>Error!</h1>
      <p>{error?.message ?? 'Unknown error'}</p>
    </>
  );
}
```

**A note on `useLoaderData`in the `Layout` Component**

`useLoaderData` is not permitted to be used in `ErrorBoundary` components because it is intended for the happy-path route rendering, and its typings have a built-in assumption that the `loader` ran successfully and returned something. That assumption doesn't hold in an `ErrorBoundary` because it could have been the `loader` that threw and triggered the boundary! In order to access loader data in `ErrorBoundary`'s, you can use `useRouteLoaderData` which accounts for the loader data potentially being `undefined`.

Because your `Layout` component is used in both success and error flows, this same restriction holds. If you need to fork logic in your `Layout` depending on if it was a successful request or not, you can use `useRouteLoaderData("root")` and `useRouteError()`.

<docs-warn>Because your `<Layout>` component is used for rendering the `ErrorBoundary`, you should be _very defensive_ to ensure that you can render your `ErrorBoundary` without encountering any render errors. If your `Layout` throws another error trying to render the boundary, then it can't be used and your UI will fall back to the very minimal built-in default `ErrorBoundary`.</docs-warn>

```tsx filename="app/root.tsx" lines=[6-7,19-29,32-34]
export function Layout({ children }: { children: React.ReactNode }) {
  const data = useRouteLoaderData('root');
  const error = useRouteError();

  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
        <style
          dangerouslySetInnerHTML={{
            __html: `
              :root {
                --themeVar: ${data?.themeVar || defaultThemeVar}
              }
            `,
          }}
        />
      </head>
      <body>
        {data ? <Analytics token={data.analyticsToken} /> : null}
        {children}
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}
```

See also:

- [`<Meta>`][meta-component]
- [`<Links>`][links-component]
- [`<Outlet>`][outlet-component]
- [`<ScrollRestoration>`][scrollrestoration-component]
- [`<Scripts>`][scripts-component]
- [`<LiveReload>`][livereload-component]

[headers]: ../route/headers
[meta]: ../route/meta
[links]: ../route/links
[loader]: ../route/loader
[clientloader]: ../route/client-loader
[action]: ../route/action
[clientaction]: ../route/client-action
[component]: ../route/component
[errorboundary]: ../route/error-boundary
[hydratefallback]: ../route/hydrate-fallback
[handle]: ../route/handle
[shouldrevalidate]: ../route/should-revalidate
[layout-rfc]: https://github.com/remix-run/remix/discussions/8702
[scripts-component]: ../components/scripts
[links-component]: ../components/links
[meta-component]: ../components/meta
[livereload-component]: ../components/live-reload
[scrollrestoration-component]: ../components/scroll-restoration
[outlet-component]: ../components/outlet

---

## File: ./file-conventions/routes.md

---

## title: Route File Naming

# Route File Naming

While you can configure routes via [the "routes" plugin option][routes_config], most routes are created with this file system convention. Add a file, get a route.

Please note that you can use either `.js`, `.jsx`, `.ts` or `.tsx` file extensions. We'll stick with `.tsx` in the examples to avoid duplication.

<docs-info>Dilum Sanjaya made [an awesome visualization][an_awesome_visualization] of how routes in the file system map to the URL in your app that might help you understand these conventions.</docs-info>

## Disclaimer

Before we go too far into the Remix convention though, we'd like to point out that file-based routing is an **incredibly** subjective idea. Some folks love the "flat" routes idea, some folks hate it and would prefer nesting routes in folders. Some folks simply hate file-based routing and would prefer to configure routes via JSON. Some folks would prefer to configure routes via JSX like they did in their React Router SPA's.

The point is, we are well aware of this and from the get-go, Remix has always given you a first-class way to opt-out via the [`routes`][routes_config]/[`ignoredRouteFiles`][ignoredroutefiles_config] and [configure your routes manually][manual-route-configuration]. But, there has to be _some_ default so that folks can get up and running quickly and easily - and we think that the flat routes convention document below is a pretty good default that scales well for small-to-medium sized apps.

Large applications with hundreds or thousands of routes will _always_ be a bit chaotic no matter what convention you use - and the idea is that via the `routes` config, you get to build _exactly_ the convention that works best for your application/team. It would be quite literally impossible for Remix to have a default convention that made everyone happy. We'd much rather give you a fairly straightforward default, and then let the community build any number of conventions you can pick and choose from.

So, before we dive into the details of the Remix default convention, here's some community alternatives you can check out if you decide that our default is not your cup of tea.

- [`remix-flat-routes`][flat_routes] - The Remix default is basically a simplified version of this package. The author has continued to iterate on and evolve this package so if you generally like the "flat routes" idea but want a bit more power (including a hybrid approach of files and folders), definitely check this one out.
- [`remix-custom-routes`][custom_routes] - If you want even more customization, this package lets you define that types of files should be treated as routes. This lets you go beyond the simple flat/nested concept and do something such as _"any file with an extension of `.route.tsx` is a route"_.
- [`remix-json-routes`][json_routes] - If you just want to specify your routes via a config file, this is your jam - just provide Remix a JSON object with your routes and skip the flat/nested concept entirely. There's even a JSX option in there too.

## Root Route

```text lines=[3]
app/
‚îú‚îÄ‚îÄ routes/
‚îî‚îÄ‚îÄ root.tsx
```

The file in `app/root.tsx` is your root layout, or "root route" (very sorry for those of you who pronounce those words the same way!). It works just like all other routes, so you can export a [`loader`][loader], [`action`][action], etc.

The root route typically looks something like this. It serves as the root layout of the entire app, all other routes will render inside the [`<Outlet />`][outlet_component].

```tsx
import { Links, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react';

export default function Root() {
  return (
    <html lang="en">
      <head>
        <Links />
        <Meta />
      </head>
      <body>
        <Outlet />
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}
```

## Basic Routes

Any JavaScript or TypeScript files in the `app/routes` directory will become routes in your application. The filename maps to the route's URL pathname, except for `_index.tsx` which is the [index route][index_route] for the [root route][root_route].

```text lines=[3-4]
app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ _index.tsx
‚îÇ   ‚îî‚îÄ‚îÄ about.tsx
‚îî‚îÄ‚îÄ root.tsx
```

| URL      | Matched Routes          |
| -------- | ----------------------- |
| `/`      | `app/routes/_index.tsx` |
| `/about` | `app/routes/about.tsx`  |

Note that these routes will be rendered in the outlet of `app/root.tsx` because of [nested routing][nested_routing].

## Dot Delimiters

Adding a `.` to a route filename will create a `/` in the URL.

```text lines=[5-7]
 app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ _index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ about.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts.trending.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts.salt-lake-city.tsx
‚îÇ   ‚îî‚îÄ‚îÄ concerts.san-diego.tsx
‚îî‚îÄ‚îÄ root.tsx
```

| URL                        | Matched Route                            |
| -------------------------- | ---------------------------------------- |
| `/`                        | `app/routes/_index.tsx`                  |
| `/about`                   | `app/routes/about.tsx`                   |
| `/concerts/trending`       | `app/routes/concerts.trending.tsx`       |
| `/concerts/salt-lake-city` | `app/routes/concerts.salt-lake-city.tsx` |
| `/concerts/san-diego`      | `app/routes/concerts.san-diego.tsx`      |

The dot delimiter also creates nesting, see the [nesting section][nested_routes] for more information.

## Dynamic Segments

Usually your URLs aren't static but data-driven. Dynamic segments allow you to match segments of the URL and use that value in your code. You create them with the `$` prefix.

```text lines=[5]
 app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ _index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ about.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts.$city.tsx
‚îÇ   ‚îî‚îÄ‚îÄ concerts.trending.tsx
‚îî‚îÄ‚îÄ root.tsx
```

| URL                        | Matched Route                      |
| -------------------------- | ---------------------------------- |
| `/`                        | `app/routes/_index.tsx`            |
| `/about`                   | `app/routes/about.tsx`             |
| `/concerts/trending`       | `app/routes/concerts.trending.tsx` |
| `/concerts/salt-lake-city` | `app/routes/concerts.$city.tsx`    |
| `/concerts/san-diego`      | `app/routes/concerts.$city.tsx`    |

Remix will parse the value from the URL and pass it to various APIs. We call these values "URL Parameters". The most useful places to access the URL params are in [loaders][loader] and [actions][action].

```tsx
export async function loader({ params }: LoaderFunctionArgs) {
  return fakeDb.getAllConcertsForCity(params.city);
}
```

You'll note the property name on the `params` object maps directly to the name of your file: `$city.tsx` becomes `params.city`.

Routes can have multiple dynamic segments, like `concerts.$city.$date`, both are accessed on the params object by name:

```tsx
export async function loader({ params }: LoaderFunctionArgs) {
  return fake.db.getConcerts({
    date: params.date,
    city: params.city,
  });
}
```

See the [routing guide][routing_guide] for more information.

## Nested Routes

Nested Routing is the general idea of coupling segments of the URL to component hierarchy and data. You can read more about it in the [Routing Guide][nested_routing].

You create nested routes with [dot delimiters][dot_delimiters]. If the filename before the `.` matches another route filename, it automatically becomes a child route to the matching parent. Consider these routes:

```text lines=[5-8]
 app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ _index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ about.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts._index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts.$city.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts.trending.tsx
‚îÇ   ‚îî‚îÄ‚îÄ concerts.tsx
‚îî‚îÄ‚îÄ root.tsx
```

All the routes that start with `app/routes/concerts.` will be child routes of `app/routes/concerts.tsx` and render inside the parent route's [outlet_component][outlet_component].

| URL                        | Matched Route                      | Layout                    |
| -------------------------- | ---------------------------------- | ------------------------- |
| `/`                        | `app/routes/_index.tsx`            | `app/root.tsx`            |
| `/about`                   | `app/routes/about.tsx`             | `app/root.tsx`            |
| `/concerts`                | `app/routes/concerts._index.tsx`   | `app/routes/concerts.tsx` |
| `/concerts/trending`       | `app/routes/concerts.trending.tsx` | `app/routes/concerts.tsx` |
| `/concerts/salt-lake-city` | `app/routes/concerts.$city.tsx`    | `app/routes/concerts.tsx` |

Note you typically want to add an index route when you add nested routes so that something renders inside the parent's outlet when users visit the parent URL directly.

For example, if the URL is `/concerts/salt-lake-city` then the UI hierarchy will look like this:

```tsx
<Root>
  <Concerts>
    <City />
  </Concerts>
</Root>
```

## Nested URLs without Layout Nesting

Sometimes you want the URL to be nested, but you don't want the automatic layout nesting. You can opt out of nesting with a trailing underscore on the parent segment:

```text lines=[8]
 app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ _index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ about.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts.$city.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts.trending.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts.tsx
‚îÇ   ‚îî‚îÄ‚îÄ concerts_.mine.tsx
‚îî‚îÄ‚îÄ root.tsx
```

| URL                        | Matched Route                      | Layout                    |
| -------------------------- | ---------------------------------- | ------------------------- |
| `/`                        | `app/routes/_index.tsx`            | `app/root.tsx`            |
| `/about`                   | `app/routes/about.tsx`             | `app/root.tsx`            |
| `/concerts/mine`           | `app/routes/concerts_.mine.tsx`    | `app/root.tsx`            |
| `/concerts/trending`       | `app/routes/concerts.trending.tsx` | `app/routes/concerts.tsx` |
| `/concerts/salt-lake-city` | `app/routes/concerts.$city.tsx`    | `app/routes/concerts.tsx` |

Note that `/concerts/mine` does not nest with `app/routes/concerts.tsx` anymore, but `app/root.tsx`. The `trailing_` underscore creates a path segment, but it does not create layout nesting.

Think of the `trailing_` underscore as the long bit at the end of your parent's signature, writing you out of the will, removing the segment that follows from the layout nesting.

## Nested Layouts without Nested URLs

We call these <a name="pathless-routes"><b>Pathless Routes</b></a>

Sometimes you want to share a layout with a group of routes without adding any path segments to the URL. A common example is a set of authentication routes that have a different header/footer than the public pages or the logged in app experience. You can do this with a `_leading` underscore.

```text lines=[3-5]
 app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ _auth.login.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _auth.register.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _auth.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ concerts.$city.tsx
‚îÇ   ‚îî‚îÄ‚îÄ concerts.tsx
‚îî‚îÄ‚îÄ root.tsx
```

| URL                        | Matched Route                   | Layout                    |
| -------------------------- | ------------------------------- | ------------------------- |
| `/`                        | `app/routes/_index.tsx`         | `app/root.tsx`            |
| `/login`                   | `app/routes/_auth.login.tsx`    | `app/routes/_auth.tsx`    |
| `/register`                | `app/routes/_auth.register.tsx` | `app/routes/_auth.tsx`    |
| `/concerts`                | `app/routes/concerts.tsx`       | `app/root.tsx`            |
| `/concerts/salt-lake-city` | `app/routes/concerts.$city.tsx` | `app/routes/concerts.tsx` |

Think of the `_leading` underscore as a blanket you're pulling over the filename, hiding the filename from the URL.

## Optional Segments

Wrapping a route segment in parentheses will make the segment optional.

```text lines=[3-5]
 app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ ($lang)._index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ ($lang).$productId.tsx
‚îÇ   ‚îî‚îÄ‚îÄ ($lang).categories.tsx
‚îî‚îÄ‚îÄ root.tsx
```

| URL                        | Matched Route                       |
| -------------------------- | ----------------------------------- |
| `/`                        | `app/routes/($lang)._index.tsx`     |
| `/categories`              | `app/routes/($lang).categories.tsx` |
| `/en/categories`           | `app/routes/($lang).categories.tsx` |
| `/fr/categories`           | `app/routes/($lang).categories.tsx` |
| `/american-flag-speedo`    | `app/routes/($lang)._index.tsx`     |
| `/en/american-flag-speedo` | `app/routes/($lang).$productId.tsx` |
| `/fr/american-flag-speedo` | `app/routes/($lang).$productId.tsx` |

You may wonder why `/american-flag-speedo` is matching the `($lang)._index.tsx` route instead of `($lang).$productId.tsx`. This is because when you have an optional dynamic param segment followed by another dynamic param, Remix cannot reliably determine if a single-segment URL such as `/american-flag-speedo` should match `/:lang` `/:productId`. Optional segments match eagerly and thus it will match `/:lang`. If you have this type of setup it's recommended to look at `params.lang` in the `($lang)._index.tsx` loader and redirect to `/:lang/american-flag-speedo` for the current/default language if `params.lang` is not a valid language code.

## Splat Routes

While [dynamic segments][dynamic_segments] match a single path segment (the stuff between two `/` in a URL), a splat route will match the rest of a URL, including the slashes.

```text lines=[4,6]
 app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ _index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ $.tsx
‚îÇ   ‚îú‚îÄ‚îÄ about.tsx
‚îÇ   ‚îî‚îÄ‚îÄ files.$.tsx
‚îî‚îÄ‚îÄ root.tsx
```

| URL                                          | Matched Route            |
| -------------------------------------------- | ------------------------ |
| `/`                                          | `app/routes/_index.tsx`  |
| `/about`                                     | `app/routes/about.tsx`   |
| `/beef/and/cheese`                           | `app/routes/$.tsx`       |
| `/files`                                     | `app/routes/files.$.tsx` |
| `/files/talks/remix-conf_old.pdf`            | `app/routes/files.$.tsx` |
| `/files/talks/remix-conf_final.pdf`          | `app/routes/files.$.tsx` |
| `/files/talks/remix-conf-FINAL-MAY_2022.pdf` | `app/routes/files.$.tsx` |

Similar to dynamic route parameters, you can access the value of the matched path on the splat route's `params` with the `"*"` key.

```tsx filename=app/routes/files.$.tsx
export async function loader({ params }: LoaderFunctionArgs) {
  const filePath = params['*'];
  return fake.getFileInfo(filePath);
}
```

## Escaping Special Characters

If you want one of the special characters Remix uses for these route conventions to actually be a part of the URL, you can escape the conventions with `[]` characters.

| Filename                            | URL                 |
| ----------------------------------- | ------------------- |
| `app/routes/sitemap[.]xml.tsx`      | `/sitemap.xml`      |
| `app/routes/[sitemap.xml].tsx`      | `/sitemap.xml`      |
| `app/routes/weird-url.[_index].tsx` | `/weird-url/_index` |
| `app/routes/dolla-bills-[$].tsx`    | `/dolla-bills-$`    |
| `app/routes/[[so-weird]].tsx`       | `/[so-weird]`       |

## Folders for Organization

Routes can also be folders with a `route.tsx` file inside defining the route module. The rest of the files in the folder will not become routes. This allows you to organize your code closer to the routes that use them instead of repeating the feature names across other folders.

<docs-info>The files inside a folder have no meaning for the route paths, the route path is completely defined by the folder name</docs-info>

Consider these routes:

```text
 app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ _landing._index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _landing.about.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _landing.tsx
‚îÇ   ‚îú‚îÄ‚îÄ app._index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ app.projects.tsx
‚îÇ   ‚îú‚îÄ‚îÄ app.tsx
‚îÇ   ‚îî‚îÄ‚îÄ app_.projects.$id.roadmap.tsx
‚îî‚îÄ‚îÄ root.tsx
```

Some, or all of them can be folders holding their own `route` module inside.

```text
app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ _landing._index/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ route.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scroll-experience.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _landing.about/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ employee-profile-card.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ get-employee-data.server.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ route.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ team-photo.jpg
‚îÇ   ‚îú‚îÄ‚îÄ _landing/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ footer.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ header.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.tsx
‚îÇ   ‚îú‚îÄ‚îÄ app._index/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ route.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats.tsx
‚îÇ   ‚îú‚îÄ‚îÄ app.projects/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ get-projects.server.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ project-buttons.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ project-card.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.tsx
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ footer.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ primary-nav.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.tsx
‚îÇ   ‚îú‚îÄ‚îÄ app_.projects.$id.roadmap/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chart.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ route.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ update-timeline.server.ts
‚îÇ   ‚îî‚îÄ‚îÄ contact-us.tsx
‚îî‚îÄ‚îÄ root.tsx
```

Note that when you turn a route module into a folder, the route module becomes `folder/route.tsx`, all other modules in the folder will not become routes. For example:

```
# these are the same route:
app/routes/app.tsx
app/routes/app/route.tsx

# as are these
app/routes/app._index.tsx
app/routes/app._index/route.tsx
```

## Scaling

Our general recommendation for scale is to make every route a folder and put the modules used exclusively by that route in the folder, then put the shared modules outside of routes folder elsewhere. This has a couple benefits:

- Easy to identify shared modules, so tread lightly when changing them
- Easy to organize and refactor the modules for a specific route without creating "file organization fatigue" and cluttering up other parts of the app

[loader]: ../route/loader
[action]: ../route/action
[outlet_component]: ../components/outlet
[routing_guide]: ../discussion/routes
[root_route]: #root-route
[index_route]: ../discussion/routes#index-routes
[nested_routing]: ../discussion/routes#what-is-nested-routing
[nested_routes]: #nested-routes
[routes_config]: ./vite-config#routes
[ignoredroutefiles_config]: ./vite-config#ignoredroutefiles
[dot_delimiters]: #dot-delimiters
[dynamic_segments]: #dynamic-segments
[an_awesome_visualization]: https://interactive-remix-routing-v2.netlify.app/
[flat_routes]: https://github.com/kiliman/remix-flat-routes
[custom_routes]: https://github.com/jacobparis-insiders/remix-custom-routes
[json_routes]: https://github.com/brophdawg11/remix-json-routes
[manual-route-configuration]: ../discussion/routes#manual-route-configuration

---

## File: ./file-conventions/vite-config.md

---

## title: vite.config.ts

# vite.config.ts

<docs-warning>If your project is still using the [Classic Remix Compiler][classic-remix-compiler], you should refer to the [remix.config.js documentation][remix-config] instead.</docs-warning>

Remix uses [Vite] to compile your application. You'll need to provide a Vite config file with the Remix Vite plugin. Here's the minimum configuration you'll need:

```ts filename=vite.config.ts
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [remix()],
});
```

<docs-info>Vite supports using a `.js` file for your config, but we recommend using TypeScript to help ensure your configuration is valid.</docs-info>

## Remix Vite Plugin Config

```js filename=vite.config.ts
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [
    remix({
      basename: '/',
      buildDirectory: 'build',
      future: {
        /* any enabled future flags */
      },
      ignoredRouteFiles: ['**/*.css'],
      routes(defineRoutes) {
        return defineRoutes((route) => {
          route('/somewhere/cool/*', 'catchall.tsx');
        });
      },
      serverBuildFile: 'index.js',
    }),
  ],
});
```

#### appDirectory

The path to the `app` directory, relative to the project root. Defaults to
`"app"`.

#### future

The `future` config lets you opt-into future breaking changes via [Future Flags][future-flags].

#### ignoredRouteFiles

This is an array of globs (via [minimatch][minimatch]) that Remix will match to
files while reading your `app/routes` directory. If a file matches, it will be
ignored rather than treated like a route module. This is useful for ignoring
CSS/test files you wish to colocate.

#### routes

A function for defining custom routes, in addition to those already defined
using the filesystem convention in `app/routes`. Both sets of routes will be merged.

```ts filename=vite.config.ts
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [
    remix({
      routes: async (defineRoutes) => {
        // If you need to do async work, do it before calling `defineRoutes`, we use
        // the call stack of `route` inside to set nesting.

        return defineRoutes((route) => {
          // A common use for this is catchall routes.
          // - The first argument is the React Router path to match against
          // - The second is the relative filename of the route handler
          route('/some/path/*', 'catchall.tsx');

          // if you want to nest routes, use the optional callback argument
          route('some/:path', 'some/route/file.js', () => {
            // - path is relative to parent path
            // - filenames are still relative to the app directory
            route('relative/path', 'some/other/file');
          });
        });
      },
    }),
  ],
});
```

#### serverModuleFormat

The output format of the server build, which can either be `"cjs"` or `"esm"`.
Defaults to `"esm"`.

#### buildDirectory

The path to the build directory, relative to the project root. Defaults to
`"build"`.

#### basename

An optional basename for your route paths, passed through to the [React Router "basename" option][rr-basename]. Please note that this is different from your _asset_ paths. You can can configure the [base public path][vite-public-base-path] for your assets via the [Vite "base" option][vite-base].

#### buildEnd

A function that is called after the full Remix build is complete.

#### manifest

Whether to write a `.remix/manifest.json` file to the build directory. Defaults
to `false`.

#### presets

An array of [presets] to ease integration with other tools and hosting providers.

#### serverBuildFile

The name of the server file generated in the server build directory. Defaults to `"index.js"`.

#### serverBundles

A function for assigning addressable routes to [server bundles][server-bundles].

You may also want to enable the `manifest` option since, when server bundles are enabled, it contains mappings between routes and server bundles.

[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-config]: ./remix-config
[vite]: https://vitejs.dev
[future-flags]: ../start/future-flags
[minimatch]: https://npm.im/minimatch
[presets]: ../guides/presets
[server-bundles]: ../guides/server-bundles
[rr-basename]: https://reactrouter.com/v6/routers/create-browser-router#basename
[vite-public-base-path]: https://vitejs.dev/config/shared-options.html#base
[vite-base]: https://vitejs.dev/config/shared-options.html#base

---

## File: ./file-conventions/-client.md

---

title: ".client modules"
toc: false

---

# `.client` modules

While uncommon, you may have a file or dependency that uses module side effects in the browser. You can use `*.client.ts` on file names or nest files within `.client` directories to force them out of server bundles.

```ts filename=feature-check.client.ts
// this would break the server
export const supportsVibrationAPI = 'vibrate' in window.navigator;
```

Note that values exported from this module will all be `undefined` on the server, so the only places to use them are in [`useEffect`][use_effect] and user events like click handlers.

```ts
import { supportsVibrationAPI } from './feature-check.client.ts';

console.log(supportsVibrationAPI);
// server: undefined
// client: true | false
```

<docs-warning>`.client` directories are only supported when using [Remix Vite][remix-vite]. The [Classic Remix Compiler][classic-remix-compiler] only supports `.client` files.</docs-warning>

Refer to the Route Module section in the sidebar for more information.

[use_effect]: https://react.dev/reference/react/useEffect
[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ../guides/vite

---

## File: ./file-conventions/-server.md

---

title: ".server modules"
toc: false

---

# `.server` modules

While not strictly necessary, `.server` modules are a good way to explicitly mark entire modules as server-only.
The build will fail if any code in a `.server` file or `.server` directory accidentally ends up in the client module graph.

```txt
app
‚îú‚îÄ‚îÄ .server üëà marks all files in this directory as server-only
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts
‚îÇ   ‚îî‚îÄ‚îÄ db.ts
‚îú‚îÄ‚îÄ cms.server.ts üëà marks this file as server-only
‚îú‚îÄ‚îÄ root.tsx
‚îî‚îÄ‚îÄ routes
    ‚îî‚îÄ‚îÄ _index.tsx
```

`.server` modules must be within your Remix app directory.

Refer to the Route Module section in the sidebar for more information.

<docs-warning>`.server` directories are only supported when using [Remix Vite][remix-vite]. The [Classic Remix Compiler][classic-remix-compiler] only supports `.server` files.</docs-warning>

<docs-warning>When using the [Classic Remix Compiler][classic-remix-compiler], `.server` modules are replaced with empty modules and will not result in a compilation error. Note that this can result in runtime errors.</docs-warning>

[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ../guides/vite

---

## File: ./guides/accessibility.md

---

## title: Accessibility

# Accessibility

Accessibility in a Remix app looks a lot like accessibility on the web in general. Using proper semantic markup and following the [Web Content Accessibility Guidelines (WCAG)][wcag] will get you most of the way there.

Remix makes certain accessibility practices the default where possible and provides APIs to help where it's not. We are actively exploring and developing new APIs to make this even easier in the future.

## Links

The [`<Link>` component][link] renders a standard anchor tag, meaning that you get its accessibility behaviors from the browser for free!

Remix also provides the [`<NavLink/>`][navlink] which behaves the same as `<Link>`, but it also provides context for assistive technology when the link points to the current page. This is useful for building navigation menus or breadcrumbs.

## Routing

If you are rendering [`<Scripts>`][scripts] in your app, there are some important things to consider to make client-side routing more accessible for your users.

With a traditional multi-page website we don't have to think about route changes too much. Your app renders an anchor tag, and the browser handles the rest. If your users disable JavaScript, your Remix app should already work this way by default!

When the client scripts in Remix are loaded, React Router takes control of routing and prevents the browser's default behavior. Remix doesn't make any assumptions about your UI as the route changes. There are some important features you'll want to consider as a result, including:

- **Focus management:** What element receives focus when the route changes? This is important for keyboard users and can be helpful for screen-reader users.
- **Live-region announcements:** Screen-reader users also benefit from announcements when a route has changed. You may want to also notify them during certain transition states depending on the nature of the change and how long loading is expected to take.

In 2019, [Marcy Sutton led and published findings from user research][marcy-sutton-led-and-published-findings-from-user-research] to help developers build accessible client-side routing experiences. We encourage you to read the article in detail. We are actively investigating and testing internal solutions as well as new APIs to simplify this process.

[link]: ../components/link
[navlink]: ../components/nav-link
[scripts]: ../components/scripts
[wcag]: https://www.w3.org/WAI/standards-guidelines/wcag/
[marcy-sutton-led-and-published-findings-from-user-research]: https://www.gatsbyjs.com/blog/2019-07-11-user-testing-accessible-client-routing

---

## File: ./guides/api-development-strategy.md

---

## title: Development Strategy

# Gradual Feature Adoption with Future Flags

In our approach to software development, we aim to achieve the following goals for major releases:

1. **Incremental Feature Adoption:** Developers have the flexibility to choose and integrate new features and changes one by one, as they become available in the current major version. This is a departure from the traditional method of bundling all changes into a single new major release.
2. **Seamless Version Upgrades:** By selectively incorporating new features ahead of time, developers can smoothly transition to new major versions without the need to modify their existing application code.

## Unstable APIs and Future Flags

We introduce new features into the current release with a future flag that looks something like `unstable_someFeature`. You can specify these flags in the Remix Vite Plugin `future` option in your [`vite.config.ts`][vite-config-future] file:

```ts filename=vite.config.ts lines=[7-9]
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [
    remix({
      future: {
        unstable_someFeature: true,
      },
    }),
  ],
});
```

<docs-info>If you are not yet using Vite, you can provide Future Flags via the [`remix.config.js` `future`][remix-config-future] option</docs-info>

- Once an unstable feature reaches a stable state, we remove the special prefix and include the feature in the next minor release. At this point, the API's structure remains consistent throughout subsequent minor releases.

- This approach allows us to refine the API collaboratively with early adopters, incorporating necessary changes in the unstable phase without affecting all users. The stable releases then benefit from these improvements without disruptions.

- If you're utilizing features labeled with `unstable_*` flags, it's crucial to review the release notes for each minor release. This is because the behavior or structure of these features might evolve. Your feedback during this phase is invaluable in enhancing the feature before the final release!

## Managing Breaking Changes with Future Flags

When we introduce breaking changes, we do so within the context of the current major version, and we hide them behind future flags. For instance, if we're in `v2`, a breaking change might be placed under a future flag named `v3_somethingDifferent`.

```ts filename=vite.config.ts lines=[7-9]
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [
    remix({
      future: {
        v3_someFeature: true,
      },
    }),
  ],
});
```

- Both the existing `v2` behavior and the new `v3_somethingDifferent` behavior coexist simultaneously.
- Applications can adopt changes incrementally, one step at a time, instead of having to adjust to a multitude of changes all at once in the next major release.
- If all the `v3_*` future flags are enabled, transitioning to `v3` should ideally not necessitate any changes to your codebase.
- Some future flags that bring about breaking changes initially start as `unstable_*` flags. These might undergo modifications during minor releases. Once they become `v3_*` future flags, the corresponding API is set and won't change further.

## Summary

Our development strategy focuses on gradual feature adoption and seamless version upgrades for major releases. This empowers developers to selectively integrate new features, avoiding the need for extensive code adjustments during version transitions. By introducing features through `unstable_*` flags, we refine the API collaboratively with early adopters while ensuring stable releases benefit from enhancements. Through careful management of breaking changes using `v3_*` flags, we provide the flexibility to adopt changes incrementally, facilitating a smoother transition between major versions. While this increases the complexity for developing Remix the framework, this developer-centric approach greatly simplifies application development with Remix, ultimately leading to improved software quality and (hopefully!) developer satisfaction.

[vite-config-future]: ../file-conventions/vite-config#future
[remix-config-future]: ../file-conventions/remix-config#future

---

## File: ./guides/api-routes.md

---

## title: API Routes

# API Routes

You might be used to building React apps that don't run on the server, or least not very much of it does, so it's backed by a set of API routes. In Remix, most of your routes are both your UI and your API, so Remix in the browser knows how to talk to itself on the server.

In general, you don't need the concept of "API Routes" at all. But we knew you'd come poking around with this term, so here we are!

## Routes Are Their Own API

Consider this route:

```tsx filename=app/routes/teams.tsx
export async function loader() {
  return json(await getTeams());
}

export default function Teams() {
  return <TeamsView teams={useLoaderData<typeof loader>()} />;
}
```

Whenever the user clicks a link to `<Link to="/teams" />`, Remix in the browser will perform the fetch to the server to get the data from the `loader` and render the route. The entire task of loading data into components has been taken care of. You don't need API routes for data requirements of your route components, they are already their own API.

## Call Loaders Outside of Navigation

There are times, however, that you want to get the data from a loader but not because the user is visiting the route, but the current page needs that route's data for some reason. A very clear example is a `<Combobox>` component that queries the database for records and suggests them to the user.

You can `useFetcher` for cases like this. And once again, since Remix in the browser knows about Remix on the server, you don't have to do much to get the data. Remix's error handling kicks in, and race conditions, interruptions, and fetch cancellations are handled for you, too.

For example, you could have a route to handle the search:

```tsx filename=app/routes/city-search.tsx
export async function loader({ request }: LoaderFunctionArgs) {
  const url = new URL(request.url);
  return json(await searchCities(url.searchParams.get('q')));
}
```

And then `useFetcher` along with Reach UI's combobox input:

```tsx lines=[2,11,14,19,21,23]
function CitySearchCombobox() {
  const cities = useFetcher();

  return (
    <cities.Form method="get" action="/city-search">
      <Combobox aria-label="Cities">
        <div>
          <ComboboxInput name="q" onChange={(event) => cities.submit(event.target.form)} />
          {cities.state === 'submitting' ? <Spinner /> : null}
        </div>

        {cities.data ? (
          <ComboboxPopover className="shadow-popup">
            {cities.data.error ? (
              <p>Failed to load cities :(</p>
            ) : cities.data.length ? (
              <ComboboxList>
                {cities.data.map((city) => (
                  <ComboboxOption key={city.id} value={city.name} />
                ))}
              </ComboboxList>
            ) : (
              <span>No results found</span>
            )}
          </ComboboxPopover>
        ) : null}
      </Combobox>
    </cities.Form>
  );
}
```

## Resource Routes

In other cases, you may need routes that are part of your application, but aren't part of your application's UI. Maybe you want a loader that renders a report as a PDF:

```tsx
export async function loader({ params }: LoaderFunctionArgs) {
  const report = await getReport(params.id);
  const pdf = await generateReportPDF(report);
  return new Response(pdf, {
    status: 200,
    headers: {
      'Content-Type': 'application/pdf',
    },
  });
}
```

If a route is not called by Remix UI (like `<Link>` or `useFetcher`), and does not export a default component, it is now a general purpose Resource Route. If called with `GET`, the loader's response is returned. If called with `POST`, `PUT`, `PATCH`, or `DELETE`, the action's response is returned.

Here are a handful of use cases to get you thinking.

- JSON API for a mobile app that reuses server-side code with the Remix UI
- Dynamically generating PDFs
- Dynamically generating social images for blog posts or other pages
- Webhooks for other services

You can read more in the [Resource Routes][resource-routes] docs.

[resource-routes]: ./resource-routes

---

## File: ./guides/authentication.md

---

title: Authentication
hidden: true

---

---

## File: ./guides/bff.md

---

title: Backend For Frontend
toc: false

---

# Backend For Your Frontend

While Remix can serve as your fullstack application, it also fits perfectly into the "Backend for your Frontend" architecture.

The BFF strategy employs a web server with a job scoped to serving the frontend web app and connecting it to the services it needs: your database, mailer, job queues, existing backend APIs (REST, GraphQL), etc. Instead of your UI integrating directly from the browser to these services, it connects to the BFF and the BFF connects to your services.

Mature apps already have a lot of backend application code in Ruby, Elixir, PHP, etc. and there's no reason to justify migrating it all to a server-side JavaScript runtime just to get the benefits of Remix. Instead, you can use your Remix app as a backend for your frontend.

Because Remix polyfills the Web Fetch API, you can use `fetch` right from your loaders and actions to your backend.

```tsx lines=[11,17,21]
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno
import escapeHtml from 'escape-html';

export async function loader({ request }: LoaderFunctionArgs) {
  const apiUrl = 'http://api.example.com/some-data.json';
  const res = await fetch(apiUrl, {
    headers: {
      Authorization: `Bearer ${process.env.API_TOKEN}`,
    },
  });

  const data = await res.json();

  const prunedData = data.map((record) => {
    return {
      id: record.id,
      title: record.title,
      formattedBody: escapeHtml(record.content),
    };
  });
  return json(prunedData);
}
```

There are several benefits of this approach vs. fetching directly from the browser. The highlighted lines above show how you can:

1. Simplify third party integrations and keep tokens and secrets out of client bundles.
2. Prune the data down to send less kB over the network, speeding up your app significantly.
3. Move a lot of code from browser bundles to the server, like `escapeHtml`, which speeds up your app. Additionally, moving code to the server usually makes your code easier to maintain since server-side code doesn't have to worry about UI states for async operations.

Again, Remix can be used as your only server by talking directly to the database and other services with server-side JavaScript APIs, but it also works perfectly as a backend for your frontend. Go ahead and keep your existing API server for application logic and let Remix connect the UI to it.

---

## File: ./guides/breadcrumbs.md

---

## title: Breadcrumbs Guide

# Breadcrumbs Guide

In Remix, you can easily build dynamic breadcrumbs based on your route hierarchy. This guide will take you through the process using the [`useMatches`][use-matches] and [`handle`][handle] features.

## Understanding the Basics

Remix provides access to all route matches and related data at the top of the React element tree. This enables components like [`<Meta />`][meta-component], [`<Links />`][links-component], and [`<Scripts />`][scripts-component] to obtain values from nested routes and render them at the top of the document.

You can use a similar strategy using the `useMatches` and `handle` functions. While we're focusing on breadcrumbs, the principles demonstrated here are applicable to a range of scenarios.

## Defining the Breadcrumbs for Routes

Start by adding a `breadcrumb` attribute to your route's `handle`. This attribute isn't specific to Remix ‚Äì you can name it whatever you like. For our example, we'll call it `breadcrumb`.

```tsx filename=app/routes/parent.tsx
export const handle = {
  breadcrumb: () => <Link to="/parent">Some Route</Link>,
};
```

Similarly, you can define breadcrumbs for child routes:

```tsx filename=app/routes/parent.child.tsx
export const handle = {
  breadcrumb: () => <Link to="/parent/child">Child Route</Link>,
};
```

## Aggregating Breadcrumbs in the Root Route

Now, bring everything together in your root route using `useMatches`:

```tsx filename=app/root.tsx lines=[5,9,19-28]
import { Links, Scripts, useLoaderData, useMatches } from '@remix-run/react';

export default function Root() {
  const matches = useMatches();

  return (
    <html lang="en">
      <head>
        <Links />
      </head>
      <body>
        <header>
          <ol>
            {matches
              .filter((match) => match.handle && match.handle.breadcrumb)
              .map((match, index) => (
                <li key={index}>{match.handle.breadcrumb(match)}</li>
              ))}
          </ol>
        </header>
        <Outlet />
      </body>
    </html>
  );
}
```

Note that we pass the `match` object to breadcrumbs, allowing us to potentially utilize `match.data` for enhancing breadcrumb content based on the route's data. This example doesn't use it, but you'll likely want to use values from your loader data for the breadcrumb.

Using `useMatches` with `handle` offers a robust way for routes to contribute to rendering processes higher up the element tree than their actual render point.

## Additional Resources

- [`useMatches`][use-matches]
- [`handle`][handle]

[use-matches]: ../hooks/use-matches
[handle]: ../route/handle
[meta-component]: ../components/meta
[links-component]: ../components/links
[scripts-component]: ../components/scripts

---

## File: ./guides/browser-support.md

---

## title: Browser Support

# Browser Support

Remix only runs in browsers that support [ES Modules][esm-browsers].

Usually teams are concerned about IE11 support when asking this question. Note that [Microsoft itself has stopped supporting this browser][msie] for their web applications and it's probably time for you, too.

However, thanks to first-class support for [Progressive Enhancement][pe], Remix apps can support browsers as old as Netscape 1.0! This works because Remix is built on the foundations of the web: HTML, HTTP, and browser behavior. By following Remix conventions, your app can work at a baseline level for IE11, while still providing a highly-interactive SPA experience for modern browsers. It doesn't take much effort on your part to achieve this, either.

Here's how it works. The Remix `<Scripts/>` component renders module script tags like this:

```html
<script type="module" src="..." />
```

Older browsers ignore it because they don't understand the `type`, so no JavaScript is loaded. Links, loaders, forms, and actions still work because they are built on the foundations of HTML, HTTP and browser behavior. Modern browsers will load the scripts, providing enhanced SPA behavior with faster transitions and the enhanced UX of your application code.

## Does Remix implement CSRF protection?

Remix cookies are configured to `SameSite=Lax` by default which is a platform built-in protection against CSRF, if you need to support old browsers (IE11 or older) that doesn't support `SameSite=Lax` you would have to implement CSRF protection yourself or use a library that implements it.

[pe]: https://en.wikipedia.org/wiki/Progressive_enhancement
[esm-browsers]: https://caniuse.com/es6-module
[msie]: https://techcommunity.microsoft.com/t5/microsoft-365-blog/microsoft-365-apps-say-farewell-to-internet-explorer-11-and/ba-p/1591666

---

## File: ./guides/cache-control.md

---

title: Cache-Control
hidden: true

---

# Cache Control

## In Routes Modules

Each route can also define its http headers. This is mostly important for http caching. Remix doesn't rely on building your website into static files to be uploaded to a CDN for performance, instead we rely on cache headers. The end result of either approach is the same: a static document on a CDN. [Check out this video for more information on that][check-out-this-video-for-more-information-on-that].

Usually, the difficulty with cache headers is configuring them. In Remix we've made it easy. Just export a `headers` function from your route.

```tsx
export function headers() {
  return {
    'Cache-Control': 'public, max-age=300, s-maxage=3600',
  };
}

export function meta() {
  /* ... */
}

export default function Gists() {
  /* ... */
}
```

The max-age tells the user's browser to cache this for 300 seconds, or 5 minutes. That means if they click back or on a link to the same page again within 5 minutes, the browser won't even make a request for the page, it will use the cache.

The s-maxage tells the CDN to cache it for an hour. Here's what it looks like when the first person visits our website:

1. Request comes in to the website, which is really the CDN
2. CDN doesn't have the document cached, so it makes a request to our server (the "origin server").
3. Our server builds the page and sends it to the CDN
4. The CDN caches it and sends it to the visitor.

Now, when the next person visits our page, it looks like this:

1. Request comes to the CDN
2. CDN has the document cached already and sends it right away without ever touching our origin server!

We have a lot more to say about caching in the [CDN Caching][cdn-caching] guide, make sure to read it sometime.

## In Loaders

We saw that our routes can define their cache control, so why does it matter for loaders? It matters for two reasons:

First, your data usually knows better what the cache control should be than your route because the data changes more often than the markup. Because of this, the loader's headers are passed to the route's header function.

Open up `app/routes/gists.ts` and update your headers function like so:

```tsx
export function headers({ loaderHeaders }: { loaderHeaders: Headers }) {
  return {
    'Cache-Control': loaderHeaders.get('Cache-Control'),
  };
}
```

The `loaderHeaders` object is an instance of the [Web Fetch API Headers constructor][web-fetch-api-headers-constructor]

Now when the browser or a CDN wants to cache our page, it gets the headers from our data source, which is usually what you want. Note in our case we're actually just using headers GitHub sent in the response from our fetch!

The second reason this matters is that Remix calls your loaders via `fetch` in the browser on client-side transitions. By returning good cache headers here, when the user clicks back/forward or visits the same page multiple times, the browser won't actually make another request for the data but will use a cached version instead. This greatly speeds up a website's performance, even for pages that you can't cache on a CDN. A lot of React apps rely on a JavaScript cache, but browser caches already work great!

[check-out-this-video-for-more-information-on-that]: https://youtu.be/bfLFHp7Sbkg
[cdn-caching]: ../guides/caching
[web-fetch-api-headers-constructor]: https://developer.mozilla.org/en-US/docs/Web/API/Headers

---

## File: ./guides/client-data.md

---

## title: Client Data

# Client Data

Remix introduced support for "Client Data" ([RFC][rfc]) in [`v2.4.0`][2.4.0] which allows you to opt-into running route loaders/actions in the browser via [`clientLoader`][clientloader]/[`clientAction`][clientaction] exports from your route.

These new exports are a bit of a sharp knife and are not recommended as your _primary_ data loading/submission mechanisms - but instead give you a lever to pull on for some of the following advanced use cases:

- **Skip the Hop:** Query a data API directly from the browser, using loaders simply for SSR
- **Fullstack State:** Augment server data with client data for your full set of loader data
- **One or the Other:** Sometimes you use server loaders, sometimes you use client loaders, but not both on one route
- **Client Cache:** Cache server loader data in the client and avoid some server calls
- **Migration:** Ease your migration from React Router -> Remix SPA -> Remix SSR (once Remix supports [SPA Mode][rfc-spa])

Please use these new exports with caution! If you're not careful - it's easy to get your UI out of sync. Remix out of the box tries _very_ hard to ensure that this doesn't happen - but once you take control over your own client-side cache, and potentially prevent Remix from performing its normal server `fetch` calls - then Remix can no longer guarantee your UI remains in sync.

## Skip the Hop

When using Remix in a [BFF][bff] architecture, it may be advantageous to skip the Remix server hop and hit your backend API directly. This assumes you are able to handle authentication accordingly and are not subject to CORS issues. You can skip the Remix BFF hop as follows:

1. Load the data from server `loader` on the document load
2. Load the data from the `clientLoader` on all subsequent loads

In this scenario, Remix will _not_ call the `clientLoader` on hydration - and will only call it on subsequent navigations.

```tsx lines=[8,15]
import type { LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import type { ClientLoaderFunctionArgs } from '@remix-run/react';

export async function loader({ request }: LoaderFunctionArgs) {
  const data = await fetchApiFromServer({ request }); // (1)
  return json(data);
}

export async function clientLoader({ request }: ClientLoaderFunctionArgs) {
  const data = await fetchApiFromClient({ request }); // (2)
  return data;
}
```

## Fullstack State

Sometimes, you may want to leverage "Fullstack State" where some of your data comes from the server, and some of your data comes from the browser (i.e., `IndexedDB` or other browser SDKs) - but you can't render your component until you have the combined set of data. You can combine these two data sources as follows:

1. Load the partial data from server `loader` on the document load
2. Export a [`HydrateFallback`][hydratefallback] component to render during SSR because we don't yet have a full set of data
3. Set `clientLoader.hydrate = true`, this instructs Remix to call the clientLoader as part of initial document hydration
4. Combine the server data with the client data in `clientLoader`

```tsx lines=[8-10,23-24,27,30]
import type { LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import type { ClientLoaderFunctionArgs } from '@remix-run/react';

export async function loader({ request }: LoaderFunctionArgs) {
  const partialData = await getPartialDataFromDb({
    request,
  }); // (1)
  return json(partialData);
}

export async function clientLoader({ request, serverLoader }: ClientLoaderFunctionArgs) {
  const [serverData, clientData] = await Promise.all([serverLoader(), getClientData(request)]);
  return {
    ...serverData, // (4)
    ...clientData, // (4)
  };
}
clientLoader.hydrate = true; // (3)

export function HydrateFallback() {
  return <p>Skeleton rendered during SSR</p>; // (2)
}

export default function Component() {
  // This will always be the combined set of server + client data
  const data = useLoaderData();
  return <>...</>;
}
```

## One or the Other

You may want to mix and match data loading strategies in your application such that some routes only load data on the server and some routes only load data on the client. You can choose per route as follows:

1. Export a `loader` when you want to use server data
2. Export `clientLoader` and a `HydrateFallback` when you want to use client data

A route that only depends on a server loader looks like this:

```tsx filename=app/routes/server-data-route.tsx
import type { LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';

export async function loader({ request }: LoaderFunctionArgs) {
  const data = await getServerData(request);
  return json(data);
}

export default function Component() {
  const data = useLoaderData(); // (1) - server data
  return <>...</>;
}
```

A route that only depends on a client loader looks like this.

```tsx filename=app/routes/client-data-route.tsx
import type { ClientLoaderFunctionArgs } from '@remix-run/react';

export async function clientLoader({ request }: ClientLoaderFunctionArgs) {
  const clientData = await getClientData(request);
  return clientData;
}
// Note: you do not have to set this explicitly - it is implied if there is no `loader`
clientLoader.hydrate = true;

// (2)
export function HydrateFallback() {
  return <p>Skeleton rendered during SSR</p>;
}

export default function Component() {
  const data = useLoaderData(); // (2) - client data
  return <>...</>;
}
```

## Client Cache

You can leverage a client-side cache (memory, local storage, etc.) to bypass certain calls to the server as follows:

1. Load the data from server `loader` on the document load
2. Set `clientLoader.hydrate = true` to prime the cache
3. Load subsequent navigations from the cache via `clientLoader`
4. Invalidate the cache in your `clientAction`

Note that since we are not exporting a `HydrateFallback` component, we will SSR the route component and then run the `clientLoader` on hydration, so it's important that your `loader` and `clientLoader` return the same data on initial load to avoid hydration errors.

```tsx lines=[14,36,42,49,56]
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import type { ClientActionFunctionArgs, ClientLoaderFunctionArgs } from '@remix-run/react';

export async function loader({ request }: LoaderFunctionArgs) {
  const data = await getDataFromDb({ request }); // (1)
  return json(data);
}

export async function action({ request }: ActionFunctionArgs) {
  await saveDataToDb({ request });
  return json({ ok: true });
}

let isInitialRequest = true;

export async function clientLoader({ request, serverLoader }: ClientLoaderFunctionArgs) {
  const cacheKey = generateKey(request);

  if (isInitialRequest) {
    isInitialRequest = false;
    const serverData = await serverLoader();
    cache.set(cacheKey, serverData); // (2)
    return serverData;
  }

  const cachedData = await cache.get(cacheKey);
  if (cachedData) {
    return cachedData; // (3)
  }

  const serverData = await serverLoader();
  cache.set(cacheKey, serverData);
  return serverData;
}
clientLoader.hydrate = true; // (2)

export async function clientAction({ request, serverAction }: ClientActionFunctionArgs) {
  const cacheKey = generateKey(request);
  cache.delete(cacheKey); // (4)
  const serverData = await serverAction();
  return serverData;
}
```

## Migration

We expect to write up a separate guide for migrations once [SPA Mode][rfc-spa] lands, but for now we expect that the process will be something like:

1. Introduce data patterns in your React Router SPA by moving to `createBrowserRouter`/`RouterProvider`
2. Move your SPA to use Vite to better prepare for the Remix migration
3. Incrementally move to file-based route definitions via the use of a Vite plugin (not yet provided)
4. Migrate your React Router SPA to Remix SPA Mode where all current file-based `loader` function act as `clientLoader`
5. Opt out of Remix SPA Mode (and into Remix SSR mode) and find/replace your `loader` functions to `clientLoader`
   - You're now running an SSR app but all your data loading is still happening in the client via `clientLoader`
6. Incrementally start moving `clientLoader -> loader` to start moving data loading to the server

[rfc]: https://github.com/remix-run/remix/discussions/7634
[2.4.0]: https://github.com/remix-run/remix/blob/main/CHANGELOG.md#v240
[clientloader]: ../route/client-loader
[clientaction]: ../route/client-action
[hydratefallback]: ../route/hydrate-fallback
[rfc-spa]: https://github.com/remix-run/remix/discussions/7638
[bff]: ../guides/bff

---

## File: ./guides/concurrent-submissions.md

---

title: Concurrent Submissions
hidden: true

---

---

## File: ./guides/constraints.md

---

## title: Module Constraints

# Module Constraints

In order for Remix to run your app in both the server and browser environments, your application modules and third-party dependencies need to be careful about **module side effects**.

- **Server-only code** - Remix will remove server-only code, but it can't if you have module side effects that use server-only code.
- **Browser-only code** - Remix renders on the server so your modules can't have module side effects or first-rendering logic that call browser-only APIs

## Server Code Pruning

The Remix compiler will automatically remove server code from the browser bundles. Our strategy is actually pretty straightforward, but requires you to follow some rules.

1. It creates a "proxy" module in front of your route module
2. The proxy module only imports the browser specific exports

Consider a route module that exports `loader`, `meta`, and a component:

```tsx
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData } from '@remix-run/react';

import { prisma } from '../db';
import PostsView from '../PostsView';

export async function loader() {
  return json(await prisma.post.findMany());
}

export function meta() {
  return [{ title: 'Posts' }];
}

export default function Posts() {
  const posts = useLoaderData<typeof loader>();
  return <PostsView posts={posts} />;
}
```

The server needs everything in this file but the browser only needs the component and `meta`. In fact, it'll be completely broken if it includes the `prisma` module in the browser bundle. That thing is full of node-only APIs!

To remove the server code from the browser bundles, the Remix compiler creates a proxy module in front of your route and bundles that instead. The proxy for this route would look like:

```tsx
export { meta, default } from './routes/posts.tsx';
```

The compiler will now analyze the code in `app/routes/posts.tsx` and only keep code that's inside of `meta` and the component. The result is something like this:

```tsx
import { useLoaderData } from '@remix-run/react';

import PostsView from '../PostsView';

export function meta() {
  return [{ title: 'Posts' }];
}

export default function Posts() {
  const posts = useLoaderData<typeof loader>();
  return <PostsView posts={posts} />;
}
```

Pretty slick! This is now safe to bundle up for the browser. So what's the problem?

### No Module Side Effects

If you're unfamiliar with side effects, you're not alone! We'll help you identify them now.

Simply put, a **side effect** is any code that might _do something_. A **module side effect** is any code that might _do something when a module is loaded_.

<docs-info>A module side effect is code that executes by simply importing a module</docs-info>

Taking our code from earlier, we saw how the compiler can remove the exports and their imports that aren't used. But if we add this seemingly harmless line of code your app will break!

```tsx bad lines=[7]
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData } from '@remix-run/react';

import { prisma } from '../db';
import PostsView from '../PostsView';

console.log(prisma);

export async function loader() {
  return json(await prisma.post.findMany());
}

export function meta() {
  return [{ title: 'Posts' }];
}

export default function Posts() {
  const posts = useLoaderData<typeof loader>();
  return <PostsView posts={posts} />;
}
```

That `console.log` _does something_. The module is imported and then immediately logs to the console. The compiler won't remove it because it has to run when the module is imported. It will bundle something like this:

```tsx bad lines=[3,6]
import { useLoaderData } from '@remix-run/react';

import { prisma } from '../db'; //üò¨
import PostsView from '../PostsView';

console.log(prisma); //ü•∂

export function meta() {
  return [{ title: 'Posts' }];
}

export default function Posts() {
  const posts = useLoaderData<typeof loader>();
  return <PostsView posts={posts} />;
}
```

The loader is gone but the prisma dependency stayed! Had we logged something harmless like `console.log("hello!")` it would be fine. But we logged the `prisma` module so the browser's going to have a hard time with that.

To fix this, remove the side effect by simply moving the code _into the loader_.

```tsx lines=[8]
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData } from '@remix-run/react';

import { prisma } from '../db';
import PostsView from '../PostsView';

export async function loader() {
  console.log(prisma);
  return json(await prisma.post.findMany());
}

export function meta() {
  return [{ title: 'Posts' }];
}

export default function Posts() {
  const posts = useLoaderData<typeof loader>();
  return <PostsView posts={posts} />;
}
```

This is no longer a module side effect (runs when the module is imported), but rather a side effect of the loader (runs when the loader is called). The compiler will now remove both the loader _and the prisma import_ because it isn't used anywhere else in the module.

Occasionally, the build may have trouble tree-shaking code that should only run on the server. If this happens, you can use the convention of naming a file with the extension `.server` before the file type, for example `db.server.ts`. Adding `.server` to the filename is a hint to the compiler to not worry about this module or its imports when bundling for the browser.

### Higher Order Functions

Some Remix newcomers try to abstract their loaders with "higher order functions". Something like this:

```ts bad filename=app/http.ts
import { redirect } from '@remix-run/node'; // or cloudflare/deno

export function removeTrailingSlash(loader) {
  return function (arg) {
    const { request } = arg;
    const url = new URL(request.url);
    if (url.pathname !== '/' && url.pathname.endsWith('/')) {
      return redirect(request.url.slice(0, -1), {
        status: 308,
      });
    }
    return loader(arg);
  };
}
```

And then try to use it like this:

```ts bad filename=app/root.ts
import { json } from '@remix-run/node'; // or cloudflare/deno

import { removeTrailingSlash } from '@/http';

export const loader = removeTrailingSlash(({ request }) => {
  return json({ some: 'data' });
});
```

You can probably now see that this is a module side effect so the compiler can't prune out the `removeTrailingSlash` code.

This type of abstraction is introduced to try to return a response early. Since you can throw a Response in a `loader`, we can make this simpler and remove the module side effect at the same time so that the server code can be pruned:

```ts filename=app/http.ts
import { redirect } from '@remix-run/node'; // or cloudflare/deno

export function removeTrailingSlash(url) {
  if (url.pathname !== '/' && url.pathname.endsWith('/')) {
    throw redirect(request.url.slice(0, -1), {
      status: 308,
    });
  }
}
```

And then use it like this:

```tsx filename=app/root.tsx
import { json } from '@remix-run/node'; // or cloudflare/deno

import { removeTrailingSlash } from '@/http';

export const loader = async ({ request }: LoaderFunctionArgs) => {
  removeTrailingSlash(request.url);
  return json({ some: 'data' });
};
```

It reads much nicer as well when you've got a lot of these:

```tsx
// this
export const loader = async ({ request }: LoaderFunctionArgs) => {
  return removeTrailingSlash(request.url, () => {
    return withSession(request, (session) => {
      return requireUser(session, (user) => {
        return json(user);
      });
    });
  });
};
```

```tsx
// vs. this
export const loader = async ({ request }: LoaderFunctionArgs) => {
  removeTrailingSlash(request.url);
  const session = await getSession(request);
  const user = await requireUser(session);
  return json(user);
};
```

If you want to do some extracurricular reading, google around for "push vs. pull API". The ability to throw responses changes the model from a "push" to a "pull". This is the same reason folks prefer async/await over callbacks, and React hooks over higher order components and render props.

## Browser-Only Code on the Server

Unlike the browser bundles, Remix doesn't try to remove _browser only code_ from the server bundle because the route modules require every export to render on the server. This means it's your job to be mindful of code that should only execute in the browser.

<docs-error>This will break your app:</docs-error>

```ts bad lines=3
import { loadStripe } from '@stripe/stripe-js';

const stripe = await loadStripe(window.ENV.stripe);

export async function redirectToStripeCheckout(sessionId: string) {
  return stripe.redirectToCheckout({ sessionId });
}
```

<docs-info>You need to avoid any browser-only module side effects like accessing window or initializing APIs in the module scope.</docs-info>

### Initializing Browser-Only APIs

The most common scenario is initializing a third-party API when your module is imported. There are a couple ways to easily deal with this.

#### Document Guard

This ensures the library is only initialized if there is a `document`, meaning you're in the browser. We recommend `document` over `window` because server runtimes like Deno have a global `window` available.

```ts lines=[3]
import firebase from 'firebase/app';

if (typeof document !== 'undefined') {
  firebase.initializeApp(document.ENV.firebase);
}

export { firebase };
```

#### Lazy Initialization

This strategy defers initialization until the library is actually used:

```ts lines=[4]
import { loadStripe } from '@stripe/stripe-js';

export async function redirectToStripeCheckout(sessionId: string) {
  const stripe = await loadStripe(window.ENV.stripe);
  return stripe.redirectToCheckout({ sessionId });
}
```

You may want to avoid initializing the library multiple times by storing it in a module-scoped variable.

```ts
import { loadStripe } from '@stripe/stripe-js';

let _stripe;
async function getStripe() {
  if (!_stripe) {
    _stripe = await loadStripe(window.ENV.stripe);
  }
  return _stripe;
}

export async function redirectToStripeCheckout(sessionId: string) {
  const stripe = await getStripe();
  return stripe.redirectToCheckout({ sessionId });
}
```

<docs-info>While none of these strategies remove browser modules from the server bundle, it's okay because the APIs are only called inside of event handlers and effects, which are not module side effects.</docs-info>

### Rendering with Browser Only APIs

Another common case is code that calls browser-only APIs while rendering. When server rendering in React (not just Remix), this must be avoided because the APIs don't exist on the server.

<docs-error>This will break your app because the server will try to use local storage</docs-error>

```ts bad lines=2
function useLocalStorage(key: string) {
  const [state, setState] = useState(localStorage.getItem(key));

  const setWithLocalStorage = (nextState) => {
    setState(nextState);
  };

  return [state, setWithLocalStorage];
}
```

You can fix this by moving the code into `useEffect`, which only runs in the browser.

```tsx lines=[2,4-6]
function useLocalStorage(key: string) {
  const [state, setState] = useState(null);

  useEffect(() => {
    setState(localStorage.getItem(key));
  }, [key]);

  const setWithLocalStorage = (nextState) => {
    setState(nextState);
  };

  return [state, setWithLocalStorage];
}
```

Now `localStorage` is not being accessed on the initial render, which will work for the server. In the browser, that state will fill in immediately after hydration. Hopefully it doesn't cause a big content layout shift though! If it does, maybe move that state into your database or a cookie, so you can access it server side.

### `useLayoutEffect`

If you use this hook React will warn you about using it on the server.

This hook is great when you're setting state for things like:

- The position of an element when it pops up (like a menu button)
- The scroll position in response to user interactions

The point is to perform the effect at the same time as the browser paint so that you don't see the popup show up at `0,0` and then bounce into place. Layout effects let the paint and the effect happen at the same time to avoid this kind of flashing.

It is **not** good for setting state that is rendered inside of elements. Just make sure you aren't using the state set in a `useLayoutEffect` in your elements, and you can ignore React's warning.

If you know you're calling `useLayoutEffect` correctly and just want to silence the warning, a popular solution in libraries is to create your own hook that doesn't call anything on the server. `useLayoutEffect` only runs in the browser anyway, so this should do the trick. **Please use this carefully, because the warning is there for a good reason!**

```ts
import * as React from 'react';

const canUseDOM = !!(
  typeof window !== 'undefined' &&
  window.document &&
  window.document.createElement
);

const useLayoutEffect = canUseDOM ? React.useLayoutEffect : () => {};
```

### Third-Party Module Side Effects

Some third party libraries have their own module side effects that are incompatible with React server rendering. Usually it's trying to access `window` for feature detection.

These libraries are incompatible with server rendering in React and therefore incompatible with Remix. Fortunately, very few third party libraries in the React ecosystem do this.

We recommend finding an alternative. But if you can't, we recommend using [patch-package][patch-package] to fix it up in your app.

[patch-package]: https://www.npmjs.com/package/patch-package

---

## File: ./guides/contributing.md

---

title: Contributing
description: Thank you for contributing to Remix! Here's everything you need to know before you open a pull request.

---

# Contributing to Remix

Our goal is for Remix development to be steady, stable, and open. We can't do that without our wonderful community of users!

This document will familiarize you with our development process as well as how to get your environment set up.

**To ensure your work has the best chance of being accepted, please read this before contributing anything!**

## Contributor License Agreement

All contributors sending a Pull Request need to sign the Contributor License Agreement (CLA) that explicitly assigns ownership of the contribution to us.

When you start a pull request, the remix-cla-bot will prompt you to review the CLA and sign it by adding your name to [contributors.yml][contributors_yaml]

[Read the CLA][cla]

## Roles

This document refers to contributors with the following roles:

- **Admins**: GitHub organization team with admin rights, they set and manage the Roadmap.
- **Collaborators**: GitHub organization team with write access. They manage issues, PRs, discussion, etc.
- **Contributors**: you!

---

## Development Process

### Feature Development

If you have an idea for a new feature, please don't send a Pull Request, but follow this process instead:

1. Contributors add a **Proposal** to [GitHub Discussions][proposals].
2. The Remix **Admin Team** accepts Proposals in the **Roadmap Planning** meeting.
   - Proposals are accepted when the Admins create an **Issue** from the Proposal and add the issue to the [**Roadmap**][roadmap].
3. The Admins assign an **Owner** to the issue.
   - Owners are responsible for shipping the feature including all decisions for APIs, behavior, and implementation.
   - Owners organize the work with other contributors for larger issues.
   - Owners may be contributors from inside or outside the Remix team.
4. Owners create an **RFC** from the Proposal and development can begin.
5. Pairing is highly encouraged, particularly at the start.

### Bug-Fix Pull Requests

If you think you've found a bug we'd love a PR that fixes it! Please follow these guidelines:

1. Contributors add a failing test along with the fix in a Pull Request
   - It's ideal if the first commit is a failing test followed by the changes to the code that fix it.
   - This is not strictly enforced but very appreciated!
2. The Admins will review open bugfix PRs as part of Roadmap Planning.
   - Simple bugfixes will be merged on the spot.
   - Others will be added to the Roadmap and assigned an Owner to review the work and get it over the finish line.

Bug fix PRs without a test case might be closed immediately (some things are hard to test, we‚Äôll use discretion here)

### Bug Report Issues

If you think you've found a bug but don't have the time to send a PR, please follow these guidelines:

1. Create a minimal reproduction of the issue somewhere like Stackblitz, Replit, CodeSandbox, etc. that we can visit and observe the bug:

   - [https://remix.new][https_remix_new] makes this really easy

2. If this is not possible (related to some hosting setup, etc.) please create a GitHub repo that we can run with clear instructions in the README to observe the bug.

3. Open an issue and link to the reproduction.

Bug reports without a reproduction will be immediately closed asking for a reproduction.

### Roadmap Planning Meeting

You can always check in on Remix development in our live-streamed planning meeting:

- The Remix Admin team will meet weekly to report progress to the community and add Proposals and Verified Bugs to the Roadmap.
  - Unanimous agreement among the Remix Admin is required to add a Proposal to the Roadmap.
  - Proposals are not ‚Äúrejected‚Äù, only ‚Äúaccepted‚Äù onto the Roadmap.
  - Contributors can continue to up-vote and comment on Proposals, they will bubble up for a future review if it‚Äôs getting new activity.
  - The Remix Admin team may lock Proposals for any reason.
- The meeting will be livestreamed on the [Remix YouTube channel][youtube].
  - Everyone is invited to the [Discord][discord] `#roadmap-livestream-chat` while the meeting is in progress.
  - Remix Collaborators are invited to attend.

### Issue Tracking

If a Roadmap Issue is expected to be large (involving multiple tasks, authors, PRs, etc.) a temporary project board will be created by the Admin team.

- The original issue will remain on the Roadmap project to see general progress.
- The subtasks will be tracked on the temporary project.
- When the work is complete, the temporary project will be archived.
- The Owner is responsible for populating the subproject with issues and splitting the work up into shippable chunks of work.
- Build / feature flags are encouraged over long-running branches.

### RFCs

- All Issues that are planned must have an RFC posted in the Official RFCs Discussion category before the Issue moves from _Planned_ to _In Progress_.
- Some Proposals may already be a sufficient RFC and can simply be moved to the Official RFCs Discussion category.
- Once the RFC is posted, development can begin, though Owners are expected to consider the community's feedback to alter their direction when needed.

### Support for Owners

- Owners will be added to the `#collaborators` private channel on [Discord][discord] to get help with architecture and implementation. This channel is private to help keep noise to a minimum so Admins don't miss messages and owners can get unblocked. Owners can also discuss these questions in any channel or anywhere!
- Admins will actively work with owners to ensure their issues and projects are organized (correct status, links to related issues, etc.), documented, and moving forward.
- An issue's Owner may be reassigned if progress is stagnating.

### Weekly Roadmap Reviews

Once a week, the Remix team and any external **Owners** are invited to review the Roadmap

- Identify blockers
- Find pairing opportunities within the team and the community

### Collaborator's Role

To help keep the repositories clean and organized, Collaborators will take the following actions:

### Issues Tab

- Bug reports without a reproduction will be immediately closed asking for a reproduction.
- Issues that should be proposals will be converted to a Proposal.
- Questions will be converted to a **Q\&A Discussion**.
- Issues with valid reproduction will be labeled as **Verified Bugs** and added to the Roadmap by the Admins in the Roadmap Planning Meeting.

### Pull Requests Tab

- Features that did not go through the **Development Process** will be immediately closed and asked to open a discussion instead.
- Bug fix PRs without a test case might be closed immediately asking for a test. (Some things are hard to test, Collaborators will use discretion here.)

---

## Development Setup

Before you can contribute to the codebase, you will need to fork the repo. This will look a bit different depending on what type of contribution you are making:

The following steps will get you set up to contribute changes to this repo:

1. Fork the repo (click the <kbd>Fork</kbd> button at the top right of [this page][fork]).

2. Clone your fork locally.

   ```shellscript nonumber
   # in a terminal, cd to parent directory where you want your clone to be, then
   git clone https://github.com/<your_github_username>/remix.git
   cd remix

   # if you are making *any* code changes, make sure to checkout the dev branch
   git checkout dev
   ```

3. Install dependencies by running `pnpm`. If you install using `npm`, unnecessary `package-lock.json` files will be generated.

4. Install Playwright to be able to run tests properly by running `npx playwright install`, or [use the Visual Studio Code plugin][vscode_playwright].

5. Verify you've got everything set up for local development by running `pnpm test`.

### Branches

**Important:** When creating the PR in GitHub, make sure that you set the base to the correct branch.

- **`dev`** is for changes to code.
- **`main`**: is for changes to documentation and some templates.

You can set the base in GitHub when authoring the PR with the dropdown below the "Compare changes" heading:

<img src="https://raw.githubusercontent.com/remix-run/react-router/main/static/base-branch.png" alt="" width="460" height="350" />

### Tests

We use a mix of `jest` and `playwright` for our testing in this project. We have a suite of integration tests in the integration folder and packages have their own jest configuration, which are then referenced by the primary jest config in the root of the project.

The integration tests and the primary tests can be run in parallel using `npm-run-all` to make the tests run as quickly and efficiently as possible. To run these two sets of tests independently you'll need to run the individual script:

- `pnpm test:primary`
- `pnpm test:integration`

We also support watch plugins for project, file, and test filtering. To filter things down, you can use a combination of `--testNamePattern`, `--testPathPattern`, and `--selectProjects`. For example:

```shellscript nonumber
pnpm test:primary --selectProjects react --testPathPattern transition --testNamePattern "initial values"
```

We also have watch mode plugins for these. So, you can run `pnpm test:primary --watch` and hit `w` to see the available watch commands.

Alternatively, you can run a project completely independently by `cd`-ing into that project and running `pnpm jest` which will pick up that project's jest config.

## Development Workflow

### Packages

Remix uses a monorepo to host code for multiple packages. These packages live in the `packages` directory.

We use [pnpm workspaces][pnpm_workspaces] to manage installation of dependencies and running various scripts. To get everything installed run `pnpm install` from the repo root.

### Building

Running `pnpm build` from the root directory will run the build. You can run the build in watch mode with `pnpm watch`.

### Playground

It's often really useful to be able to interact with a real app while developing features for apps. So you can place an app in the `playground` directory and the build process will automatically copy all the output to the `node_modules` of all the apps in the `playground` directory for you. It will even trigger a live reload event for you!

To generate a new playground, simply run:

```shellscript nonumber
pnpm playground:new <?name>
```

Where the name of the playground is optional and defaults to `playground-${Date.now()}`. Then you can `cd` into the directory that's generated for you and run `npm run dev`. In another terminal window have `pnpm watch` running, and you're ready to work on whatever Remix features you like with live reload magic üßô‚Äç‚ôÇÔ∏è

The playground generated from `pnpm playground:new` is based on a template in `scripts/playground/template`. If you'd like to change anything about the template, you can create a custom one in `scripts/playground/template.local` which is `.gitignored` so you can customize it to your heart's content.

### Testing

Before running the tests, you need to run a build. After you build, running `pnpm test` from the root directory will run **every** package's tests. If you want to run tests for a specific package, use `pnpm test:primary --selectProjects <display-name>`:

```shellscript nonumber
# Test all packages
pnpm test

# Test only @remix-run/express
pnpm test:primary --selectProjects express
```

## Repository Branching

This repo maintains separate branches for different purposes. They will look something like this:

```
- main   > the most recent release and current docs
- dev    > code under active development between stable releases
```

There may be other branches for various features and experimentation, but all the magic happens from these branches.

## How do nightly releases work?

Nightly releases will run the action files from the `main` branch as scheduled workflows will always use the latest commit to the default branch, signified by [this comment on the nightly action file][nightly_action_comment], however they check out the `dev` branch during their setup as that's where we want our nightly releases to be cut from. From there, we check if the git SHA is the same and only cut a new nightly if something has changed.

## End-to-end testing

For every release of Remix (stable, experimental, nightly, and pre-releases), we will do a complete end-to-end test of Remix apps on each of our official adapters from `create-remix`, all the way to deploying them to production. We do this by utilizing the default [templates][templates] and the CLIs for Fly, and Arc. We'll then run some simple Cypress assertions to make sure everything is running properly for both development and the deployed app.

[proposals]: https://github.com/remix-run/remix/discussions/categories/proposals
[roadmap]: https://github.com/orgs/remix-run/projects/5
[youtube]: https://www.youtube.com/@Remix-Run/streams
[discord]: https://rmx.as/discord
[contributors_yaml]: https://github.com/remix-run/remix/blob/main/contributors.yml
[cla]: https://github.com/remix-run/remix/blob/main/CLA.md
[fork]: https://github.com/remix-run/remix
[pnpm_workspaces]: https://pnpm.io/workspaces
[vscode_playwright]: https://playwright.dev/docs/intro#using-the-vs-code-extension
[nightly_action_comment]: https://github.com/remix-run/remix/blob/main/.github/workflows/nightly.yml#L8-L12
[templates]: ./templates
[https_remix_new]: https://remix.new

---

## File: ./guides/css-files.md

---

## title: CSS Files

# CSS Files

There are two main ways to manage CSS files in Remix:

- [CSS bundling][css-bundling]
- [CSS URL imports][css-url-imports]

This guide covers the pros and cons of each approach, and provides some recommendations based on your project's specific needs.

## CSS bundling

CSS bundling is the most common approach for managing CSS files in the React community. In this model, styles are treated as module side effects and are bundled into one or more CSS files at the discretion of the bundler. It's simpler to use, requires less boilerplate, and gives the bundler more power to optimize the output.

For example, let's say you have a basic `Button` component with some styles attached to it:

```css filename=components/Button.css
.Button__root {
  background: blue;
  color: white;
}
```

```jsx filename=components/Button.jsx
import './Button.css';

export function Button(props) {
  return <button {...props} className="Button__root" />;
}
```

To use this component, you can simply import it and use it in your route file:

```jsx filename=routes/hello.jsx
import { Button } from '../components/Button';

export default function HelloRoute() {
  return <Button>Hello!</Button>;
}
```

When consuming this component, you don't have to worry about managing individual CSS files. CSS is treated as private implementation detail of the component. This is a common pattern in many component libraries and design systems and scales quite nicely.

#### CSS bundling is required for some CSS solutions

Some approaches to managing CSS files requires the use of bundled CSS.

For example, [CSS Modules][css-modules] is built on the assumption that CSS is bundled. Even though you're explicitly importing the CSS file's class names as a JavaScript object, the styles themselves are still treated as a side effect and automatically bundled into the output. You have no access to the underlying URL of the CSS file.

Another common use case where CSS bundling is required is when you're using a third-party component library that imports CSS files as side effects and relies on your bundler to handle them for you, such as [React Spectrum][react-spectrum].

#### CSS order can differ between development and production

CSS bundling comes with a notable trade-off when combined with Vite's approach to on-demand compilation.

Using the `Button.css` example presented earlier, this CSS file will be transformed into the following JavaScript code during development:

<!-- prettier-ignore-start -->

<!-- eslint-skip -->

```js
import {createHotContext as __vite__createHotContext} from "/@vite/client";
import.meta.hot = __vite__createHotContext("/app/components/Button.css");
import {updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle} from "/@vite/client";
const __vite__id = "/path/to/app/components/Button.css";
const __vite__css = ".Button__root{background:blue;color:white;}"
__vite__updateStyle(__vite__id, __vite__css);
import.meta.hot.accept();
import.meta.hot.prune(()=>__vite__removeStyle(__vite__id));
```

<!-- prettier-ignore-end -->

It's worth stressing that this transformation only happens in development. **Production builds won't look like this** since static CSS files are generated.

Vite does this so that CSS can be compiled lazily when imported and then hot reloaded during development. As soon as this file is imported, the CSS file's contents are injected into the page as a side effect.

The downside of this approach is that these styles are not tied to the route lifecycle. This means that styles won't be unmounted when navigating away from the route, leading to a build-up of old styles in the document while navigating around the app. This can result in CSS rule order differing between development and production.

To mitigate this, it's helpful to write your CSS in a way that makes it resilient against changes to file ordering. For example, you can use [CSS Modules][css-modules] to ensure that CSS files are scoped to the files that import them. You should also try to limit the number of CSS files that target a single element since the order of those files is not guaranteed.

#### Bundled CSS can disappear in development

Another notable tradeoff with Vite's approach to CSS bundling during development is that React can inadvertently remove styles from the document.

When React is used to render the entire document (as Remix does) you can run into issues when elements are dynamically injected into the `head` element. If the document is re-mounted, the existing `head` element is removed and replaced with an entirely new one, removing any `style` elements that Vite injects during development.

In Remix, this issue can happen due to hydration errors since it causes React to re-render the entire page from scratch. Hydration errors can be caused by your app code, but they can also be caused by browser extensions that manipulate the document.

This is a known React issue that is fixed in their [canary release channel][react-canaries]. If you understand the risks involved, you can pin your app to a specific [React version][react-versions] and then use [package overrides][package-overrides] to ensure this is the only version of React used throughout your project. For example:

```json filename=package.json
{
  "dependencies": {
    "react": "18.3.0-canary-...",
    "react-dom": "18.3.0-canary-..."
  },
  "overrides": {
    "react": "18.3.0-canary-...",
    "react-dom": "18.3.0-canary-..."
  }
}
```

<docs-info>For reference, this is how Next.js treats React versioning internally on your behalf, so this approach is more widely used than you might expect, even though it's not something Remix provides as a default.</docs-info>

Again, it's worth stressing that this issue with styles that were injected by Vite only happens in development. **Production builds won't have this issue** since static CSS files are generated.

## CSS URL Imports

The other main way to manage CSS files is to use [Vite's explicit URL imports][vite-url-imports].

Vite lets you append `?url` to your CSS file imports to get the URL of the file (e.g. `import href from "./styles.css?url"`). This URL can then be passed to Remix via the [links export][links-export] from route modules. This ties CSS files into Remix's routing lifecycle, ensuring styles are injected and removed from the document while navigating around the app.

For example, using the same `Button` component example from earlier, you can export a `links` array alongside the component so that consumers have access to its styles.

```jsx filename=components/Button.jsx lines=[1,3-5]
import buttonCssUrl from './Button.css?url';

export const links = [{ rel: 'stylesheet', href: buttonCssUrl }];

export function Button(props) {
  return <button {...props} className="Button__root" />;
}
```

When importing this component, consumers now also need to import this `links` array and attach it to their route's `links` export:

```jsx filename=routes/hello.jsx lines=[3,6]
import { Button, links as buttonLinks } from '../components/Button';

export const links = () => [...buttonLinks];

export default function HelloRoute() {
  return <Button>Hello!</Button>;
}
```

This approach is much more predictable in terms of rule ordering since it gives you granular control over each file and provides consistent behavior between development and production. As opposed to bundled CSS during development, styles are removed from the document when they are no longer needed. If the page's `head` element is ever re-mounted, any `link` tags defined by your routes will also be re-mounted since they are part of the React lifecycle.

The downside of this approach is that it can result in a lot of boilerplate.

If you have many re-usable components each with their own CSS file, you'll need to manually surface all `links` for each component up to your route components, which may require passing CSS URLs up through multiple levels of components. This can also be error prone since it's easy to forget to import a component's `links` array.

Despite its advantages, you may find this to be too cumbersome compared to CSS bundling, or you may find the extra boilerplate to be worth it. There's no right or wrong on this one.

## Conclusion

It's ultimately personal preference when it comes to managing CSS files in your Remix application, but here's a good rule of thumb:

- If your project only has a small number of CSS files (e.g. when using Tailwind, in which case you might only have a single CSS file), you should use CSS URL imports. The increased boilerplate is minimal and your development environment will be much closer to production.
- If your project has a large number of CSS files tied to smaller re-usable components, you'll probably find the reduced boilerplate of CSS bundling to be much more ergonomic. Just be aware of the trade-offs and write your CSS in a way that makes it resilient against changes to file ordering.
- If you're experiencing issues with styles disappearing during development, you should consider using a [React canary release][react-canaries] so that React doesn't remove the existing `head` element when re-mounting the page.

[css-modules]: https://vitejs.dev/guide/features#css-modules
[react-spectrum]: https://react-spectrum.adobe.com
[react-canaries]: https://react.dev/blog/2023/05/03/react-canaries
[react-versions]: https://www.npmjs.com/package/react?activeTab=versions
[package-overrides]: https://docs.npmjs.com/cli/v10/configuring-npm/package-json#overrides
[vite-url-imports]: https://vitejs.dev/guide/assets#explicit-url-imports
[links-export]: ../route/links
[css-bundling]: #css-bundling
[css-url-imports]: #css-url-imports

---

## File: ./guides/data-loading.md

---

title: Data Loading
description: One of the primary features of Remix is simplifying interactions with the server to get data into components. This document will help you get the most out of data loading in Remix.

---

# Data Loading

One of the primary features of Remix is simplifying interactions with the server to get data into components. When you follow these conventions, Remix can automatically:

- Server render your pages
- Be resilient to network conditions when JavaScript fails to load
- Make optimizations as the user interacts with your site to make it fast by only loading data for the changing parts of the page
- Fetch data, JavaScript modules, CSS and other assets in parallel on transitions, avoiding render+fetch waterfalls that lead to choppy UI
- Ensure the data in the UI is in sync with the data on the server by revalidating after [actions][action]
- Excellent scroll restoration on back/forward clicks (even across domains)
- Handle server-side errors with [error boundaries][error-boundary]
- Enable solid UX for "Not Found" and "Unauthorized" with [error boundaries][error-boundary]
- Help you keep the happy path of your UI happy

## Basics

Each route module can export a component and a [`loader`][loader]. [`useLoaderData`][useloaderdata] will provide the loader's data to your component:

```tsx filename=app/routes/products.tsx lines=[1-2,4-9,12]
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData } from '@remix-run/react';

export const loader = async () => {
  return json([
    { id: '1', name: 'Pants' },
    { id: '2', name: 'Jacket' },
  ]);
};

export default function Products() {
  const products = useLoaderData<typeof loader>();
  return (
    <div>
      <h1>Products</h1>
      {products.map((product) => (
        <div key={product.id}>{product.name}</div>
      ))}
    </div>
  );
}
```

The component renders on the server and in the browser. The loader _only runs on the server_. That means our hard-coded products array doesn't get included in the browser bundles, and it's safe to use server-only for APIs and SDKs for things like database, payment processing, content management systems, etc.

If your server-side modules end up in client bundles, refer to our guide on [server vs. client code execution][server-vs-client-code].

## Route Params

When you name a file with `$` like `app/routes/users.$userId.tsx` and `app/routes/users.$userId.projects.$projectId.tsx` the dynamic segments (the ones starting with `$`) will be parsed from the URL and passed to your loader on a `params` object.

```tsx filename=app/routes/users.$userId.projects.$projectId.tsx
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno

export const loader = async ({ params }: LoaderFunctionArgs) => {
  console.log(params.userId);
  console.log(params.projectId);
};
```

Given the following URLs, the params would be parsed as follows:

| URL                             | `params.userId` | `params.projectId` |
| ------------------------------- | --------------- | ------------------ |
| `/users/123/projects/abc`       | `"123"`         | `"abc"`            |
| `/users/aec34g/projects/22cba9` | `"aec34g"`      | `"22cba9"`         |

These params are most useful for looking up data:

```tsx filename=app/routes/users.$userId.projects.$projectId.tsx lines=[10-11]
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno

export const loader = async ({ params }: LoaderFunctionArgs) => {
  return json(
    await fakeDb.project.findMany({
      where: {
        userId: params.userId,
        projectId: params.projectId,
      },
    }),
  );
};
```

### Param Type Safety

Because these params come from the URL and not your source code, you can't know for sure if they will be defined. That's why the types on the param's keys are `string | undefined`. It's good practice to validate before using them, especially in TypeScript to get type safety. Using `invariant` makes it easy.

```tsx filename=app/routes/users.$userId.projects.$projectId.tsx lines=[2,7-8]
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import invariant from 'tiny-invariant';

export const loader = async ({ params }: LoaderFunctionArgs) => {
  invariant(params.userId, 'Expected params.userId');
  invariant(params.projectId, 'Expected params.projectId');

  params.projectId; // <-- TypeScript now knows this is a string
};
```

While you may be uncomfortable throwing errors like this with `invariant` when it fails, remember that in Remix you know the user will end up in the [error boundary][error-boundary] where they can recover from the problem instead of a broken UI.

## External APIs

Remix polyfills the `fetch` API on your server, so it's very easy to fetch data from existing JSON APIs. Instead of managing state, errors, race conditions, and more yourself, you can do the fetch from your loader (on the server) and let Remix handle the rest.

```tsx filename=app/routes/gists.tsx lines=[5]
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData } from '@remix-run/react';

export async function loader() {
  const res = await fetch('https://api.github.com/gists');
  return json(await res.json());
}

export default function GistsRoute() {
  const gists = useLoaderData<typeof loader>();
  return (
    <ul>
      {gists.map((gist) => (
        <li key={gist.id}>
          <a href={gist.html_url}>{gist.id}</a>
        </li>
      ))}
    </ul>
  );
}
```

This is great when you already have an API to work with and don't care or need to connect directly to your data source in your Remix app.

## Databases

Since Remix runs on your server, you can connect directly to a database in your route modules. For example, you could connect to a Postgres database with [Prisma][prisma].

```tsx filename=app/db.server.ts
import { PrismaClient } from '@prisma/client';
const db = new PrismaClient();
export { db };
```

And then your routes can import it and make queries against it:

```tsx filename=app/routes/products.$categoryId.tsx
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData } from '@remix-run/react';

import { db } from '@/db.server';

export const loader = async ({ params }: LoaderFunctionArgs) => {
  return json(
    await db.product.findMany({
      where: {
        categoryId: params.categoryId,
      },
    }),
  );
};

export default function ProductCategory() {
  const products = useLoaderData<typeof loader>();
  return (
    <div>
      <p>{products.length} Products</p>
      {/* ... */}
    </div>
  );
}
```

If you are using TypeScript, you can use type inference to use Prisma Client generated types when calling `useLoaderData`. This allows better type safety and intellisense when writing code that uses the loaded data.

```tsx filename=app/routes/products.$productId.tsx
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData } from '@remix-run/react';

import { db } from '@/db.server';

async function getLoaderData(productId: string) {
  const product = await db.product.findUnique({
    where: {
      id: productId,
    },
    select: {
      id: true,
      name: true,
      imgSrc: true,
    },
  });

  return product;
}

export const loader = async ({ params }: LoaderFunctionArgs) => {
  return json(await getLoaderData(params.productId));
};

export default function Product() {
  const product = useLoaderData<typeof loader>();
  return (
    <div>
      <p>Product {product.id}</p>
      {/* ... */}
    </div>
  );
}
```

## Cloudflare KV

If you picked Cloudflare Pages or Workers as your environment, [Cloudflare Key Value][cloudflare-kv] storage allows you to persist data at the edge as if it were a static resource.

For Pages, to start with local development, you need to add a `--kv` parameter with a name of your namespace to the package.json task, so it would look like this:

```
"dev:wrangler": "cross-env NODE_ENV=development wrangler pages dev ./public --kv PRODUCTS_KV"
```

For the Cloudflare Workers environment you'll need to [do some other configuration][cloudflare-kv-setup].

This enables you to use the `PRODUCTS_KV` in a loader context (KV stores are added to loader context automatically by the Cloudflare Pages adapter):

```tsx
import type { LoaderFunctionArgs } from '@remix-run/cloudflare';
import { json } from '@remix-run/cloudflare';
import { useLoaderData } from '@remix-run/react';

export const loader = async ({ context, params }: LoaderFunctionArgs) => {
  return json(await context.PRODUCTS_KV.get(`product-${params.productId}`, { type: 'json' }));
};

export default function Product() {
  const product = useLoaderData<typeof loader>();
  return (
    <div>
      <p>Product</p>
      {product.name}
    </div>
  );
}
```

## Not Found

While loading data it's common for a record to be "not found". As soon as you know you can't render the component as expected, `throw` a response and Remix will stop executing code in the current loader and switch over to the nearest [error boundary][error-boundary].

```tsx lines=[10-13]
export const loader = async ({ params, request }: LoaderFunctionArgs) => {
  const product = await db.product.findOne({
    where: { id: params.productId },
  });

  if (!product) {
    // we know we can't render the component
    // so throw immediately to stop executing code
    // and show the not found page
    throw new Response('Not Found', { status: 404 });
  }

  const cart = await getCart(request);
  return json({
    product,
    inCart: cart.includes(product.id),
  });
};
```

## URL Search Params

URL Search Params are the portion of the URL after a `?`. Other names for this are "query string", "search string", or "location search". You can access the values by creating a URL out of the `request.url`:

```tsx filename=app/routes/products.tsx lines=[7-8]
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const term = url.searchParams.get('term');
  return json(await fakeProductSearch(term));
};
```

There are a few web platform types at play here:

- The [`request`][request] object has a `url` property
- [URL constructor][url] that parses the URL string into an object
- `url.searchParams` is an instance of [URLSearchParams][url-search-params], which is a parsed version of the location search string that makes it easy to read and manipulate the search string

Given the following URLs, the search params would be parsed as follows:

| URL                             | `url.searchParams.get("term")` |
| ------------------------------- | ------------------------------ |
| `/products?term=stretchy+pants` | `"stretchy pants"`             |
| `/products?term=`               | `""`                           |
| `/products`                     | `null`                         |

### Data Reloads

When multiple nested routes are rendering and the search params change, all the routes will be reloaded (instead of just the new or changed routes). This is because search params are a cross-cutting concern and could affect any loader. If you would like to prevent some of your routes from reloading in this scenario, use [shouldRevalidate][should-revalidate].

### Search Params in Components

Sometimes you need to read and change the search params from your component instead of your loaders and actions. There are handful of ways to do this depending on your use case.

**Setting Search Params**

Perhaps the most common way to set search params is letting the user control them with a form:

```tsx filename=app/routes/products.shoes.tsx lines=[8,9,16,17]
export default function ProductFilters() {
  return (
    <Form method="get">
      <label htmlFor="nike">Nike</label>
      <input type="checkbox" id="nike" name="brand" value="nike" />

      <label htmlFor="adidas">Adidas</label>
      <input type="checkbox" id="adidas" name="brand" value="adidas" />

      <button type="submit">Update</button>
    </Form>
  );
}
```

If the user only has one selected:

- [x] Nike
- [ ] Adidas

Then the URL will be `/products/shoes?brand=nike`

If the user has both selected:

- [x] Nike
- [x] Adidas

Then the url will be: `/products/shoes?brand=nike&brand=adidas`

Note that `brand` is repeated in the URL search string since both checkboxes were named `"brand"`. In your loader you can get access to all of those values with [`searchParams.getAll`][search-params-getall]

```tsx lines=[8]
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno

export async function loader({ request }: LoaderFunctionArgs) {
  const url = new URL(request.url);
  const brands = url.searchParams.getAll('brand');
  return json(await getProducts({ brands }));
}
```

**Linking to Search Params**

As the developer, you can control the search params by linking to URLs with search strings in them. The link will replace the current search string in the URL (if there is one) with what is in the link:

```tsx
<Link to="?brand=nike">Nike (only)</Link>
```

**Reading Search Params in Components**

In addition to reading search params in loaders, you often need access to them in components, too:

```tsx lines=[1,4-5,15,24]
import { useSearchParams } from '@remix-run/react';

export default function ProductFilters() {
  const [searchParams] = useSearchParams();
  const brands = searchParams.getAll('brand');

  return (
    <Form method="get">
      <label htmlFor="nike">Nike</label>
      <input
        type="checkbox"
        id="nike"
        name="brand"
        value="nike"
        defaultChecked={brands.includes('nike')}
      />

      <label htmlFor="adidas">Adidas</label>
      <input
        type="checkbox"
        id="adidas"
        name="brand"
        value="adidas"
        defaultChecked={brands.includes('adidas')}
      />

      <button type="submit">Update</button>
    </Form>
  );
}
```

You might want to auto submit the form on any field change, for that there is [`useSubmit`][use-submit]:

```tsx lines=[2,7,14]
import { useSubmit, useSearchParams } from '@remix-run/react';

export default function ProductFilters() {
  const submit = useSubmit();
  const [searchParams] = useSearchParams();
  const brands = searchParams.getAll('brand');

  return (
    <Form method="get" onChange={(e) => submit(e.currentTarget)}>
      {/* ... */}
    </Form>
  );
}
```

**Setting Search Params Imperatively**

While uncommon, you can also set searchParams imperatively at any time for any reason. The use cases here are slim, so slim we couldn't even come up with a good one, but here's a silly example:

```tsx
import { useSearchParams } from '@remix-run/react';

export default function ProductFilters() {
  const [searchParams, setSearchParams] = useSearchParams();

  useEffect(() => {
    const id = setInterval(() => {
      setSearchParams({ now: Date.now() });
    }, 1000);
    return () => clearInterval(id);
  }, [setSearchParams]);

  // ...
}
```

### Search Params and Controlled Inputs

Often you want to keep some inputs, like checkboxes, in sync with the search params in the URL. This can get a little tricky with React's controlled component concept.

This is only needed if the search params can be set in two ways, and we want the inputs to stay in sync with the search params. For example, both the `<input type="checkbox">` and the `Link` can change the brand in this component:

```tsx bad lines=[11-18]
import { useSearchParams } from '@remix-run/react';

export default function ProductFilters() {
  const [searchParams] = useSearchParams();
  const brands = searchParams.getAll('brand');

  return (
    <Form method="get">
      <p>
        <label htmlFor="nike">Nike</label>
        <input
          type="checkbox"
          id="nike"
          name="brand"
          value="nike"
          defaultChecked={brands.includes('nike')}
        />
        <Link to="?brand=nike">(only)</Link>
      </p>

      <button type="submit">Update</button>
    </Form>
  );
}
```

If the user clicks the checkbox and submits the form, the URL updates and the checkbox state changes too. But if the user clicks the link _only the url will update and not the checkbox_. That's not what we want. You may be familiar with React's controlled components here and think to switch it to `checked` instead of `defaultChecked`:

```tsx bad lines=[6]
<input
  type="checkbox"
  id="adidas"
  name="brand"
  value="adidas"
  checked={brands.includes('adidas')}
/>
```

Now we have the opposite problem: clicking the link updates both the URL and the checkbox state but _the checkbox no longer works_ because React prevents the state from changing until the URL that controls it changes--and it never will because we can't change the checkbox and resubmit the form.

React wants you to control it with some state, but we want the user to control it until they submit the form, and then we want the URL to control it when it changes. So we're in this "sorta-controlled" spot.

You have two choices, and what you pick depends on the user experience you want.

**First Choice**: The simplest thing is to auto-submit the form when the user clicks the checkbox:

```tsx lines=[2,7,20]
import { useSubmit, useSearchParams } from '@remix-run/react';

export default function ProductFilters() {
  const submit = useSubmit();
  const [searchParams] = useSearchParams();
  const brands = searchParams.getAll('brand');

  return (
    <Form method="get">
      <p>
        <label htmlFor="nike">Nike</label>
        <input
          type="checkbox"
          id="nike"
          name="brand"
          value="nike"
          onChange={(e) => submit(e.currentTarget.form)}
          checked={brands.includes('nike')}
        />
        <Link to="?brand=nike">(only)</Link>
      </p>

      {/* ... */}
    </Form>
  );
}
```

(If you are also auto submitting on the form `onChange`, make sure to `e.stopPropagation()` so the event doesn't bubble up to the form, otherwise you'll get double submissions on every click of the checkbox.)

**Second Choice**: If you want the input to be "semi controlled", where the checkbox reflects the URL state, but the user can also toggle it on and off before submitting the form and changing the URL, you'll need to wire up some state. It's a bit of work but straightforward:

- Initialize some state from the search params
- Update the state when the user clicks the checkbox so the box changes to "checked"
- Update the state when the search params change (the user submitted the form or clicked the link) to reflect what's in the url search params

```tsx lines=[11-14,16-20,31-35]
import { useSubmit, useSearchParams } from '@remix-run/react';

export default function ProductFilters() {
  const submit = useSubmit();
  const [searchParams] = useSearchParams();
  const brands = searchParams.getAll('brand');

  const [nikeChecked, setNikeChecked] = React.useState(
    // initialize from the URL
    brands.includes('nike'),
  );

  // Update the state when the params change
  // (form submission or link click)
  React.useEffect(() => {
    setNikeChecked(brands.includes('nike'));
  }, [brands, searchParams]);

  return (
    <Form method="get">
      <p>
        <label htmlFor="nike">Nike</label>
        <input
          type="checkbox"
          id="nike"
          name="brand"
          value="nike"
          onChange={(e) => {
            // update checkbox state w/o submitting the form
            setNikeChecked(true);
          }}
          checked={nikeChecked}
        />
        <Link to="?brand=nike">(only)</Link>
      </p>

      {/* ... */}
    </Form>
  );
}
```

You might want to make an abstraction for checkboxes like this:

```tsx
<div>
  <SearchCheckbox name="brand" value="nike" />
  <SearchCheckbox name="brand" value="reebok" />
  <SearchCheckbox name="brand" value="adidas" />
</div>;

function SearchCheckbox({ name, value }) {
  const [searchParams] = useSearchParams();
  const paramsIncludeValue = searchParams.getAll(name).includes(value);
  const [checked, setChecked] = React.useState(paramsIncludeValue);

  React.useEffect(() => {
    setChecked(paramsIncludeValue);
  }, [paramsIncludeValue]);

  return (
    <input
      type="checkbox"
      name={name}
      value={value}
      checked={checked}
      onChange={(e) => setChecked(e.target.checked)}
    />
  );
}
```

**Option 3**: We said there were only two options, but there is a third unholy option that might tempt you if you know React pretty well. You might want to blow away the input and remount it with `key` prop shenanigans. While clever, this will cause accessibility issues as the user will lose focus when React removes the node from the document after they click it.

<docs-error>Don't do this, it will cause accessibility issues</docs-error>

```tsx bad lines=[6,7]
<input
  type="checkbox"
  id="adidas"
  name="brand"
  value="adidas"
  key={'adidas' + brands.includes('adidas')}
  defaultChecked={brands.includes('adidas')}
/>
```

## Remix Optimizations

Remix optimizes the user experiences by only loading the data for the parts of the page that are changing on navigation. For example, consider the UI you're using right now in these docs. The navbar on the side is in a parent route that fetched the dynamically-generated menu of all the docs, and the child route fetched the document you're reading right now. If you click a link in the sidebar, Remix knows that the parent route will remain on the page - but the child route's data will change because the url param for the document will change. With this insight, Remix _will not refetch the parent route's data_.

Without Remix the next question is "how do I reload all the data?". This is built into Remix as well. Whenever an [action][action] is called (the user submitted a form or you, the programmer, called `submit` from `useSubmit`), Remix will automatically reload all the routes on the page to capture any changes that might have happened.

You don't have to worry about expiring caches or avoid over-fetching data as the user interacts with your app, it's all automatic.

There are three cases where Remix will reload all of your routes:

- After an action (forms, `useSubmit`, [`fetcher.submit`][fetcher-submit])
- If the url search params change (any loader could use them)
- The user clicks a link to the exact same URL they are already at (this will also replace the current entry in the history stack)

All of these behaviors emulate the browser's default behavior. In these cases, Remix doesn't know enough about your code to optimize the data loading, but you can optimize it yourself with [shouldRevalidate][should-revalidate].

## Data Libraries

Thanks to Remix's data conventions and nested routes, you'll usually find you don't need to reach for client side data libraries like React Query, SWR, Apollo, Relay, `urql` and others. If you're using global state management libraries like redux, primarily for interacting with data on the server, it's also unlikely you'll need those.

Of course, Remix doesn't prevent you from using them (unless they require bundler integration). You can bring whatever React data libraries you like and use them wherever you think they'll serve your UI better than the Remix APIs. In some cases you can use Remix for the initial server render and then switch over to your favorite library for the interactions afterward.

That said, if you bring an external data library and sidestep Remix's own data conventions, Remix can no longer automatically

- Server render your pages
- Be resilient to network conditions when JavaScript fails to load
- Make optimizations as the user interacts with your site to make it fast by only loading data for the changing parts of the page
- Fetch data, JavaScript modules, CSS and other assets in parallel on transitions, avoiding render+fetch waterfalls that lead to choppy UI
- Ensure the data in the UI is in sync with the data on the server by revalidating after actions
- Excellent scroll restoration on back/forward clicks (even across domains)
- Handle server-side errors with [error boundaries][error-boundary]
- Enable solid UX for "Not Found" and "Unauthorized" with [error boundaries][error-boundary]
- Help you keep the happy path of your UI happy.

Instead you'll need to do extra work to provide a good user experience.

Remix is designed to meet any user experience you can design. While it's unexpected that you _need_ an external data library, you might still _want_ one and that's fine!

As you learn Remix, you'll find you shift from thinking in client state to thinking in URLs, and you'll get a bunch of stuff for free when you do.

## Gotchas

Loaders are only called on the server, via `fetch` from the browser, so your data is serialized with `JSON.stringify` and sent over the network before it makes it to your component. This means your data needs to be serializable. For example:

<docs-error>This won't work!</docs-error>

```tsx bad nocopy lines=[3-6]
export async function loader() {
  return {
    date: new Date(),
    someMethod() {
      return 'hello!';
    },
  };
}

export default function RouteComp() {
  const data = useLoaderData<typeof loader>();
  console.log(data);
  // '{"date":"2021-11-27T23:54:26.384Z"}'
}
```

Not everything makes it! Loaders are for _data_, and data needs to be serializable.

Some databases (like [FaunaDB][fauna]) return objects with methods that you'll want to be careful to serialize before returning from your loader. Usually this isn't a problem, but it's good to understand that your data is traveling over the network.

Additionally, Remix will call your loaders for you, in no case should you ever try to call your loader directly:

<docs-error>This will not work</docs-error>

```tsx bad nocopy
export const loader = async () => {
  return json(await fakeDb.products.findMany());
};

export default function RouteComp() {
  const data = loader();
  // ...
}
```

[action]: ../route/action
[cloudflare-kv-setup]: https://developers.cloudflare.com/workers/cli-wrangler/commands#kv
[cloudflare-kv]: https://developers.cloudflare.com/workers/learning/how-kv-works
[error-boundary]: ../route/error-boundary
[fauna]: https://fauna.com
[fetcher-submit]: ../hooks/use-fetcher#fetchersubmit
[loader]: ../route/loader
[prisma]: https://prisma.io
[request]: https://developer.mozilla.org/en-US/docs/Web/API/Request
[search-params-getall]: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/getAll
[should-revalidate]: ../route/should-revalidate
[url-search-params]: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams
[url]: https://developer.mozilla.org/en-US/docs/Web/API/URL
[use-submit]: ../hooks/use-submit
[useloaderdata]: ../hooks/use-loader-data
[server-vs-client-code]: ../discussion/server-vs-client

---

## File: ./guides/data-writes.md

---

## title: Data Writes

# Data Writes

Data writes (some people call these mutations) in Remix are built on top of two fundamental web APIs: `<form>` and HTTP. We then use progressive enhancement to enable optimistic UI, loading indicators, and validation feedback--but the programming model is still built on HTML forms.

When the user submits a form, Remix will:

1. Call the action for the form
2. Reload all the data for all the routes on the page

Many times people reach for global state management libraries in React like redux, data libs like apollo, and fetch wrappers like React Query in order to help manage getting server state into your components and keeping the UI in sync with it when the user changes it. Remix's HTML based API replaces the majority of use cases for these tools. Remix knows how to load the data as well as how to revalidate it after it changes when you use standard HTML APIs.

There are a few ways to call an action and get the routes to revalidate:

- [`<Form>`][form]
- [`useSubmit()`][use-submit]
- [`useFetcher()`][use-fetcher]

This guide only covers `<Form>`. We suggest you read the docs for the other two after this guide to get a sense of how to use them. Most of this guide applies to `useSubmit` but `useFetcher` is a bit different.

## Plain HTML Forms

After teaching workshops with our company <a href="https://reacttraining.com">React Training</a> for years, we've learned that a lot of newer web developers (though no fault of their own) don't actually know how `<form>` works!

Since Remix `<Form>` works identically to `<form>` (with a couple of extra goodies for optimistic UI etc.), we're going to brush up on plain ol' HTML forms, so you can learn both HTML and Remix at the same time.

### HTML Form HTTP Verbs

Native forms support two HTTP verbs: `GET` and `POST`. Remix uses these verbs to understand your intent. If it's a GET, Remix will figure out what parts of the page are changing and only fetch the data for the changing layouts, and use the cached data for the layouts that don't change. When it's a POST, Remix will reload all data to ensure it captures the update from the server. Let's take a look at both.

### HTML Form GET

A `GET` is just a normal navigation where the form data is passed in the URL search params. You use it for normal navigation, just like `<a>` except the user gets to provide the data in the search params through the form. Aside from search pages, its use with `<form>` is pretty rare.

Consider this form:

```html
<form method="get" action="/search">
  <label>Search <input name="term" type="text" /></label>
  <button type="submit">Search</button>
</form>
```

When the user fills it out and clicks submit, the browser automatically serializes the form values into a URL search param string and navigates to the form's `action` with the query string appended. Let's say the user typed in "remix". The browser would navigate to `/search?term=remix`. If we changed the input to `<input name="q"/>` then the form would navigate to `/search?q=remix`.

It's the same behavior as if we had created this link:

```html
<a href="/search?term=remix">Search for "remix"</a>
```

With the unique difference that the **user** got to supply the information.

If you have more fields, the browser will add them:

```html
<form method="get" action="/search">
  <fieldset>
    <legend>Brand</legend>
    <label>
      <input name="brand" value="nike" type="checkbox" />
      Nike
    </label>
    <label>
      <input name="brand" value="reebok" type="checkbox" />
      Reebok
    </label>
    <label>
      <input name="color" value="white" type="checkbox" />
      White
    </label>
    <label>
      <input name="color" value="black" type="checkbox" />
      Black
    </label>
    <button type="submit">Search</button>
  </fieldset>
</form>
```

Depending on which checkboxes the user clicks, the browser will navigate to URLs like:

```
/search?brand=nike&color=black
/search?brand=nike&brand=reebok&color=white
```

### HTML Form POST

When you want to create, delete, or update data on your website, a form post is the way to go. And we don't just mean big forms like a user profile edit page. Even "Like" buttons can be handled with a form.

Let's consider a "new project" form.

```html
<form method="post" action="/projects">
  <label><input name="name" type="text" /></label>
  <label><textarea name="description"></textarea></label>
  <button type="submit">Create</button>
</form>
```

When the user submits this form, the browser will serialize the fields into a request "body" (instead of URL search params) and "POST" it to the server. This is still a normal navigation as if the user clicked a link. The difference is two-fold: the user provided the data for the server and the browser sent the request as a "POST" instead of a "GET".

The data is made available to the server's request handler, so you can create the record. After that, you return a response. In this case, you'd probably redirect to the newly-created project. A remix action would look something like this:

```tsx filename=app/routes/projects.tsx
export async function action({ request }: ActionFunctionArgs) {
  const body = await request.formData();
  const project = await createProject(body);
  return redirect(`/projects/${project.id}`);
}
```

The browser started at `/projects/new`, then posted to `/projects` with the form data in the request, then the server redirected the browser to `/projects/123`. While this is all happening, the browser goes into its normal "loading" state: the address progress bar fills up, the favicon turns into a spinner, etc. It's actually a decent user experience.

If you're newer to web development, you may not have ever used a form this way. Lots of folks have always done:

```html
<form onSubmit="{(event)" ="">{ event.preventDefault(); // good luck! }} /></form>
```

If this is you, you're going to be delighted when you see just how easy mutations can be when you just use what browsers (and Remix) have built in!

## Remix Mutation, Start to Finish

We're going to build a mutation from start to finish with:

1. JavaScript optional
2. Validation
3. Error handling
4. Progressively-enhanced loading indicators
5. Progressively-enhanced error display

You use the Remix `<Form>` component for data mutations the same way you use HTML forms. The difference is now you get access to pending form state to build a nicer user experience: like contextual loading indicators and "optimistic UI".

Whether you use `<form>` or `<Form>` though, you write the very same code. You can start with a `<form>` and then graduate it to `<Form>` without changing anything. After that, add in the special loading indicators and optimistic UI. However, if you're not feeling up to it, or deadlines are tight, just use a `<form>` and let the browser handle the user feedback! Remix `<Form>` is the realization of "progressive enhancement" for mutations.

### Building the form

Let's start with our project form from earlier but make it usable:

Let's say you've got the route `app/routes/projects.new.tsx` with this form in it:

```tsx filename=app/routes/projects.new.tsx
export default function NewProject() {
  return (
    <form method="post" action="/projects/new">
      <p>
        <label>
          Name: <input name="name" type="text" />
        </label>
      </p>
      <p>
        <label>
          Description:
          <br />
          <textarea name="description" />
        </label>
      </p>
      <p>
        <button type="submit">Create</button>
      </p>
    </form>
  );
}
```

Now add the route action. Any form submissions that are "post" will call your data "action". Any "get" submissions (`<Form method="get">`) will be handled by your "loader".

```tsx lines=[1,5-11]
import type { ActionFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { redirect } from '@remix-run/node'; // or cloudflare/deno

// Note the "action" export name, this will handle our form POST
export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  const project = await createProject(formData);
  return redirect(`/projects/${project.id}`);
};

export default function NewProject() {
  // ... same as before
}
```

And that's it! Assuming `createProject` does what we want it to, that's all you have to do. Note that no matter what kind of SPA you may have built in the past, you always need a server-side action and a form to get data from the user. The difference with Remix is **that's all you need** (and that's how the web used to be, too.)

Of course, we started complicating things to try to create better user experiences than the default browser behavior. Keep going, we'll get there, but we won‚Äôt have to change any of the code we've already written to get the core functionality.

### Form Validation

It's common to validate forms both client-side and server-side. It's also (unfortunately) common to only validate client-side, which leads to various issues with your data that we don't have time to get into right now. Point is, if you're validating in only one place, do it on the server. You'll find with Remix that's the only place you care to anymore (the less you send to the browser the better!).

We know, we know, you want to animate in nice validation errors and stuff. We'll get to that. But right now we're just building a basic HTML form and user flow. We'll keep it simple first, then make it fancy.

Back in our action, maybe we have an API that returns validation errors like this.

```tsx
const [errors, project] = await createProject(formData);
```

If there are validation errors, we want to go back to the form and display them.

```tsx lines=[1,7,9-12]
import { json, redirect } from '@remix-run/node'; // or cloudflare/deno

export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  const [errors, project] = await createProject(formData);

  if (errors) {
    const values = Object.fromEntries(formData);
    return json({ errors, values });
  }

  return redirect(`/projects/${project.id}`);
};
```

Just like `useLoaderData` returns the values from the `loader`, `useActionData` will return the data from the action. It will only be there if the navigation was a form submission, so you always have to check if you've got it or not.

```tsx lines=[3,12,22,27-31,39,44-48]
import type { ActionFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json, redirect } from '@remix-run/node'; // or cloudflare/deno
import { useActionData } from '@remix-run/react';

export const action = async ({ request }: ActionFunctionArgs) => {
  // ...
};

export default function NewProject() {
  const actionData = useActionData<typeof action>();

  return (
    <form method="post" action="/projects/new">
      <p>
        <label>
          Name: <input name="name" type="text" defaultValue={actionData?.values.name} />
        </label>
      </p>

      {actionData?.errors.name ? <p style={{ color: 'red' }}>{actionData.errors.name}</p> : null}

      <p>
        <label>
          Description:
          <br />
          <textarea name="description" defaultValue={actionData?.values.description} />
        </label>
      </p>

      {actionData?.errors.description ? (
        <p style={{ color: 'red' }}>{actionData.errors.description}</p>
      ) : null}

      <p>
        <button type="submit">Create</button>
      </p>
    </form>
  );
}
```

Notice how we add `defaultValue` to all of our inputs. Remember, this is regular HTML `<form>`, so it's just normal browser/server stuff happening. We're getting the values back from the server so the user doesn't have to re-type what they had.

You can ship this code as-is. The browser will handle the pending UI and interruptions for you. Enjoy your weekend and make it fancy on Monday.

### Graduate to `<Form>` and add pending UI

Let's use progressive enhancement to make this UX a bit more fancy. By changing it from `<form>` to `<Form>`, Remix will emulate the browser behavior with `fetch`. It will also give you access to the pending form data, so you can build pending UI.

```tsx lines=[2,11]
import { json, redirect } from '@remix-run/node'; // or cloudflare/deno
import { useActionData, Form } from '@remix-run/react';

// ...

export default function NewProject() {
  const actionData = useActionData<typeof action>();

  return (
    // note the capital "F" <Form> now
    <Form method="post">{/* ... */}</Form>
  );
}
```

<docs-error>HOLD UP! If all you do is change your form to Form, you made the UX a little worse!</docs-error>

If you don't have the time or drive to do the rest of the job here, use `<Form reloadDocument>`. This lets the browser continue to handle the pending UI state (spinner in the favicon of the tab, progress bar in the address bar, etc.) If you simply use `<Form>` without implementing pending UI, the user will have no idea anything is happening when they submit a form.

<docs-info>We recommend always using capital-F Form, and if you want to let the browser handle the pending UI, use the <code>\<Form reloadDocument></code> prop.</docs-info>

Now let's add some pending UI so the user has a clue something happened when they submit. There's a hook called `useNavigation`. When there is a pending form submission, Remix will give you the serialized version of the form as a <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData">`FormData`</a> object. You'll be most interested in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData/get">`formData.get()`</a> method.

```tsx lines=[5,13,19,65-67]
import { json, redirect } from '@remix-run/node'; // or cloudflare/deno
import { useActionData, Form, useNavigation } from '@remix-run/react';

// ...

export default function NewProject() {
  // when the form is being processed on the server, this returns different
  // navigation states to help us build pending and optimistic UI.
  const navigation = useNavigation();
  const actionData = useActionData<typeof action>();

  return (
    <Form method="post">
      <fieldset disabled={navigation.state === 'submitting'}>
        <p>
          <label>
            Name:{' '}
            <input
              name="name"
              type="text"
              defaultValue={actionData ? actionData.values.name : undefined}
            />
          </label>
        </p>

        {actionData && actionData.errors.name ? (
          <p style={{ color: 'red' }}>{actionData.errors.name}</p>
        ) : null}

        <p>
          <label>
            Description:
            <br />
            <textarea
              name="description"
              defaultValue={actionData ? actionData.values.description : undefined}
            />
          </label>
        </p>

        {actionData && actionData.errors.description ? (
          <p style={{ color: 'red' }}>{actionData.errors.description}</p>
        ) : null}

        <p>
          <button type="submit">
            {navigation.state === 'submitting' ? 'Creating...' : 'Create'}
          </button>
        </p>
      </fieldset>
    </Form>
  );
}
```

Pretty slick! Now when the user clicks "Create", the inputs go disabled, and the submit button's text changes. The whole operation should be faster now too since there's just one network request happening instead of a full page reload (which involves potentially more network requests, reading assets from the browser cache, parsing JavaScript, parsing CSS, etc.).

We didn't do much with `navigation` on this page, but it's got all the information about the submission (`navigation.formMethod`, `navigation.formAction`, `navigation.formEncType`), as well as all the values being processed on the server on `navigation.formData`.

### Animating in the Validation Errors

Now that we're using JavaScript to submit this page, our validation errors can be animated in because the page is stateful. First we'll make a fancy component that animates height and opacity:

```tsx
function ValidationMessage({ error, isSubmitting }) {
  const [show, setShow] = useState(!!error);

  useEffect(() => {
    const id = setTimeout(() => {
      const hasError = !!error;
      setShow(hasError && !isSubmitting);
    });
    return () => clearTimeout(id);
  }, [error, isSubmitting]);

  return (
    <div
      style={{
        opacity: show ? 1 : 0,
        height: show ? '1em' : 0,
        color: 'red',
        transition: 'all 300ms ease-in-out',
      }}
    >
      {error}
    </div>
  );
}
```

Now we can wrap our old error messages in this new fancy component, and even turn the borders of our fields red that have errors:

```tsx lines=[21-24,31-34,44-48,53-56]
export default function NewProject() {
  const navigation = useNavigation();
  const actionData = useActionData<typeof action>();

  return (
    <Form method="post">
      <fieldset disabled={navigation.state === 'submitting'}>
        <p>
          <label>
            Name:{' '}
            <input
              name="name"
              type="text"
              defaultValue={actionData ? actionData.values.name : undefined}
              style={{
                borderColor: actionData?.errors.name ? 'red' : '',
              }}
            />
          </label>
        </p>

        {actionData?.errors.name ? (
          <ValidationMessage
            isSubmitting={navigation.state === 'submitting'}
            error={actionData?.errors?.name}
          />
        ) : null}

        <p>
          <label>
            Description:
            <br />
            <textarea
              name="description"
              defaultValue={actionData?.values.description}
              style={{
                borderColor: actionData?.errors.description ? 'red' : '',
              }}
            />
          </label>
        </p>

        <ValidationMessage
          isSubmitting={navigation.state === 'submitting'}
          error={actionData?.errors.description}
        />

        <p>
          <button type="submit">
            {navigation.state === 'submitting' ? 'Creating...' : 'Create'}
          </button>
        </p>
      </fieldset>
    </Form>
  );
}
```

Boom! Fancy UI without having to change anything about how we communicate with the server. It's also resilient to network conditions that prevent JS from loading.

### Review

- First we built the project form without JavaScript in mind. A simple form, posting to a server-side action. Welcome to 1998.

- Once that worked, we used JavaScript to submit the form by changing `<form>` to `<Form>`, but we didn't have to do anything else!

- Now that there was a stateful page with React, we added loading indicators and animation for the validation errors by simply asking Remix for the state of the navigation.

From your components perspective, all that happened was the `useNavigation` hook caused a state update when the form was submitted, and then another state update when the data came back. Of course, a lot more happened inside of Remix, but as far as your component is concerned, that's it. Just a couple of state updates. This makes it really easy to dress up any user flow.

## See also

- [Form][form]
- [useNavigation][use-navigation]
- [Actions][actions]
- [Loaders][loaders]
- [`useSubmit()`][use-submit]
- [`useFetcher()`][use-fetcher]

[form]: ../components/form
[use-submit]: ../hooks/use-submit
[use-fetcher]: ../hooks/use-fetcher
[use-navigation]: ../hooks/use-navigation
[actions]: ../route/action
[loaders]: ../route/loader

---

## File: ./guides/debugging.md

---

title: Debugging
hidden: true

---

TODO

---

## File: ./guides/dependency-optimization.md

---

## title: Dependency optimization

<docs-info>This feature only affects development. It does not impact production builds.</docs-info>

# Dependency optimization

Remix introduced automatic dependency optimization in development behind the `future.unstable_optimizeDeps` [Future Flag][future-flags]. This allows you to opt-into this behavior which will eventually become the default in some future version of Remix - a.k.a. React Router ([1][rr-v7], [2][rr-v7-2]). This flag is intended to remain "unstable" into React Router v7 as there is some additional bundling-related work coming that will ease adoption of the flag. We plan to stabilize the flag once that work is completed in v7.

In development, Vite aims to [prebundle dependencies][prebundle-dependencies] so that it can efficiently serve up those dependencies on-demand.
To do this, Vite needs to know where to start crawling your app's module graph to look for dependencies.

Previously, Remix did not inform Vite to start dependency detection at route modules nor at the client entry.
That meant that in development, Vite would encounter new dependencies as you navigated around in your app resulting in `504 Outdated Dependency` errors.
Consequently, the development experience could feel janky at times since those errors could cause HMR to break or link navigations to be aborted.
Navigation could also feel sluggish as processing dependencies interactively could sometimes be slow.

For more information, see [Vite's Dep Optimization Options][vite-s-dep-optimization-options].

## Troubleshooting

### `Failed to resolve entry for package`

```txt
‚úò [ERROR] Failed to resolve entry for package "<package>". The package may have incorrect main/module/exports specified in its package.json. [plugin vite:dep-pre-bundle]
```

This is usually caused by a misconfigured dependency.
You use [publint][publint] to check if the offending package is misconfigured.
To fix the issue, you'll need to use `npm why` or `pnpm why` to determine which of your direct dependencies to add to `optimizeDeps.exclude`.

For example, let's say your app is running into this error:

```txt
‚úò [ERROR] Failed to resolve entry for package "jimp". The package may have incorrect main/module/exports specified in its package.json. [plugin vite:dep-pre-bundle]
```

Sure enough, `publint` reports that the [`jimp` package is misconfigured][jimp-package-is-misconfigured].
Then, you determine that `jimp` is an indirect dependency being pulled in by your `svg2img` direct dependency:

```sh
‚ùØ npm why jimp
jimp@0.16.13
node_modules/jimp
  jimp@"^0.16.1" from svg2img@1.0.0-beta.2
  node_modules/svg2img
    svg2img@"^1.0.0-beta.2" from the root project
```

Finally, you add `svg2img` to `optimizeDeps.exclude`, which should fix the issue:

```ts filename=vite.config.ts
export default defineConfig({
  optimizeDeps: {
    exclude: ['svg2img'],
  },
});
```

[future-flags]: ../guides/api-development-strategy
[rr-v7]: https://remix.run/blog/merging-remix-and-react-router
[rr-v7-2]: https://remix.run/blog/incremental-path-to-react-19
[prebundle-dependencies]: https://vitejs.dev/guide/dep-pre-bundling.html
[vite-s-dep-optimization-options]: https://vitejs.dev/config/dep-optimization-options#dep-optimization-options
[publint]: https://publint.dev
[jimp-package-is-misconfigured]: https://publint.dev/jimp@0.22.12

---

## File: ./guides/deployment.md

---

title: Deployment
toc: false

---

# Deployment

Remix maintains a few [starter templates][starter-templates] to help you deploy to various servers right from the start. You should be able to initialize your app and get it live within a couple of minutes.

Running `npx create-remix@latest` with the `--template` flag allows you to provide the URL to one of these templates, for example:

```sh
npx create-remix@latest --template remix-run/remix/templates/express
```

Each target has unique file structures, configuration files, cli commands that need to be run, server environment variables to be set etc. Because of this, it's important to read the README.md to deploy the app. It's got all of the steps you need to take to get your app live within minutes.

<docs-info>After initializing an app, make sure to read the README.md</docs-info>

Additionally, Remix doesn't abstract over your infrastructure, so the templates don't hide anything about where you're deploying to (you may want other functions besides the Remix app!). You're welcome to tweak the configuration to suit your needs. Remix runs on your server, but it is not your server.

In a nutshell: if you want to deploy your app, Read the manual üòã

[starter-templates]: https://github.com/remix-run/remix/tree/main/templates

---

## File: ./guides/disabling-javascript.md

---

title: Disabling JavaScript
toc: false

---

# Disabling JavaScript

Do you ever look at a page on your site and think "why are we loading all of this JavaScript? There's nothing on this page but links!" This may seem a little odd for a JavaScript framework, but you can easily turn off JavaScript with a boolean and your data loading, links, and even forms will still work.

Here's how we like to do it:

Open up each route module you want to include JavaScript for and add a "handle". This is a way for you to provide any kind of meta information about a route to the parent route (as you'll see in a moment).

```tsx
export const handle = { hydrate: true };
```

Now open `root.tsx`, bring in `useMatches` and add this:

```tsx filename=app/root.tsx lines=[6,10,13-15,27]
import { Meta, Links, Scripts, Outlet, useMatches } from '@remix-run/react';

export default function App() {
  const matches = useMatches();

  // If at least one route wants to hydrate, this will return true
  const includeScripts = matches.some((match) => match.handle?.hydrate);

  // then use the flag to render scripts or not
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <Outlet />
        {/* include the scripts, or not! */}
        {includeScripts ? <Scripts /> : null}
      </body>
    </html>
  );
}
```

All of your data loading will still work on the server render, and all of your `<Link>`s render normal `<a>` underneath, so they will continue to work.

On any page, at anytime, you can flip between plain HTML and full client-side transitions.

If you need one tiny bit of interactivity, use a `<script dangerouslySetInnerHTML>`.

```tsx
return (
  <>
    <select id="qty">
      <option>1</option>
      <option>2</option>
      <option value="contact">Contact Sales for more</option>
    </select>

    <script
      dangerouslySetInnerHTML={{
        __html: `
          document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('qty').onchange = (event) => {
              if (event.target.value === "contact") {
                window.location.assign("/contact")
              }
            }
          });
        `,
      }}
    />
  </>
);
```

---

## File: ./guides/envvars.md

---

## title: Environment Variables

# Environment Variables

Remix does not do anything directly with environment variables (except during local development), but there are some patterns we find useful that we'll share in this guide.

Environment Variables are values that live on the server that your application can use. You may be familiar with the ubiquitous `NODE_ENV`. Your deployment server probably automatically sets that to "production".

<docs-warning>Running `remix build` compiles using the value of `process.env.NODE_ENV` if it corresponds with a valid mode: "production", "development" or "test". If the value of `process.env.NODE_ENV` is invalid, "production" is used as a default.</docs-warning>

Here are some example environment variables you might find in the wild:

- `DATABASE_URL`: The URL for a Postgres Database
- `STRIPE_PRIVATE_KEY`: The key a checkout workflow will use on the server
- `STRIPE_PUBLIC_KEY`: The key a checkout workflow will use on the browser

If your experience with web development is primarily with the JS frameworks in the last few years, you might think of these as something for your build to use. While they can be useful for bundling code, traditionally those are "build arguments" not environment variables. Environment variables are most useful _at runtime on the server_. For example, you can change an environment variable to change the behavior of your app without rebuilding or even redeploying.

## Server Environment Variables

### Local Development

If you're using the `remix dev` server to run your project locally, it has built-in support for [dotenv][dotenv].

First, create an `.env` file in the root of your project:

```sh
touch .env
```

<docs-error>Do not commit your <code>.env</code> file to git, the point is that it contains secrets!</docs-error>

Edit your `.env` file.

```
SOME_SECRET=super-secret
```

Then, when running `remix dev` you will be able to access those values in your loaders/actions:

```tsx
export async function loader() {
  console.log(process.env.SOME_SECRET);
}
```

If you're using the `@remix-run/cloudflare-pages` or `@remix-run/cloudflare` adapters, env variables work a little differently. You'll need to define your local environment variables in the [`.dev.vars`][dev-vars] file. It has the same syntax as `.env` example file mentioned above.

Then, they'll be available via Remix's `context.cloudflare.env` in your `loader`/`action` functions:

```tsx
export const loader = async ({ context }: LoaderFunctionArgs) => {
  console.log(context.cloudflare.env.SOME_SECRET);
};
```

Note that `.env` and `.dev.vars` files are only for development. You should not use them in production, so Remix doesn't load them when running `remix serve`. You'll need to follow your host's guides on adding secrets to your production server, via the links below.

### Production

Environment variables when deployed to production will be handled by your host, for example:

- [Netlify][netlify]
- [Fly.io][fly-io]
- [Cloudflare Pages][cloudflare-pages]
- [Cloudflare Workers][cloudflare-workers]
- [Vercel][vercel]
- [Architect][architect]

## Browser Environment Variables

Some folks ask if Remix can let them put environment variables into browser bundles. It's a common strategy in build-heavy frameworks. However, this approach is a problem for a few reasons:

1. It's not really an environment variable. You have to know which server you're deploying to at build time.
2. You can't change the values without a rebuild and redeploy.
3. It's easy to accidentally leak secrets into publicly accessible files!

Instead we recommend keeping all of your environment variables on the server (all the server secrets as well as the stuff your JavaScript in the browser needs) and exposing them to your browser code through `window.ENV`. Since you always have a server, you don't need this information in your bundle, your server can provide the client-side environment variables in the loaders.

1. **Return `ENV` for the client from the root loader** - Inside your loader you can access your server's environment variables. Loaders only run on the server and are never bundled into your client-side JavaScript.

   ```tsx lines=[3-6]
   export async function loader() {
     return json({
       ENV: {
         STRIPE_PUBLIC_KEY: process.env.STRIPE_PUBLIC_KEY,
         FAUNA_DB_URL: process.env.FAUNA_DB_URL,
       },
     });
   }

   export function Root() {
     return (
       <html lang="en">
         <head>
           <Meta />
           <Links />
         </head>
         <body>
           <Outlet />
           <Scripts />
         </body>
       </html>
     );
   }
   ```

2. **Put `ENV` on window** - This is how we hand off the values from the server to the client. Make sure to put this before `<Scripts/>`

   ```tsx lines=[10,19-25]
   export async function loader() {
     return json({
       ENV: {
         STRIPE_PUBLIC_KEY: process.env.STRIPE_PUBLIC_KEY,
       },
     });
   }

   export function Root() {
     const data = useLoaderData<typeof loader>();
     return (
       <html lang="en">
         <head>
           <Meta />
           <Links />
         </head>
         <body>
           <Outlet />
           <script
             dangerouslySetInnerHTML={{
               __html: `window.ENV = ${JSON.stringify(data.ENV)}`,
             }}
           />
           <Scripts />
         </body>
       </html>
     );
   }
   ```

3. **Access the values**

   ```tsx lines=[6-8]
   import { loadStripe } from '@stripe/stripe-js';

   export async function redirectToStripeCheckout(sessionId) {
     const stripe = await loadStripe(window.ENV.STRIPE_PUBLIC_KEY);
     return stripe.redirectToCheckout({ sessionId });
   }
   ```

[dotenv]: https://www.npmjs.com/package/dotenv
[netlify]: https://docs.netlify.com/configure-builds/environment-variables
[fly-io]: https://fly.io/docs/reference/secrets
[cloudflare-pages]: https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables
[cloudflare-workers]: https://developers.cloudflare.com/workers/platform/environment-variables
[vercel]: https://vercel.com/docs/environment-variables
[architect]: https://arc.codes/docs/en/reference/cli/env
[dev-vars]: https://developers.cloudflare.com/pages/functions/bindings/#interact-with-your-environment-variables-locally

---

## File: ./guides/errors.md

---

## title: Error Handling

# Error Handling

Remix sets a new precedent in web application error handling that you are going to love. Remix automatically catches most errors in your code, on the server or in the browser, and renders the closest [`ErrorBoundary`][error-boundary] to where the error occurred. If you're familiar with React's [`componentDidCatch`][component-did-catch] and [`getDerivedStateFromError`][get-derived-state-from-error] class component hooks, it's just like that but with some extra handling for errors on the server.

Remix will automatically catch errors and render the nearest error boundary for errors thrown while:

- rendering in the browser
- rendering on the server
- in a `loader` during the initial server-rendered document request
- in an `action` during the initial server-rendered document request
- in a `loader` during a client-side transition in the browser (Remix serializes the error and sends it over the network to the browser)
- in an `action` during a client-side transition in the browser

## Root Error Boundary

By default, Remix ships with a default `ErrorBoundary` built-in, but we hope you'll want to add a little branding to your own global error boundary. You can do so by exporting your own [`ErrorBoundary`][error-boundary] from `app/root.tsx`. This is what your users will see whenever an uncaught error is thrown.

```tsx
export function ErrorBoundary() {
  const error = useRouteError();
  console.error(error);
  return (
    <html>
      <head>
        <title>Oh no!</title>
        <Meta />
        <Links />
      </head>
      <body>
        {/* add the UI you want your users to see */}
        <Scripts />
      </body>
    </html>
  );
}
```

You'll want to make sure to still render the [`Links`][links-component], [`Meta`][meta-component], and [`Scripts`][scripts-component] components because the whole document will mount and unmount when the root error boundary is rendered.

## Nested Error Boundaries

Each route in the hierarchy is a potential error boundary. If a nested route exports an error boundary, then any errors below it will be caught and rendered there. This means that the rest of the surrounding UI in the parent routes _continue to render normally_ so the user is able to click another link and not lose any client-side state they might have had.

For example, consider these routes:

```text
app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ sales.tsx
‚îÇ   ‚îú‚îÄ‚îÄ sales.invoices.tsx
‚îÇ   ‚îî‚îÄ‚îÄ sales.invoices.$invoiceId.tsx
‚îî‚îÄ‚îÄ root.tsx
```

If `app/routes/sales.invoices.$invoiceId.tsx` exports an [`ErrorBoundary`][error-boundary] and an error is thrown in its component, [`action`][action], or [`loader`][loader], the rest of the app renders normally and only the invoice section of the page renders the error.

![error in a nested route where the parent route's navigation renders normally][error-in-a-nested-route-where-the-parent-route-s-navigation-renders-normally]

If a route doesn't have an error boundary, the error "bubbles up" to the closest error boundary, all the way to the root, so you don't have to add error boundaries to every route--only when you want to add that extra touch to your UI.

## Error Sanitization

In production mode, any errors that happen on the server are automatically sanitized to prevent leaking any sensitive server information (such as stack traces) to the client. This means that the `Error` instance you receive from [`useRouteError`][use-route-error] will have a generic message and no stack trace:

```tsx
export async function loader() {
  if (badConditionIsTrue()) {
    throw new Error('Oh no! Something went wrong!');
  }
}

export function ErrorBoundary() {
  const error = useRouteError();
  // When NODE_ENV=production:
  // error.message = "Unexpected Server Error"
  // error.stack = undefined
}
```

If you need to log these errors or report them to a third-party service such as [BugSnag][bugsnag] or [Sentry][sentry], then you can do this through a [`handleError`][handle-error] export in your [`app/entry.server.js`][entry-server]. This method receives the un-sanitized versions of the error since it is also running on the server.

If you want to trigger an error boundary and display a specific message or data in the browser, then you can throw a `Response` from a `action`/`loader` with that data instead:

```tsx
export async function loader() {
  if (badConditionIsTrue()) {
    throw new Response('Oh no! Something went wrong!', {
      status: 500,
    });
  }
}

export function ErrorBoundary() {
  const error = useRouteError();
  if (isRouteErrorResponse(error)) {
    // error.status = 500
    // error.data = "Oh no! Something went wrong!"
  }
}
```

[component-did-catch]: https://react.dev/reference/react/Component#componentdidcatch
[get-derived-state-from-error]: https://react.dev/reference/react/Component#static-getderivedstatefromerror
[error-boundary]: ../route/error-boundary
[links-component]: ../components/links
[meta-component]: ../components/meta
[scripts-component]: ../components/scripts
[error-in-a-nested-route-where-the-parent-route-s-navigation-renders-normally]: /docs-images/error-boundary.png
[action]: ../route/action
[loader]: ../route/loader
[use-route-error]: ../hooks/use-route-error
[bugsnag]: https://www.bugsnag.com/
[sentry]: https://sentry.io/
[handle-error]: ../file-conventions/entry.server#handleerror
[entry-server]: ../file-conventions/entry.server

---

## File: ./guides/faq.md

---

title: FAQs
description: Frequently Asked Questions about Remix

---

# Frequently Asked Questions

## How can I have a parent route loader validate the user and protect all child routes?

You can't üòÖ. During a client-side transition, to make your app as speedy as possible, Remix will call all of your loaders _in parallel_, in separate fetch requests. Each one of them needs to have its own authentication check.

This is probably not different from what you were doing before Remix, it might just be more obvious now. Outside of Remix, when you make multiple fetches to your "API Routes", each of those endpoints needs to validate the user session. In other words, Remix route loaders are their own "API Route" and must be treated as such.

We recommend you create a function that validates the user session that can be added to any routes that require it.

```ts filename=app/session.ts lines=[9-22]
import { createCookieSessionStorage, redirect } from '@remix-run/node'; // or cloudflare/deno

// somewhere you've got a session storage
const { getSession } = createCookieSessionStorage();

export async function requireUserSession(request) {
  // get the session
  const cookie = request.headers.get('cookie');
  const session = await getSession(cookie);

  // validate the session, `userId` is just an example, use whatever value you
  // put in the session when the user authenticated
  if (!session.has('userId')) {
    // if there is no user session, redirect to login
    throw redirect('/login');
  }

  return session;
}
```

And now in any loader or action that requires a user session, you can call the function.

```tsx filename=app/routes/projects.tsx lines=[5]
export async function loader({ request }: LoaderFunctionArgs) {
  // if the user isn't authenticated, this will redirect to login
  const session = await requireUserSession(request);

  // otherwise the code continues to execute
  const projects = await fakeDb.projects.scan({
    userId: session.get('userId'),
  });
  return json(projects);
}
```

Even if you don't need the session information, the function will still protect the route:

```tsx
export async function loader({ request }: LoaderFunctionArgs) {
  await requireUserSession(request);
  // continue
}
```

## How do I handle multiple forms in one route?

[Watch on YouTube][watch_on_youtube]

In HTML, forms can post to any URL with the action prop and the app will navigate there:

```tsx
<Form action="/some/where" />
```

In Remix the action defaults to the route that the form is rendered in, making it easy to co-locate the UI and the server code that handles it. Developers often wonder how you can handle multiple actions in this scenario. You have two choices:

1. Send a form field to determine the action you want to take
2. Post to a different route and redirect back to the original

We find option (1) to be the simplest because you don't have to mess around with sessions to get validation errors back to the UI.

HTML buttons can send a value, so it's the easiest way to implement this:

```tsx filename=app/routes/projects.$id.tsx lines=[5-6,35,41]
export async function action({ request }: ActionFunctionArgs) {
  const formData = await request.formData();
  const intent = formData.get('intent');
  switch (intent) {
    case 'update': {
      // do your update
      return updateProjectName(formData.get('name'));
    }
    case 'delete': {
      // do your delete
      return deleteStuff(formData);
    }
    default: {
      throw new Error('Unexpected action');
    }
  }
}

export default function Projects() {
  const project = useLoaderData<typeof loader>();
  return (
    <>
      <h2>Update Project</h2>
      <Form method="post">
        <label>
          Project name: <input type="text" name="name" defaultValue={project.name} />
        </label>
        <button type="submit" name="intent" value="update">
          Update
        </button>
      </Form>

      <Form method="post">
        <button type="submit" name="intent" value="delete">
          Delete
        </button>
      </Form>
    </>
  );
}
```

<docs-warning>Older browser versions might break this functionality because they might not support the [SubmitEvent: submitter property][submitevent-submitter] or the [FormData() constructor submitter parameter][formdata-submitter]. Be sure to check the browser compatibility for these features. If you need to polyfill this, please refer to the [Event Submitter Polyfill][polyfill-event-submitter] and the [FormData Submitter Polyfill][polyfill-formdata-submitter]. For more details, see the related issue [remix-run/remix#9704][remix-submitter-issue].</docs-warning>

## How can I have structured data in a form?

If you're used to doing fetches with a content type of `application/json`, you may wonder how forms fit into this. [`FormData`][form_data] is a bit different from JSON.

- It can't have nested data, it's just "key value".
- It _can_ have multiple entries on one key, unlike JSON.

If you're wanting to send structured data simply to post arrays, you can use the same key on multiple inputs:

```tsx
<Form method="post">
  <p>Select the categories for this video:</p>
  <label>
    <input type="checkbox" name="category" value="comedy" /> Comedy
  </label>
  <label>
    <input type="checkbox" name="category" value="music" /> Music
  </label>
  <label>
    <input type="checkbox" name="category" value="howto" /> How-To
  </label>
</Form>
```

Each checkbox has the name: "category". Since `FormData` can have multiple values on the same key, you don't need JSON for this. Access the checkbox values with `formData.getAll()` in your action.

```tsx
export async function action({ request }: ActionFunctionArgs) {
  const formData = await request.formData();
  const categories = formData.getAll('category');
  // ["comedy", "music"]
}
```

Using the same input name and `formData.getAll()` covers most cases for wanting to submit structured data in your forms.

If you still want to submit nested structures as well, you can use non-standard form-field naming conventions and the [`query-string`][query_string] package from npm:

```tsx
<>
  // arrays with []
  <input name="category[]" value="comedy" />
  <input name="category[]" value="comedy" />
  // nested structures parentKey[childKey]
  <input name="user[name]" value="Ryan" />
</>
```

And then in your action:

```tsx
import queryString from 'query-string';

// in your action:
export async function action({ request }: ActionFunctionArgs) {
  // use `request.text()`, not `request.formData` to get the form data as a url
  // encoded form query string
  const formQueryString = await request.text();

  // parse it into an object
  const obj = queryString.parse(formQueryString);
}
```

Some folks even dump their JSON into a hidden field. Note that this approach won't work with progressive enhancement. If that's not important to your app, this is an easy way to send structured data.

```tsx
<input type="hidden" name="json" value={JSON.stringify(obj)} />
```

And then parse it in the action:

```tsx
export async function action({ request }: ActionFunctionArgs) {
  const formData = await request.formData();
  const obj = JSON.parse(formData.get('json'));
}
```

Again, `formData.getAll()` is often all you need, we encourage you to give it a shot!

[form_data]: https://developer.mozilla.org/en-US/docs/Web/API/FormData
[query_string]: https://npm.im/query-string
[ramda]: https://npm.im/ramda
[watch_on_youtube]: https://www.youtube.com/watch?v=w2i-9cYxSdc&ab_channel=Remix
[submitevent-submitter]: https://developer.mozilla.org/en-US/docs/Web/API/SubmitEvent/submitter
[formdata-submitter]: https://developer.mozilla.org/en-US/docs/Web/API/FormData/FormData#submitter
[polyfill-event-submitter]: https://github.com/idea2app/event-submitter-polyfill
[polyfill-formdata-submitter]: https://github.com/jenseng/formdata-submitter-polyfill
[remix-submitter-issue]: https://github.com/remix-run/remix/issues/9704

---

## File: ./guides/file-uploads.md

---

## title: File Uploads

<docs-warning>This doc is a WIP: It was extracted from the API docs for file uploads so it's a bit out of context. We intend to re-write this as a general guide on file uploads.</docs-warning>

Most of the time, you'll probably want to proxy the file to a file host.

**Example:**

```tsx
import type { ActionFunctionArgs, UploadHandler } from '@remix-run/node'; // or cloudflare/deno
import {
  unstable_composeUploadHandlers,
  unstable_createMemoryUploadHandler,
  unstable_parseMultipartFormData,
} from '@remix-run/node'; // or cloudflare/deno
import { writeAsyncIterableToWritable } from '@remix-run/node'; // `writeAsyncIterableToWritable` is a Node-only utility
import type { UploadApiOptions, UploadApiResponse, UploadStream } from 'cloudinary';
import cloudinary from 'cloudinary';

async function uploadImageToCloudinary(data: AsyncIterable<Uint8Array>) {
  const uploadPromise = new Promise<UploadApiResponse>(async (resolve, reject) => {
    const uploadStream = cloudinary.v2.uploader.upload_stream(
      {
        folder: 'remix',
      },
      (error, result) => {
        if (error) {
          reject(error);
          return;
        }
        resolve(result);
      },
    );
    await writeAsyncIterableToWritable(data, uploadStream);
  });

  return uploadPromise;
}

export const action = async ({ request }: ActionFunctionArgs) => {
  const userId = getUserId(request);

  const uploadHandler = unstable_composeUploadHandlers(
    // our custom upload handler
    async ({ name, contentType, data, filename }) => {
      if (name !== 'img') {
        return undefined;
      }
      const uploadedImage = await uploadImageToCloudinary(data);
      return uploadedImage.secure_url;
    },
    // fallback to memory for everything else
    unstable_createMemoryUploadHandler(),
  );

  const formData = await unstable_parseMultipartFormData(request, uploadHandler);

  const imageUrl = formData.get('avatar');

  // because our uploadHandler returns a string, that's what the imageUrl will be.
  // ... etc
};
```

The `UploadHandler` function accepts a number of parameters about the file:

| Property    | Type                      | Description                                                                  |
| ----------- | ------------------------- | ---------------------------------------------------------------------------- |
| name        | string                    | The field name (comes from your HTML form field "name" value)                |
| data        | AsyncIterable<Uint8Array> | The iterable of the file bytes                                               |
| filename    | string                    | The name of the file that the user selected for upload (like `rickroll.mp4`) |
| contentType | string                    | The content type of the file (like `videomp4`)                               |

Your job is to do whatever you need with the `data` and return a value that's a valid \[`FormData`]\[form-data] value: \[`File`]\[the-browser-file-api], `string`, or `undefined` to skip adding it to the resulting FormData.

### Upload Handler Composition

We have the built-in `unstable_createFileUploadHandler` and `unstable_createMemoryUploadHandler` and we also expect more upload handler utilities to be developed in the future. If you have a form that needs to use different upload handlers, you can compose them together with a custom handler, here's a theoretical example:

```ts filename=file-upload-handler.server.ts
import type { UploadHandler } from '@remix-run/node'; // or cloudflare/deno
import { unstable_createFileUploadHandler } from '@remix-run/node'; // or cloudflare/deno
import { createCloudinaryUploadHandler } from 'some-handy-remix-util';

export const standardFileUploadHandler = unstable_createFileUploadHandler({
  directory: 'public/calendar-events',
});

export const cloudinaryUploadHandler = createCloudinaryUploadHandler({
  folder: '/my-site/avatars',
});

export const fileUploadHandler: UploadHandler = (args) => {
  if (args.name === 'calendarEvent') {
    return standardFileUploadHandler(args);
  } else if (args.name === 'eventBanner') {
    return cloudinaryUploadHandler(args);
  }
  return undefined;
};
```

---

## File: ./guides/form-validation.md

---

## title: Form Validation

# Form Validation

This guide walks you through implementing form validation for a simple signup form in Remix. Here, we focus on capturing the fundamentals to help you understand the essential elements of form validation in Remix, including [`action`][action]s, action data, and rendering errors.

## Step 1: Setting Up the Signup Form

We'll start by creating a basic signup form using the [`Form`][form_component] component from Remix.

```tsx filename=app/routes/signup.tsx
import { Form } from '@remix-run/react';

export default function Signup() {
  return (
    <Form method="post">
      <p>
        <input type="email" name="email" />
      </p>

      <p>
        <input type="password" name="password" />
      </p>

      <button type="submit">Sign Up</button>
    </Form>
  );
}
```

## Step 2: Defining the Action

In this step, we'll define a server `action` in the same file as our `Signup` component. Note that the aim here is to provide a broad overview of the mechanics involved rather than digging deep into form validation rules or error object structures. We'll use rudimentary checks for the email and password to demonstrate the core concepts.

```tsx filename=app/routes/signup.tsx
import type { ActionFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json, redirect } from '@remix-run/node'; // or cloudflare/deno
import { Form } from '@remix-run/react';

export default function Signup() {
  // omitted for brevity
}

export async function action({ request }: ActionFunctionArgs) {
  const formData = await request.formData();
  const email = String(formData.get('email'));
  const password = String(formData.get('password'));

  const errors = {};

  if (!email.includes('@')) {
    errors.email = 'Invalid email address';
  }

  if (password.length < 12) {
    errors.password = 'Password should be at least 12 characters';
  }

  if (Object.keys(errors).length > 0) {
    return json({ errors });
  }

  // Redirect to dashboard if validation is successful
  return redirect('/dashboard');
}
```

If any validation errors are found, they are returned from the `action` to the client. This is our way of signaling to the UI that something needs to be corrected, otherwise the user will be redirected to the dashboard.

## Step 3: Displaying Validation Errors

Finally, we'll modify the `Signup` component to display validation errors, if any. We'll use [`useActionData`][use_action_data] to access and display these errors.

```tsx filename=app/routes/signup.tsx lines=[3,6,12-14,19-21]
import type { ActionFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json, redirect } from '@remix-run/node'; // or cloudflare/deno
import { Form, useActionData } from '@remix-run/react';

export default function Signup() {
  const actionData = useActionData<typeof action>();

  return (
    <Form method="post">
      <p>
        <input type="email" name="email" />
        {actionData?.errors?.email ? <em>{actionData?.errors.email}</em> : null}
      </p>

      <p>
        <input type="password" name="password" />
        {actionData?.errors?.password ? <em>{actionData?.errors.password}</em> : null}
      </p>

      <button type="submit">Sign Up</button>
    </Form>
  );
}

export async function action({ request }: ActionFunctionArgs) {
  // omitted for brevity
}
```

## Conclusion

And there you have it! You've successfully set up a basic form validation flow in Remix. The beauty of this approach is that the errors will automatically display based on the `action` data, and they will be updated each time the user re-submits the form. This reduces the amount of boilerplate code you have to write, making your development process more efficient.

[action]: ../route/action
[form_component]: ../components/form
[use_action_data]: ../hooks/use-action-data

---

## File: ./guides/gotchas.md

---

## title: Gotchas

# Gotchas

Rendering your app on the server and in the browser with React has some inherent gotchas. Additionally, as we've built Remix, we've been laser focused on production results and scalability. Some developer-experience and ecosystem-compatibility issues exist that we haven't smoothed over yet.

This document should help you get over these bumps.

## `typeof window` checks

Because the same JavaScript code can run in the browser as well as the server, sometimes you need to have a part of your code that only runs in one context or the other:

```ts bad
if (typeof window === 'undefined') {
  // running in a server environment
} else {
  // running in a browser environment
}
```

This works fine in a Node.js environment, however, Deno actually supports `window`! So if you really want to check whether you're running in the browser, it's better to check for `document` instead:

```ts good
if (typeof document === 'undefined') {
  // running in a server environment
} else {
  // running in a browser environment
}
```

This will work for all JS environments (Node.js, Deno, Workers, etc.).

## Browser extensions injecting code

You may run into this warning in the browser:

```
Warning: Did not expect server HTML to contain a <script> in <html>.
```

This is a hydration warning from React, and is most likely due to one of your browser extensions injecting scripts into the server-rendered HTML, creating a difference with the resulting HTML.

Check out the page in incognito mode, the warning should disappear.

## Writing to Sessions in `loader`s

Typically, you should only write to sessions in actions, but there are occasions where it makes sense in loaders (anonymous users, navigation tracking, etc.)

While multiple loaders can _read_ from the same session, _writing_ to a session in loaders can cause problems.

Remix loaders run in parallel, and sometimes in separate requests (client transitions call [`fetch`][fetch] for each loader). If one loader is writing to a session while another is attempting to read from it, you will hit bugs and/or non-deterministic behavior.

Additionally, sessions are built on cookies which come from the browser's request. After committing a session, it goes to the browser in a [`Set-Cookie`][set_cookie_header] header which is then sent back to the server on the next request in the [`Cookie`][cookie_header] header. Regardless of parallel loaders, you can't write to a cookie with `Set-Cookie` and then attempt to read it from the original request `Cookie` and expect updated values. It needs to make a round trip to the browser first and come from the next request.

If you need to write to a session in a loader, ensure the loader doesn't share that session with any other loaders.

## Server Code in Client Bundles

<docs-warning>This section is only relevant if you're using the [Classic Remix Compiler][classic-remix-compiler].</docs-warning>

You may run into this strange error in the browser. It almost always means that server code made it into browser bundles.

```
TypeError: Cannot read properties of undefined (reading 'root')
```

For example, you can't import `fs-extra` directly into a route module:

```tsx bad filename=app/routes/_index.tsx lines=[2] nocopy
import { json } from '@remix-run/node'; // or cloudflare/deno
import fs from 'fs-extra';

export async function loader() {
  return json(await fs.pathExists('../some/path'));
}

export default function SomeRoute() {
  // ...
}
```

To fix it, move the import into a different module named `*.server.ts` or `*.server.js` and import from there. In our example here, we create a new file at `utils/fs-extra.server.ts`:

```ts filename=app/utils/fs-extra.server.ts
export { default } from 'fs-extra';
```

And then change our import in the route to the new "wrapper" module:

```tsx filename=app/routes/_index.tsx lines=[3]
import { json } from '@remix-run/node'; // or cloudflare/deno

import fs from '@/utils/fs-extra.server';

export async function loader() {
  return json(await fs.pathExists('../some/path'));
}

export default function SomeRoute() {
  // ...
}
```

Even better, send a PR to the project to add `"sideEffects": false` to their `package.json` so that bundlers that tree shake know they can safely remove the code from browser bundles.

Similarly, you may run into the same error if you call a function at the top-level scope of your route module that depends on server-only code.

For example, [Remix upload handlers like `unstable_createFileUploadHandler` and `unstable_createMemoryUploadHandler`][parse_multipart_form_data_upload_handler] use Node globals under the hood and should only be called on the server. You can call either of these functions in a `*.server.ts` or `*.server.js` file, or you can move them into your route's `action` or `loader` function.

So instead of doing:

```tsx bad filename=app/routes/some-route.tsx lines=[3-6]
import { unstable_createFileUploadHandler } from '@remix-run/node'; // or cloudflare/deno

const uploadHandler = unstable_createFileUploadHandler({
  maxPartSize: 5_000_000,
  file: ({ filename }) => filename,
});

export async function action() {
  // use `uploadHandler` here ...
}
```

You should be doing:

```tsx filename=app/routes/some-route.tsx good lines=[4-7]
import { unstable_createFileUploadHandler } from '@remix-run/node'; // or cloudflare/deno

export async function action() {
  const uploadHandler = unstable_createFileUploadHandler({
    maxPartSize: 5_000_000,
    file: ({ filename }) => filename,
  });

  // use `uploadHandler` here ...
}
```

> Why does this happen?

Remix uses "tree shaking" to remove server code from browser bundles. Anything inside of Route module `action`, `headers`, and `loader` exports will be removed. It's a great approach but suffers from ecosystem compatibility.

When you import a third-party module, Remix checks the `package.json` of that package for `"sideEffects": false`. If that is configured, Remix knows it can safely remove the code from the client bundles. Without it, the imports remain because code may depend on the module's side effects (like setting global polyfills, etc.).

## Importing ESM Packages

<docs-warning>This section is only relevant if you're using the [Classic Remix Compiler][classic-remix-compiler].</docs-warning>

You may try importing an ESM-only package into your app and see an error like this when server rendering:

```
Error [ERR_REQUIRE_ESM]: require() of ES Module /app/node_modules/dot-prop/index.js from /app/project/build/index.js not supported.
Instead change the require of /app/project/node_modules/dot-prop/index.js in /app/project/build/index.js to a dynamic import() which is available in all CommonJS modules.
```

To fix it, add the ESM package to the [`serverDependenciesToBundle`][server_dependencies_to_bundle] option in your [`remix.config.js`][remix_config] file.

In our case here, we're using the `dot-prop` package, so we would do it like this:

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  serverDependenciesToBundle: ['dot-prop'],
  // ...
};
```

> Why does this happen?

Remix compiles your server build to CJS and doesn't bundle your node modules. CJS modules can't import ESM modules.

Adding packages to `serverDependenciesToBundle` tells Remix to bundle the ESM module directly into the server build instead of requiring it at runtime.

> Isn't ESM the future?

Yes! Our plan is to allow you to compile your app to ESM on the server. However, that will come with the reverse problem of not being able to import some CommonJS modules that are incompatible with being imported from ESM! So even when we get there, we may still need this configuration.

You may ask why we don't just bundle everything for the server. We could, but that will slow down builds and make production stack traces all point to a single file for your entire app. We don't want to do that. We know we can smooth this over eventually without making that tradeoff.

With major deployment platforms now supporting ESM server side, we're confident the future is brighter than the past here. We're still working on a solid dev experience for ESM server builds, our current approach relies on some things that you can't do in ESM. We'll get there.

## CSS bundle being incorrectly tree-shaken

<docs-warning>This section is only relevant if you're using the [Classic Remix Compiler][classic-remix-compiler].</docs-warning>

When using [CSS bundling features][css_bundling] in combination with `export *` (e.g. when using an index file like `components/index.ts` that re-exports from all subdirectories) you may find that styles from the re-exported modules are missing from the build output.

This is due to an [issue with `esbuild`'s CSS tree shaking][esbuild_css_tree_shaking_issue]. As a workaround, you should use named re-exports instead.

```diff
- export * from "./Button";
+ export { Button } from "./Button";
```

Note that, even if this issue didn't exist, we'd still recommend using named re-exports! While it may introduce a bit more boilerplate, you get explicit control over the module's public interface rather than inadvertently exposing everything.

[esbuild]: https://esbuild.github.io
[parse_multipart_form_data_upload_handler]: ../utils/parse-multipart-form-data#uploadhandler
[server_dependencies_to_bundle]: ../file-conventions/remix-config#serverdependenciestobundle
[remix_config]: ../file-conventions/remix-config
[css_bundling]: ../styling/bundling
[esbuild_css_tree_shaking_issue]: https://github.com/evanw/esbuild/issues/1370
[fetch]: https://developer.mozilla.org/en-US/docs/Web/API/fetch
[set_cookie_header]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie
[cookie_header]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie
[classic-remix-compiler]: ./vite#classic-remix-compiler-vs-remix-vite

---

## File: ./guides/images.md

---

title: Handling Images
hidden: true

---

---

## File: ./guides/index.md

---

title: Guides
order: 10

---

---

## File: ./guides/index-query-param.md

---

title: Index Query Param
toc: false

---

# Index Query Param

You may find a wild `?index` appear in the URL of your app when submitting forms.

Because of nested routes, multiple routes in your route hierarchy can match the URL. Unlike navigations where all matching route [`loader`][loader]s are called to build up the UI, when a [`form`][form_element] is submitted _only one action is called_.

Because index routes share the same URL as their parent, the `?index` param lets you disambiguate between the two.

For example, consider the following forms:

```tsx
<Form method="post" action="/projects" />;
<Form method="post" action="/projects?index" />;
```

The `?index` param will submit to the index route, the [`action`][form_component_action] without the index param will submit to the parent route.

When a [`<Form>`][form_component] is rendered in an index route without an [`action`][action], the `?index` param will automatically be appended so that the form posts to the index route. The following form, when submitted, will post to `/projects?index` because it is rendered in the context of the projects index route:

```tsx filename=app/routes/projects._index.tsx
function ProjectsIndex() {
  return <Form method="post" />;
}
```

If you moved the code to the `ProjectsLayout` route, it would instead post to `/projects`.

This applies to `<Form>` and all of its cousins:

```tsx
function Component() {
  const submit = useSubmit();
  submit({}, { action: '/projects' });
  submit({}, { action: '/projects?index' });
}
```

```tsx
function Component() {
  const fetcher = useFetcher();
  fetcher.submit({}, { action: '/projects' });
  fetcher.submit({}, { action: '/projects?index' });
  <fetcher.Form action="/projects" />;
  <fetcher.Form action="/projects?index" />;
  <fetcher.Form />; // defaults to the route in context
}
```

[loader]: ../route/loader
[form_element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form
[form_component_action]: ../components/form#action
[form_component]: ../components/form
[action]: ../route/action

---

## File: ./guides/lazy-route-discovery.md

---

## title: Lazy Route Discovery

# Lazy Route Discovery (a.k.a. "Fog of War")

Remix introduced support for Lazy Route Discovery (a.k.a. "Fog of War") ([RFC][rfc]) behind the `future.unstable_lazyRouteDiscovery` [Future Flag][future-flags] in [`v2.10.0`][2.10.0] (later stabilized as `future.v3_lazyRouteDiscovery` in [`v2.13.0`][2.13.0]). This allows you to opt-into this behavior which will become the default in the next major version of Remix - a.k.a. React Router v7 ([1][rr-v7], [2][rr-v7-2]). For more information on this feature, please check out the [blog post][blog-post].

## Current Behavior

Currently, Remix loads the complete route manifest in a JS file on initial load (i.e., `/assets/manifest-[hash].js`). The manifest does not contain the route module implementations, but rather their URL paths and meta information (route JS/CSS imports, whether they have a `loader`/`action` on the server, etc.). Having this full manifest up-front allows Remix to do synchronous client-side route matching on Link clicks and kick off the loads for route modules and data immediately. For small-to-medium-sized apps, loading the full manifest up-front is usually not prohibitive as it is highly cacheable and gzips down quite well. However, at scale we found that this manifest could grow large enough to impact some performance metrics.

## New Behavior

When you enable "Fog of War", Remix will no longer send a full route manifest on initial load. Instead, your SSR render will only include the SSR routes in the initial manifest and additional routes will be loaded as the user navigates around the application. Over time, the manifest grows to include the portions of the app the user navigated to.

Please note that this is **not** a way to "hide" any of your application URLs from end-users. It doesn't ship them all in the manifest initially, but the manifest endpoint used to fetch new routes as the user navigates around will still have the ability to expose all of your defined application routes - albeit it's just a bit more obscured.

### Eager Route Discovery

As always, there is a tradeoff with this type of lazy-route discovery. It improves initial application load times -- but Remix can no longer perform synchronous route matching on link clicks, which can lead to waterfalls.

In the current architecture (without using `<Link prefetch>`), clicking a link would look something like this:

```
click /a
        |-- load route module -->
        |-- load route data -->
                                 | render /a
```

In the Fog of War architecture, clicking a link can introduce a waterfall:

```
click /a
        |-- discover route -->
                              |-- load route module -->
                              |-- load route data -->
                                                       | render /a
```

As we all know, Remix hates waterfalls, so the Fog of War feature implements an optimization to avoid them in the majority of cases. By default, all [`<Link>`][link] and [`<NavLink>`][navlink] components rendered on the page will be batched up and eagerly "discovered" via a request to the server. This request will match all current link paths on the server and send back all required route manifest entries. Under the majority of cases, this request should complete prior to the user clicking any links (since users don't usually click links in the first few hundred milliseconds) and the manifest will be patched before any links are clicked. Then, when a link is clicked, Remix is able to do synchronous client-side matching as if the Fog of War behavior wasn't even present.

If you wish to opt-out of this eager route discovery on a per-link basis, you can do that via the [`discover="none"`][link-discover] prop (the default value is `discover="render"`).

### Notable Changes

- When this feature is enabled, the route manifest in `window.__remixManifest.routes` will only contain the minimal required routes on initial SSR, and routes will be added to it dynamically as the user navigates around
- The Remix handler now has a new internal `/__manifest` endpoint through which it will fetch manifest patches
  - You will need to ensure that your deployment architecture routes any `/__manifest` requests through to the Remix handler
  - If you have any CDN/Edge caching layers in place, the `/__manifest` route accepts 2 query string params you may need to include in your cache key: `version` and `p`
  - ‚ö†Ô∏è This is considered an internal implementation detail and is not intended to be requested by application code

[rfc]: https://github.com/remix-run/react-router/discussions/11113
[future-flags]: ../guides/api-development-strategy
[2.10.0]: https://github.com/remix-run/remix/blob/main/CHANGELOG.md#v2100
[2.13.0]: https://github.com/remix-run/remix/blob/main/CHANGELOG.md#v2130
[link]: ../components/link
[navlink]: ../components/nav-link
[link-discover]: ../components/link#discover
[rr-v7]: https://remix.run/blog/merging-remix-and-react-router
[rr-v7-2]: https://remix.run/blog/incremental-path-to-react-19
[blog-post]: https://remix.run/blog/fog-of-war

---

## File: ./guides/local-tls.md

---

## title: "Local TLS"

# Local TLS

<docs-warning>This guide is currently only relevant when using the [Classic Remix Compiler][classic-remix-compiler].</docs-warning>

It's simpler to use HTTP locally, but if you really need to use HTTPS locally, here's how to do it.

<docs-warning>

`remix-serve` does not support local HTTPS as its meant to be a minimal server to get you off the ground.
`remix-serve` is a simple wrapper around Express, so you can use Express directly if you want to use HTTPS locally.

If you are running `remix dev` without the `-c` flag, you are implicitly using `remix-serve` as your app server.

</docs-warning>

## Running your app server with local TLS

The first step is to get your app server running with local TLS _without_ running `remix dev`.
That will set you up for success when you set up `remix dev` with local TLS in the next section.

üëâ Install [`mkcert`][mkcert]

üëâ Create a local Certificate Authority:

```shellscript nonumber
mkcert -install
```

üëâ Tell Node to use our local CA:

```shellscript nonumber
export NODE_EXTRA_CA_CERTS="$(mkcert -CAROOT)/rootCA.pem"
```

üëâ Create a TLS key and certificate:

```shellscript nonumber
mkcert -key-file key.pem -cert-file cert.pem localhost
```

<docs-info>

You can change `localhost` to something else when generating TLS keys and certificates if you are using custom hostnames.

</docs-info>

üëâ Use the `key.pem` and `cert.pem` to get HTTPS working locally with your app server.

How you do this will depend on what app server you are using.
For example, here's how you could use HTTPS with an Express server:

```ts filename=server.ts
import fs from 'node:fs';
import https from 'node:https';
import path from 'node:path';

import express from 'express';

const BUILD_DIR = path.resolve(__dirname, 'build');
const build = require(BUILD_DIR);

const app = express();

// ... code setting up your express app goes here ...

const server = https.createServer(
  {
    key: fs.readFileSync('path/to/key.pem'),
    cert: fs.readFileSync('path/to/cert.pem'),
  },
  app,
);

const port = 3000;
server.listen(port, () => {
  // ... code to run after your server is running goes here ...
});
```

üëâ Run your app server with local TLS

For example, with the Express server above, you would run it like this:

```shellscript nonumber
remix build
node ./server.js
```

## Running `remix dev` with local TLS

Make sure you can run your app with local TLS without `remix dev` first!
Check out the previous section if you haven't done that yet.

üëâ Enable TLS for `remix dev`

Via config:

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  dev: {
    tlsKey: 'key.pem', // relative to cwd
    tlsCert: 'cert.pem', // relative to cwd
  },
};
```

or via flags:

```shellscript nonumber
remix dev --tls-key=key.pem --tls-cert=cert.pem -c "node ./server.js"
```

Your app should now be running with local TLS!

[mkcert]: https://github.com/FiloSottile/mkcert#installation
[classic-remix-compiler]: ./vite#classic-remix-compiler-vs-remix-vite

---

## File: ./guides/manual-mode.md

---

## title: Manual Dev Server

# Manual mode

<docs-warning>This guide is only relevant when using the [Classic Remix Compiler][classic-remix-compiler].</docs-warning>

By default, `remix dev` drives like an automatic.
It keeps your app server up-to-date with the latest code changes by automatically restarting the app server whenever file changes are detected in your app code.
This is a simple approach that stays out of your way, and we think will work well for most apps.

But if app server restarts are slowing you down, you can take the wheel and drive `remix dev` like a manual:

```shellscript nonumber
remix dev --manual -c "node ./server.js"
```

That means learning how to use the clutch to shift gears.
It also means you might stall while your getting your bearings.
It takes a bit more time to learn and its more code for you to maintain.

> With great power comes great responsibility.

We don't think its worth it unless you're feeling some pain with the default automatic mode.
But if you are, Remix has got you covered.

## Mental model for `remix dev`

Before you start drag racing, it helps to understand how Remix works under the hood.
It's especially important to understand that `remix dev` spins up _not one, but two processes_: the Remix compiler and your app server.

Check out our video ["Mental model for the new dev flow üß†"][mental_model] for more details.

<docs-info>

Previously, we referred to the Remix compiler as the "new dev server" or the "v2 dev server".
Technically, `remix dev` is a thin layer around the Remix compiler that _does_ include a tiny server with a single endpoint (`/ping`) for coordinating hot updates.
But thinking of `remix dev` as a "dev server" is unhelpful and wrongly implies that it is replacing your app server in dev.
Rather than replacing your app server, `remix dev` runs your app server _alongside_ the Remix compiler, so you get the best of both worlds:

- Hot updates managed by the Remix compiler
- Real production code paths running in dev within your app server

</docs-info>

## `remix-serve`

The Remix App Server (`remix-serve`) comes with support for manual mode out of the box:

```sh
remix dev --manual
```

<docs-info>

If you are running `remix dev` without the `-c` flag, then you are implicitly using `remix-serve` as your app server.

</docs-info>

No need to learn to drive stick, since `remix-serve` has a built-in sports mode that automatically shifts gears for you more aggressively at higher RPMs.
Ok, I think we're stretching this car metaphor. üòÖ

In other words, `remix-serve` knows how to reimport server code changes _without_ needing to restart itself.
But if you are using `-c` to run your own app server, read on.

## Learning to drive stick

When you switch on manual mode with `--manual`, you take on some new responsibilities:

1. Detect when server code changes are available
2. Re-import code changes while keeping the app server running
3. Send "ready" message to the Remix compiler _after_ those changes are picked up

Re-importing code changes turns out to be tricky because JS imports are cached.

```js
import fs from 'node:fs';

const original = await import('./build/index.js');
fs.writeFileSync('./build/index.js', someCode);
const changed = await import('./build/index.js');
//    ^^^^^^^ this will return the original module from the import cache without the code changes
```

You need some way to bust the import cache when you want to re-import modules with code changes.
Also importing modules is different between CommonJS (`require`) and ESM (`import`) which makes things even more complicated.

<docs-warning>

If you are using `tsx` or `ts-node` to run your `server.ts`, those tools may be transpiling your ESM Typescript code to CJS Javascript code.
In this case, you'll need to use CJS cache busting in your `server.ts` even though the rest of your server code uses `import`s.

What matters here is how your server code is _executed_ not how its _written_.

</docs-warning>

### 1.a CJS: `require` cache busting

CommonJS uses `require` for imports, giving you direct access to the `require` cache.
That lets you bust the cache for _just_ the server code when rebuilds occur.

For example, here's how to bust the `require` cache for the Remix server build:

```js
const path = require('node:path');

/** @typedef {import('@remix-run/node').ServerBuild} ServerBuild */

const BUILD_PATH = path.resolve('./build/index.js');
const VERSION_PATH = path.resolve('./build/version.txt');
const initialBuild = reimportServer();

/**
 * @returns {ServerBuild}
 */
function reimportServer() {
  // 1. manually remove the server build from the require cache
  Object.keys(require.cache).forEach((key) => {
    if (key.startsWith(BUILD_PATH)) {
      delete require.cache[key];
    }
  });

  // 2. re-import the server build
  return require(BUILD_PATH);
}
```

<docs-info>

The `require` cache keys are _absolute paths_ so make sure you resolve your server build path to an absolute path!

</docs-info>

### 1.b ESM: `import` cache busting

Unlike CJS, ESM doesn't give you direct access to the import cache.
To work around this, you can use a timestamp query parameter to force ESM to treat the import as a new module.

```js
import * as fs from 'node:fs';
import * as path from 'node:path';
import * as url from 'node:url';

/** @typedef {import('@remix-run/node').ServerBuild} ServerBuild */

const BUILD_PATH = path.resolve('./build/index.js');
const VERSION_PATH = path.resolve('./build/version.txt');
const initialBuild = await reimportServer();

/**
 * @returns {Promise<ServerBuild>}
 */
async function reimportServer() {
  const stat = fs.statSync(BUILD_PATH);

  // convert build path to URL for Windows compatibility with dynamic `import`
  const BUILD_URL = url.pathToFileURL(BUILD_PATH).href;

  // use a timestamp query parameter to bust the import cache
  return import(BUILD_URL + '?t=' + stat.mtimeMs);
}
```

<docs-warning>

In ESM, there's no way to remove entries from the `import` cache.
While our timestamp workaround works, it means that the `import` cache will grow over time which can eventually cause Out of Memory errors.

If this happens, you can restart `remix dev` to start again with a fresh import cache.
In the future, Remix may pre-bundle your dependencies to keep the import cache small.

</docs-warning>

### 2. Detecting server code changes

Now that you have a way to bust the import cache for CJS or ESM, it's time to put that to use by dynamically updating the server build within your app server.
To detect when the server code changes, you can use a file watcher like [chokidar][chokidar]:

```js
import chokidar from 'chokidar';

async function handleServerUpdate() {
  build = await reimportServer();
}

chokidar
  .watch(VERSION_PATH, { ignoreInitial: true })
  .on('add', handleServerUpdate)
  .on('change', handleServerUpdate);
```

### 3. Sending the "ready" message

Now's a good time to double-check that your app server is sending "ready" messages to the Remix compiler when it initially spins up:

```js filename=server.js lines=[5-7]
const port = 3000;
app.listen(port, async () => {
  console.log(`Express server listening on port ${port}`);

  if (process.env.NODE_ENV === 'development') {
    broadcastDevReady(initialBuild);
  }
});
```

In manual mode, you also need to send "ready" messages whenever you re-import the server build:

```js lines=[4-5]
async function handleServerUpdate() {
  // 1. re-import the server build
  build = await reimportServer();
  // 2. tell Remix that this app server is now up-to-date and ready
  broadcastDevReady(build);
}
```

### 4. Dev-aware request handler

Last step is to wrap all of this up in a development mode request handler:

```js
/**
 * @param {ServerBuild} initialBuild
 */
function createDevRequestHandler(initialBuild) {
  let build = initialBuild;
  async function handleServerUpdate() {
    // 1. re-import the server build
    build = await reimportServer();
    // 2. tell Remix that this app server is now up-to-date and ready
    broadcastDevReady(build);
  }

  chokidar
    .watch(VERSION_PATH, { ignoreInitial: true })
    .on('add', handleServerUpdate)
    .on('change', handleServerUpdate);

  // wrap request handler to make sure its recreated with the latest build for every request
  return async (req, res, next) => {
    try {
      return createRequestHandler({
        build,
        mode: 'development',
      })(req, res, next);
    } catch (error) {
      next(error);
    }
  };
}
```

Awesome!
Now let's plug in our new manual transmission when running in development mode:

```js filename=server.js
app.all(
  '*',
  process.env.NODE_ENV === 'development'
    ? createDevRequestHandler(initialBuild)
    : createRequestHandler({ build: initialBuild }),
);
```

For complete app server code examples, check our [templates][templates] or [community examples][community_examples].

## Keeping in-memory server state across rebuilds

When server code is re-imported, any server-side in-memory state is lost.
That includes things like database connections, caches, in-memory data structures, etc.

Here's a utility that remembers any in-memory values you want to keep around across rebuilds:

```ts filename=app/utils/singleton.server.ts
// Borrowed & modified from https://github.com/jenseng/abuse-the-platform/blob/main/app/utils/singleton.ts
// Thanks @jenseng!

export const singleton = <Value>(name: string, valueFactory: () => Value): Value => {
  const g = global as any;
  g.__singletons ??= {};
  g.__singletons[name] ??= valueFactory();
  return g.__singletons[name];
};
```

For example, to reuse a Prisma client across rebuilds:

```ts filename=app/db.server.ts
import { PrismaClient } from '@prisma/client';

import { singleton } from '@/utils/singleton.server';

// hard-code a unique key so we can look up the client when this module gets re-imported
export const db = singleton('prisma', () => new PrismaClient());
```

There is also a handy [`remember` utility][remember] that can help out here if you prefer to use that.

[mental_model]: https://www.youtube.com/watch?v=zTrjaUt9hLo
[chokidar]: https://github.com/paulmillr/chokidar
[templates]: https://github.com/remix-run/remix/blob/main/templates
[community_examples]: https://github.com/xHomu/remix-v2-server
[remember]: https://npm.im/@epic-web/remember
[classic-remix-compiler]: ./vite#classic-remix-compiler-vs-remix-vite

---

## File: ./guides/mdx.md

---

title: MDX
description: Remix makes integrating MDX into your project a breeze with built in routes and "import" support.

---

# MDX

<docs-warning>This documentation is only relevant when using the [Classic Remix Compiler][classic-remix-compiler]. Vite consumers wanting to use MDX should use the [MDX Rollup (and Vite) plugin][mdx-plugin].</docs-warning>

While we believe that a strong separation of data and display is important, we understand that formats that mix the two such as [MDX][mdx] (Markdown with embedded JSX components) have become a popular and powerful authoring format for developers.

<docs-info>Rather than compiling your content at build-time like this document demonstrates, it's typically better UX and DX if you do this at runtime via something like <a href="https://github.com/kentcdodds/mdx-bundler">mdx-bundler</a>. It's also much more customizable and powerful. However, if you prefer to do this compilation at build-time, continue reading.</docs-info>

Remix has built-in support for using MDX at build-time in two ways:

- You can use a `.mdx` file as one of your route modules
- You can `import` a `.mdx` file into one of your route modules (in `app/routes`)

## Routes

The simplest way to get started with MDX in Remix is to create a route module. Just like `.tsx`, `.js` and `.jsx` files in your `app/routes` directory, `.mdx` (and `.md`) files will participate in automatic file system based routing.

MDX routes allow you to define both meta and headers as if they were a code based route:

```md
---
meta:
  - title: My First Post
  - name: description
    content: Isn't this awesome?
headers:
  Cache-Control: no-cache
---

# Hello Content!
```

The lines in the document above between the `---` are called "frontmatter". You can think of them like metadata for your document, formatted as [YAML][yaml].

You can reference your frontmatter fields through the global `attributes` variable in your MDX:

```mdx
---
componentData:
  label: Hello, World!
---

import SomeComponent from '@/components/some-component';

# Hello MDX!

<SomeComponent {...attributes.componentData} />
```

### Example

By creating a `app/routes/posts.first-post.mdx` we can start writing a blog post:

```mdx
---
meta:
  - title: My First Post
  - name: description
    content: Isn't this just awesome?
---

# Example Markdown Post

You can reference your frontmatter data through "attributes". The title of this post is {attributes.meta.title}!
```

### Advanced Example

You can even export all the other things in this module that you can in regular route modules in your mdx files like `loader`, `action`, and `handle`:

```mdx
---
meta:
  - title: My First Post
  - name: description
    content: Isn't this awesome?

headers:
  Cache-Control: no-cache

handle:
  someData: abc
---

import styles from './first-post.css';

export const links = () => [{ rel: 'stylesheet', href: styles }];

import { json } from '@remix-run/node';
import { useLoaderData } from '@remix-run/react';

export const loader = async () => {
  return json({ mamboNumber: 5 });
};

export function ComponentUsingData() {
  const { mamboNumber } = useLoaderData<typeof loader>();
  return <div id="loader">Mambo Number: {mamboNumber}</div>;
}

# This is some markdown!

<ComponentUsingData />
```

## Modules

Besides just route level MDX, you can also import these files anywhere yourself as if it were a regular JavaScript module.

When you `import` a `.mdx` file, the exports of the module are:

- **default**: The React component for consumption
- **attributes**: The frontmatter data as an object
- **filename**: The basename of the source file (e.g. "first-post.mdx")

```tsx
import Component, { attributes, filename } from './first-post.mdx';
```

## Example Blog Usage

The following example demonstrates how you might build a simple blog with MDX, including individual pages for the posts themselves and an index page that shows all posts.

```tsx filename=app/routes/_index.tsx
import { json } from '@remix-run/node'; // or cloudflare/deno
import { Link, useLoaderData } from '@remix-run/react';

// Import all your posts from the app/routes/posts directory. Since these are
// regular route modules, they will all be available for individual viewing
// at /posts/a, for example.
import * as postA from './posts/a.mdx';
import * as postB from './posts/b.md';
import * as postC from './posts/c.md';

function postFromModule(mod) {
  return {
    slug: mod.filename.replace(/\.mdx?$/, ''),
    ...mod.attributes.meta,
  };
}

export async function loader() {
  // Return metadata about each of the posts for display on the index page.
  // Referencing the posts here instead of in the Index component down below
  // lets us avoid bundling the actual posts themselves in the bundle for the
  // index page.
  return json([postFromModule(postA), postFromModule(postB), postFromModule(postC)]);
}

export default function Index() {
  const posts = useLoaderData<typeof loader>();

  return (
    <ul>
      {posts.map((post) => (
        <li key={post.slug}>
          <Link to={post.slug}>{post.title}</Link>
          {post.description ? <p>{post.description}</p> : null}
        </li>
      ))}
    </ul>
  );
}
```

Clearly this is not a scalable solution for a blog with thousands of posts. Realistically speaking, writing is hard, so if your blog starts to suffer from too much content, that's an awesome problem to have. If you get to 100 posts (congratulations!), we suggest you rethink your strategy and turn your posts into data stored in a database so that you don't have to rebuild and redeploy your blog every time you fix a typo. You can even keep using MDX with [MDX Bundler][mdx-bundler].

## Advanced Configuration

If you wish to configure your own remark plugins you can do so through the `remix.config.js`'s `mdx` export:

```js filename=remix.config.js
const { remarkMdxFrontmatter } = require('remark-mdx-frontmatter');

// can be an sync / async function or an object
exports.mdx = async (filename) => {
  const [rehypeHighlight, remarkToc] = await Promise.all([
    import('rehype-highlight').then((mod) => mod.default),
    import('remark-toc').then((mod) => mod.default),
  ]);

  return {
    remarkPlugins: [remarkToc],
    rehypePlugins: [rehypeHighlight],
  };
};
```

[mdx-plugin]: https://mdxjs.com/packages/rollup
[mdx]: https://mdxjs.com
[yaml]: https://yaml.org
[mdx-bundler]: https://github.com/kentcdodds/mdx-bundler
[classic-remix-compiler]: ./vite#classic-remix-compiler-vs-remix-vite

---

## File: ./guides/meta.md

---

title: SEO and Meta Tags
hidden: true

---

---

## File: ./guides/migrating-react-router-app.md

---

title: Migrating from React Router
description: Migrating your React Router app to Remix can be done all at once or in stages. This guide will walk you through an iterative approach to get your app running quickly.

---

<docs-info>If you want a TL;DR version along with a repo outlining a simplified migration, check out our <a href="https://github.com/kentcdodds/incremental-react-router-to-remix-upgrade-path">example React Router-to-Remix repo</a>.</docs-info>

# Migrating your React Router App to Remix

<docs-warning>This guide currently assumes you are using the [Classic Remix Compiler][classic-remix-compiler] rather than [Remix Vite][remix-vite].</docs-warning>

Millions of React applications deployed worldwide are powered by [React Router][react-router]. Chances are you've shipped a few of them! Because Remix is built on top of React Router, we have worked to make migration an easy process you can work through iteratively to avoid huge refactors.

If you aren't already using React Router, we think there are several compelling reasons to reconsider! History management, dynamic path matching, nested routing, and much more. Take a look at the [React Router docs][react-router-docs] and see all what we have to offer.

## Ensure your app uses React Router v6

If you are using an older version of React Router, the first step is to upgrade to v6. Check out the [migration guide from v5 to v6][migration-guide-from-v5-to-v6] and our [backwards compatibility package][backwards-compatibility-package] to upgrade your app to v6 quickly and iteratively.

## Installing Remix

First, you'll need a few of our packages to build on Remix. Follow the instructions below, running all commands from the root of your project.

```shell
npm install @remix-run/react @remix-run/node @remix-run/serve
npm install -D @remix-run/dev
```

## Creating server and browser entrypoints

Most React Router apps run primarily in the browser. The server's only job is to send a single static HTML page while React Router manages the route-based views client-side. These apps generally have a browser entrypoint file like a root `index.js` that looks something like this:

```tsx filename=index.tsx
import { render } from 'react-dom';

import App from './App';

render(<App />, document.getElementById('app'));
```

Server-rendered React apps are a little different. The browser script is not rendering your app, but is "hydrating" the DOM provided by the server. Hydration is the process of mapping the elements in the DOM to their React component counterparts and setting up event listeners so that your app is interactive.

Let's start by creating two new files:

- `app/entry.server.tsx` (or `entry.server.jsx`)
- `app/entry.client.tsx` (or `entry.client.jsx`)

<docs-info>All of your app code in Remix will live in an `app` directory by convention. If your existing app uses a directory with the same name, rename it to something like `src` or `old-app` to differentiate as we migrate to Remix.</docs-info>

```tsx filename=app/entry.server.tsx
import { PassThrough } from 'node:stream';

import type { AppLoadContext, EntryContext } from '@remix-run/node';
import { createReadableStreamFromReadable } from '@remix-run/node';
import { RemixServer } from '@remix-run/react';
import { isbot } from 'isbot';
import { renderToPipeableStream } from 'react-dom/server';

const ABORT_DELAY = 5_000;

export default function handleRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext,
  loadContext: AppLoadContext,
) {
  return isbot(request.headers.get('user-agent') || '')
    ? handleBotRequest(request, responseStatusCode, responseHeaders, remixContext)
    : handleBrowserRequest(request, responseStatusCode, responseHeaders, remixContext);
}

function handleBotRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext,
) {
  return new Promise((resolve, reject) => {
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer context={remixContext} url={request.url} abortDelay={ABORT_DELAY} />,
      {
        onAllReady() {
          const body = new PassThrough();

          responseHeaders.set('Content-Type', 'text/html');

          resolve(
            new Response(createReadableStreamFromReadable(body), {
              headers: responseHeaders,
              status: responseStatusCode,
            }),
          );

          pipe(body);
        },
        onShellError(error: unknown) {
          reject(error);
        },
        onError(error: unknown) {
          responseStatusCode = 500;
          console.error(error);
        },
      },
    );

    setTimeout(abort, ABORT_DELAY);
  });
}

function handleBrowserRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext,
) {
  return new Promise((resolve, reject) => {
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer context={remixContext} url={request.url} abortDelay={ABORT_DELAY} />,
      {
        onShellReady() {
          const body = new PassThrough();

          responseHeaders.set('Content-Type', 'text/html');

          resolve(
            new Response(createReadableStreamFromReadable(body), {
              headers: responseHeaders,
              status: responseStatusCode,
            }),
          );

          pipe(body);
        },
        onShellError(error: unknown) {
          reject(error);
        },
        onError(error: unknown) {
          console.error(error);
          responseStatusCode = 500;
        },
      },
    );

    setTimeout(abort, ABORT_DELAY);
  });
}
```

Your client entrypoint will look like this:

```tsx filename=app/entry.client.tsx
import { RemixBrowser } from '@remix-run/react';
import { startTransition, StrictMode } from 'react';
import { hydrateRoot } from 'react-dom/client';

startTransition(() => {
  hydrateRoot(
    document,
    <StrictMode>
      <RemixBrowser />
    </StrictMode>,
  );
});
```

## Creating The `root` route

We mentioned that Remix is built on top of React Router. Your app likely renders a `BrowserRouter` with your routes defined in JSX `Route` components. We don't need to do that in Remix, but more on that later. For now, we need to provide the lowest level route our Remix app needs to work.

The root route (or the "root root" if you're Wes Bos) is responsible for providing the structure of the application. Its default export is a component that renders the full HTML tree that every other route loads and depends on. Think of it as the scaffold or shell of your app.

In a client-rendered app, you will have an index HTML file that includes the DOM node for mounting your React app. The root route will render markup that mirrors the structure of this file.

Create a new file called `root.tsx` (or `root.jsx`) in your `app` directory. The contents of that file will vary, but let's assume that your `index.html` looks something like this:

```html filename=index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="My beautiful React app" />
    <link rel="apple-touch-icon" href="/logo192.png" />
    <link rel="manifest" href="/manifest.json" />
    <title>My React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
```

In your `root.tsx`, export a component that mirrors its structure:

```tsx filename=app/root.tsx
import { Outlet } from '@remix-run/react';

export default function Root() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <link rel="icon" href="/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="theme-color" content="#000000" />
        <meta name="description" content="My beautiful React app" />
        <link rel="apple-touch-icon" href="/logo192.png" />
        <link rel="manifest" href="/manifest.json" />
        <title>My React App</title>
      </head>
      <body>
        <div id="root">
          <Outlet />
        </div>
      </body>
    </html>
  );
}
```

Notice a few things here:

- We got rid of the `noscript` tag. We're server rendering now, which means users who disable JavaScript will still be able to see our app (and over time, as you make [a few tweaks to improve progressive enhancement][a-few-tweaks-to-improve-progressive-enhancement], much of your app should still work).
- Inside the root element we render an `Outlet` component from `@remix-run/react`. This is the same component that you would normally use to render your matched route in a React Router app; it serves the same function here, but it's adapted for the router in Remix.

<docs-warning><strong>Important:</strong> be sure to delete the `index.html` from your `public` directory after you've created your root route. Keeping the file around may cause your server to send that HTML instead of your Remix app when accessing the `/` route.</docs-warning>

## Adapting your existing app code

First, move the root of your existing React code into your `app` directory. So if your root app code lives in an `src` directory in the project root, it should now be in `app/src`.

We also suggest renaming this directory to make it clear that this is your old code so that, eventually, you can delete it after migrating all of its contents. The beauty of this approach is that you don't have to do it all at once for your app to run as usual. In our demo project we name this directory `old-app`.

Lastly, in your root `App` component (the one that would have been mounted to the `root` element), remove the `<BrowserRouter>` from React Router. Remix takes care of this for you without needing to render the provider directly.

## Creating an index and a catch-all route

Remix needs routes beyond the root route to know what to render in `<Outlet />`. Fortunately you already render `<Route>` components in your app, and Remix can use those as you migrate to use our [routing conventions][routing-conventions].

To start, create a new directory in `app` called `routes`. In that directory, create two files called `_index.tsx` and `$.tsx`. `$.tsx` is called [a **catch-all or "splat" route**][a-catch-all-route], and it will be useful to let your old app handle routes that you haven't moved into the `routes` directory yet.

Inside your `_index.tsx` and `$.tsx` files, all we need to do is export the code from our old root `App`:

```tsx filename=app/routes/_index.tsx
export { default } from '@/old-app/app';
```

```tsx filename=app/routes/$.tsx
export { default } from '@/old-app/app';
```

## Replacing the bundler with Remix

Remix provides its own bundler and CLI tools for development and building your app. Chances are your app used something like Create React App to bootstrap, or perhaps you have a custom build set up with Webpack.

In your `package.json` file, update your scripts to use `remix` commands instead of your current build and dev scripts.

```json filename=package.json
{
  "scripts": {
    "build": "remix build",
    "dev": "remix dev",
    "start": "remix-serve build/index.js",
    "typecheck": "tsc"
  }
}
```

And poof! Your app is now server-rendered and your build went from 90 seconds to 0.5 seconds ‚ö°

## Creating your routes

Over time, you'll want to migrate the routes rendered by React Router's `<Route>` components into their own route files. The filenames and directory structure outlined in our [routing conventions][routing-conventions] will guide this migration.

The default export in your route file is the component rendered in the `<Outlet />`. So if you have a route in your `App` that looks like this:

```tsx filename=app/old-app/app.tsx
function About() {
  return (
    <main>
      <h1>About us</h1>
      <PageContent />
    </main>
  );
}

function App() {
  return (
    <Routes>
      <Route path="/about" element={<About />} />
    </Routes>
  );
}
```

Your route file should look like this:

```tsx filename=app/routes/about.tsx
export default function About() {
  return (
    <main>
      <h1>About us</h1>
      <PageContent />
    </main>
  );
}
```

Once you create this file, you can delete the `<Route>` component from your `App`. After all of your routes have been migrated you can delete `<Routes>` and ultimately all the code in `old-app`.

## Gotchas and next steps

At this point you _might_ be able to say you are done with the initial migration. Congrats! However, Remix does things a bit differently than your typical React app. If it didn't, why would we have bothered building it in the first place? üòÖ

### Unsafe browser references

A common pain-point in migrating a client-rendered codebase to a server-rendered one is that you may have references to browser APIs in code that runs on the server. A common example can be found when initializing values in state:

```tsx
function Count() {
  const [count, setCount] = React.useState(() => localStorage.getItem('count') || 0);

  React.useEffect(() => {
    localStorage.setItem('count', count);
  }, [count]);

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

In this example, `localStorage` is used as a global store to persist some data across page reloads. We update `localStorage` with the current value of `count` in `useEffect`, which is perfectly safe because `useEffect` is only ever called in the browser! However, initializing state based on `localStorage` is a problem, as this callback is executed on both the server and in the browser.

Your go-to solution may be to check for the `window` object and only run the callback in the browser. However, this can lead to another problem, which is the dreaded [hydration mismatch][hydration-mismatch]. React relies on markup rendered by the server to be identical to what is rendered during client hydration. This ensures that `react-dom` knows how to match DOM elements with their corresponding React components so that it can attach event listeners and perform updates as state changes. So if local storage gives us a different value than whatever we initiate on the server, we'll have a new problem to deal with.

#### Client-only components

One potential solution here is using a different caching mechanism that can be used on the server and passed to the component via props passed from a route's [loader data][loader-data]. But if it isn't crucial for your app to render the component on the server, a simpler solution may be to skip rendering altogether on the server and wait until hydration is complete to render it in the browser.

```tsx
// We can safely track hydration in memory state
// outside of the component because it is only
// updated once after the version instance of
// `SomeComponent` has been hydrated. From there,
// the browser takes over rendering duties across
// route changes and we no longer need to worry
// about hydration mismatches until the page is
// reloaded and `isHydrating` is reset to true.
let isHydrating = true;

function SomeComponent() {
  const [isHydrated, setIsHydrated] = React.useState(!isHydrating);

  React.useEffect(() => {
    isHydrating = false;
    setIsHydrated(true);
  }, []);

  if (isHydrated) {
    return <Count />;
  } else {
    return <SomeFallbackComponent />;
  }
}
```

To simplify this solution, we recommend the using the [`ClientOnly` component][client-only-component] in the [`remix-utils`][remix-utils] community package. An example of its usage can be found in the [`examples` repository][examples-repository].

### `React.lazy` and `React.Suspense`

If you are lazy-loading components with [`React.lazy`][react-lazy] and [`React.Suspense`][react-suspense], you may run into issues depending on the version of React you are using. Until React 18, this would not work on the server as `React.Suspense` was originally implemented as a browser-only feature.

If you are using React 17, you have a few options:

- Upgrade to React 18
- Use the [client-only approach][client-only-approach] outlined above
- Use an alternative lazy-loading solution such as [Loadable Components][loadable-components]
- Remove `React.lazy` and `React.Suspense` altogether

Keep in mind that Remix automatically handles code-splitting for all your routes that it manages, so as you move things into the `routes` directory you should rarely‚Äîif ever‚Äîneed to use `React.lazy` manually.

### Configuration

Further configuration is optional, but the following may be helpful to optimize your development workflow.

#### `remix.config.js`

Every Remix app accepts a `remix.config.js` file in the project root. While its settings are optional, we recommend you include a few of them for clarity's sake. See the [docs on configuration][docs-on-configuration] for more information about all available options.

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  appDirectory: 'app',
  ignoredRouteFiles: ['**/*.css'],
  assetsBuildDirectory: 'public/build',
};
```

#### `jsconfig.json` or `tsconfig.json`

If you are using TypeScript, you likely already have a `tsconfig.json` in your project. `jsconfig.json` is optional but provides helpful context for many editors. These are the minimal settings we recommend including in your language configuration.

<docs-info>Remix uses the <code>~~/\_</code> path alias to easily import modules from the root no matter where your file lives in the project. If you change the `appDirectory` in your `remix.config.js`, you'll need to update your path alias for <code>~~/\_</code> as well.</docs-info>

```json filename=jsconfig.json
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "resolveJsonModule": true,
    "baseUrl": ".",
    "paths": {
      "~/*": ["./app/*"]
    }
  }
}
```

```json filename=tsconfig.json
{
  "include": ["remix.env.d.ts", "**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "isolatedModules": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "resolveJsonModule": true,
    "moduleResolution": "Bundler",
    "baseUrl": ".",
    "noEmit": true,
    "paths": {
      "~/*": ["./app/*"]
    }
  }
}
```

If you are using TypeScript, you also need to create the `remix.env.d.ts` file in the root of your project with the appropriate global type references.

```ts filename=remix.env.d.ts
/// <reference types="@remix-run/dev" />
/// <reference types="@remix-run/node" />
```

### A note about non-standard imports

At this point, you _might_ be able to run your app with no changes. If you are using Create React App or a highly-configured bundler setup, you likely use `import` to include non-JavaScript modules like stylesheets and images.

Remix does not support most non-standard imports, and we think for good reason. Below is a non-exhaustive list of some of the differences you'll encounter in Remix, and how to refactor as you migrate.

#### Asset imports

Many bundlers use plugins to allow importing various assets like images and fonts. These typically come into your component as string representing the filepath of the asset.

```tsx
import logo from './logo.png';

export function Logo() {
  return <img src={logo} alt="My logo" />;
}
```

In Remix, this works basically the same way. For assets like fonts that are loaded by a `<link>` element, you'll generally import these in a route module and include the filename in an object returned by a `links` function. [See our docs on route `links` for more information.][see-our-docs-on-route-links-for-more-information]

#### SVG imports

Create React App and some other build tools allow you to import SVG files as a React component. This is a common use case for SVG files, but it's not supported by default in Remix.

```tsx bad nocopy
// This will not work in Remix!
import MyLogo from './logo.svg';

export function Logo() {
  return <MyLogo />;
}
```

If you want to use SVG files as React components, you'll need to first create the components and import them directly. [React SVGR][react-svgr] is a great toolset that can help you generate these components from the [command line][command-line] or in an [online playground][online-playground] if you prefer to copy and paste.

```svg filename=icon.svg
<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 20 20" fill="currentColor">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 0l-3 3a1 1 0 001.414 1.414L9 9.414V13a1 1 0 102 0V9.414l1.293 1.293a1 1 0 001.414-1.414z" />
</svg>
```

```tsx filename=icon.tsx good
export default function Icon() {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="icon"
      viewBox="0 0 20 20"
      fill="currentColor"
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 0l-3 3a1 1 0 001.414 1.414L9 9.414V13a1 1 0 102 0V9.414l1.293 1.293a1 1 0 001.414-1.414z"
      />
    </svg>
  );
}
```

#### CSS imports

Create React App and many other build tools support importing CSS in your components in various ways. Remix supports importing regular CSS files along with several popular CSS bundling solutions described below.

### Route `links` exports

In Remix, regular stylesheets can be loaded from route component files. Importing them does not do anything magical with your styles, rather it returns a URL that can be used to load the stylesheet as you see fit. You can render the stylesheet directly in your component or use our [`links` export][see-our-docs-on-route-links-for-more-information].

Let's move our app's stylesheet and a few other assets to the `links` function in our root route:

```tsx filename=app/root.tsx lines=[2,5,7-16,32]
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno
import { Links } from '@remix-run/react';

import App from './app';
import stylesheetUrl from './styles.css';

export const links: LinksFunction = () => {
  // `links` returns an array of objects whose
  // properties map to the `<link />` component props
  return [
    { rel: 'icon', href: '/favicon.ico' },
    { rel: 'apple-touch-icon', href: '/logo192.png' },
    { rel: 'manifest', href: '/manifest.json' },
    { rel: 'stylesheet', href: stylesheetUrl },
  ];
};

export default function Root() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="theme-color" content="#000000" />
        <meta name="description" content="Web site created using create-react-app" />
        <Links />
        <title>React App</title>
      </head>
      <body>
        <App />
      </body>
    </html>
  );
}
```

You'll notice on line 32 that we've rendered a `<Links />` component that replaced all of our individual `<link />` components. This is inconsequential if we only ever use links in the root route, but all child routes may export their own links that will also be rendered here. The `links` function can also return a [`PageLinkDescriptor` object][page-link-descriptor-object] that allows you to prefetch the resources for a page the user is likely to navigate to.

If you currently inject `<link />` tags into your page client-side in your existing route components, either directly or via an abstraction like [`react-helmet`][react-helmet], you can stop doing that and instead use the `links` export. You get to delete a lot of code and possibly a dependency or two!

### CSS bundling

Remix has built-in support for [CSS Modules][css-modules], [Vanilla Extract][vanilla-extract] and [CSS side effect imports][css-side-effect-imports]. In order to make use of these features, you'll need to set up CSS bundling in your application.

First, to get access to the generated CSS bundle, install the `@remix-run/css-bundle` package.

```sh
npm install @remix-run/css-bundle
```

Then, import `cssBundleHref` and add it to a link descriptor‚Äîmost likely in `root.tsx` so that it applies to your entire application.

```tsx filename=root.tsx lines=[2,6-8]
import { cssBundleHref } from '@remix-run/css-bundle';
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

export const links: LinksFunction = () => {
  return [
    ...(cssBundleHref ? [{ rel: 'stylesheet', href: cssBundleHref }] : []),
    // ...
  ];
};
```

[See our docs on CSS bundling for more information.][css-bundling]

<docs-info>

**Note:** Remix does not currently support Sass/Less processing directly, but you can still run those as a separate process to generate CSS files that can then be imported into your Remix app.

</docs-info>

### Rendering components in `<head>`

Just as a `<link>` is rendered inside your route component and ultimately rendered in your root `<Links />` component, your app may use some injection trickery to render additional components in the document `<head>`. Often this is done to change the document's `<title>` or `<meta>` tags.

Similar to `links`, each route can also export a `meta` function that returns values responsible for rendering `<meta>` tags for that route (as well as a few other tags relevant for metadata, such as `<title>`, `<link rel="canonical">` and `<script type="application/ld+json">`).

The behavior for `meta` is slightly different from `links`. Instead of merging values from other `meta` functions in the route hierarchy, **each leaf route is responsible for rendering its own tags**. This is because:

- You often want more fine-grained control over metadata for optimal SEO
- In the case of some tags that follow the [Open Graph protocol][open-graph-protocol], the ordering of some tags impacts how they are interpreted by crawlers and social media sites, and it's less predictable for Remix to assume how complex metadata should be merged
- Some tags allow for multiple values while others do not, and Remix shouldn't assume how you want to handle all of those cases

### Updating imports

Remix re-exports everything you get from `react-router-dom` and we recommend that you update your imports to get those modules from `@remix-run/react`. In many cases, those components are wrapped with additional functionality and features specifically optimized for Remix.

**Before:**

```tsx bad nocopy
import { Link, Outlet } from 'react-router-dom';
```

**After:**

```tsx good
import { Link, Outlet } from '@remix-run/react';
```

## Final Thoughts

While we've done our best to provide a comprehensive migration guide, it's important to note that we built Remix from the ground up with a few key principles that differ significantly from how many React apps are currently built. While your app will likely run at this point, as you dig through our docs and explore our APIs, we think you'll be able to drastically reduce the complexity of your code and improve the end-user experience of your app. It might take a bit of time to get there, but you can eat that elephant one bite at a time.

Now then, go off and _remix your app_. We think you'll like what you build along the way! üíø

### Further reading

- [Remix philosophy][remix-philosophy]
- [Remix technical explanation][remix-technical-explanation]
- [Data loading in Remix][data-loading-in-remix]
- [Routing in Remix][routing-in-remix]
- [Styling in Remix][styling-in-remix]
- [Frequently asked questions][frequently-asked-questions]
- [Common "gotchas"][common-gotchas]

[react-router]: https://reactrouter.com
[react-router-docs]: https://reactrouter.com/v6/start/concepts
[migration-guide-from-v5-to-v6]: https://reactrouter.com/en/6.22.3/upgrading/v5
[backwards-compatibility-package]: https://www.npmjs.com/package/react-router-dom-v5-compat
[a-few-tweaks-to-improve-progressive-enhancement]: ../pages/philosophy#progressive-enhancement
[routing-conventions]: ./routing
[a-catch-all-route]: ../file-conventions/routes#splat-routes
[hydration-mismatch]: https://reactjs.org/docs/react-dom.html#hydrate
[loader-data]: ../route/loader
[client-only-component]: https://github.com/sergiodxa/remix-utils/blob/main/src/react/client-only.tsx
[remix-utils]: https://www.npmjs.com/package/remix-utils
[examples-repository]: https://github.com/remix-run/examples/blob/main/client-only-components/app/routes/_index.tsx
[react-lazy]: https://reactjs.org/docs/code-splitting.html#reactlazy
[react-suspense]: https://reactjs.org/docs/react-api.html#reactsuspense
[client-only-approach]: #client-only-components
[loadable-components]: https://loadable-components.com/docs/loadable-vs-react-lazy
[docs-on-configuration]: ../file-conventions/remix-config
[see-our-docs-on-route-links-for-more-information]: ../route/links
[react-svgr]: https://react-svgr.com
[command-line]: https://react-svgr.com/docs/cli
[online-playground]: https://react-svgr.com/playground
[page-link-descriptor-object]: ../route/links#pagelinkdescriptor
[react-helmet]: https://www.npmjs.com/package/react-helmet
[remix-philosophy]: ../pages/philosophy
[remix-technical-explanation]: ../pages/technical-explanation
[data-loading-in-remix]: ./data-loading
[routing-in-remix]: ./routing
[styling-in-remix]: ./styling
[frequently-asked-questions]: ../pages/faq
[common-gotchas]: ../pages/gotchas
[css-modules]: ./styling#css-modules
[vanilla-extract]: ./styling#vanilla-extract
[css-side-effect-imports]: ./styling#css-side-effect-imports
[css-bundling]: ./styling#css-bundling
[open-graph-protocol]: https://ogp.me
[classic-remix-compiler]: ./vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ./vite

---

## File: ./guides/not-found.md

---

## title: Not Found Handling

# Not Found (404) Handling

When a document isn't found on a web server, it should send a [404 status code][404-status-code]. This indicates to machines that the document is not there: search engines won't index it, CDNs won't cache it, etc. Most SPAs today just serve everything as 200 whether the page exists or not, but for you that stops today!

There are two primary cases where a Remix site should send a 404:

- The URL doesn't match any routes in the app
- Your loader didn't find any data

The first case is already handled by Remix, you don't have to throw a response yourself. It knows your routes, so it knows if nothing matched (_consider using a [Splat Route][splat-route] to handle this case_). The second case is up to you, but it's really easy.

## How to Send a 404

As soon as you know you don't have what the user is looking for you should _throw a response_.

```tsx filename=app/routes/page.$slug.tsx
export async function loader({ params }: LoaderFunctionArgs) {
  const page = await db.page.findOne({
    where: { slug: params.slug },
  });

  if (!page) {
    throw new Response(null, {
      status: 404,
      statusText: 'Not Found',
    });
  }

  return json(page);
}
```

Remix will catch the response and send your app down the [Error Boundary][error-boundary] path. It's actually exactly like Remix's automatic [error handling][errors], but instead of receiving an `Error` from `useRouteError()`, you'll receive an object with your response `status`, `statusText`, and extracted `data`.

What's nice about throwing a response is that code in your loader _stops executing_. The rest of your code doesn't have to deal with the chance that the page is defined or not (this is especially handy for TypeScript).

Throwing also ensures that your route component doesn't render if the loader wasn't successful. Your route components only have to consider the "happy path". They don't need pending states, error states, or in our case here, not-found states.

## Root Error Boundary

You probably already have one at the root of your app. This will handle all thrown responses that weren't handled in a nested route. Here's a sample:

```tsx
export function ErrorBoundary() {
  const error = useRouteError();
  return (
    <html>
      <head>
        <title>Oops!</title>
        <Meta />
        <Links />
      </head>
      <body>
        <h1>
          {isRouteErrorResponse(error)
            ? `${error.status} ${error.statusText}`
            : error instanceof Error
              ? error.message
              : 'Unknown Error'}
        </h1>
        <Scripts />
      </body>
    </html>
  );
}
```

[error-boundary]: ../route/error-boundary
[errors]: ./errors
[404-status-code]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404
[splat-route]: ../file-conventions/routes#splat-routes

---

## File: ./guides/performance.md

---

## title: Performance

# Performance

<docs-warning>This document is in draft, we will be adding more practical information soon, but we wanted to communicate our approach early.</docs-warning>

Instead of prescribing a precise architecture with all of its constraints like SSG, Remix is designed to encourage you to leverage the performance characteristics of distributed computing.

The fastest thing to send to a user is, of course, a static document on a CDN that's close to the user. Until recently, servers pretty much only ran in one region of the world, which made for slow responses everywhere else. This is perhaps one reason SSG gained so much popularity, it allowed developers to essentially "cache" their data into HTML documents and then distribute them across the world. It comes with a lot of tradeoffs too: build times, build complexity, duplicate websites for translations, can't use it for authenticated user experiences, can't use it for very large and dynamic data sources (like our project [unpkg.com][unpkg-com]!) to name a few.

## The Edge

(No, not the U2 guy.)

Today, there are a lot of exciting things happening with distributed computing "at the edge". Computing "at the edge" generally means running code on servers close to users instead of just one place (like the US East Coast). We're not only seeing more of this, but we're seeing distributed databases moving to the edge as well. We've been anticipating all of this for a while, that's why Remix is designed the way it is.

With distributed servers and databases running at the edge, it's now possible to serve dynamic content at speeds comparable to static files. **You can make your server fast, but you can't do anything about the users network**. The only thing left to do is get code out of your browser bundles and onto the server, sending fewer bytes over the network, and provide unparalleled web performance. That's what Remix is designed to do.

## This Website + Fly.io

This very website has a time to first byte that's hard to beat. For most people in the world it's under 100ms. We can fix a typo in the docs and within a minute or two the site is updated across the world without a rebuild, without a redeploy, and without HTTP caching.

We accomplished this with distributed systems. The app runs in several regions on [Fly][fly] around the world so it's close to you. Each instance has its own SQLite database. When the app boots, it fetches tarballs from the Remix source repository on GitHub, processes the markdown docs into HTML and then inserts them into the SQLite database.

The code involved is actually really similar to what a Gatsby site might do at build time in `gatsby-node.js` or `getStaticProps` in Next.js. The idea is to take the slow parts (fetching docs from GitHub, processing markdown) and cache it (SSG caches into HTML, this website caches into SQLite on the server).

When users request a page, the app queries its local SQLite database and sends the page. Our server is done with these requests in a few milliseconds. What's most interesting about this architecture is that we don't have to sacrifice speed for freshness. When we edit a doc on GitHub, a GitHub action calls a webhook on the nearest app instance, which then replays that request to all of the other instances across the world. Then they all pull the new tarball from GitHub and sync their database with the docs just like they did when they booted. The docs are updated within a minute or two across the world.

But this is just one approach that we wanted to explore.

## Cloudflare Workers

[Remix Cloudflare Workers Demo][remix-cloudflare-workers-demo]

Cloudflare has been pushing the boundaries of edge computing for a while now and Remix is positioned to take full advantage of it. You can see our demo's response times are the same as serving static files but the features it demonstrates are definitely not static!

Not only does Cloudflare run the app close to the user, they also have persistent storage systems like [KV][kv] and [Durable Objects][durable-objects] to allow SSG-level speed without the handcuffs of coupling data to deploys and bespoke, incremental-builder backends.

There are other similar platforms that we've got plans to support soon.

## Bundle analysis

<docs-warning>This documentation is only relevant when using the [Classic Remix Compiler][classic-remix-compiler]</docs-warning>

Remix outputs metafiles to the server build directory (`build/` by default) so you can analyze your bundle size and composition.

- `metafile.css.json` : Metafile for the CSS bundle
- `metafile.js.json` : Metafile for the browser JS bundle
- `metafile.server.json` : Metafile for the serve JS bundle

Remix uses esbuild's metafile format so you can directly upload those files to [https://esbuild.github.io/analyze/][https-esbuild-github-io-analyze] to visualize your bundle.

## Other Technologies

Here are some other technologies to help speed up your servers:

- [FaunaDB][fauna-db] - A distributed database that runs close to your users
- [LRU Cache][lru-cache] - An in-memory cache that automatically clears out more space when it gets full
- [Redis][redis] - A tried and true server-side cache

[unpkg-com]: https://unpkg.com
[fly]: https://fly.io
[remix-cloudflare-workers-demo]: https://remix-cloudflare-demo.jacob-ebey.workers.dev
[kv]: https://developers.cloudflare.com/workers/learning/how-kv-works
[durable-objects]: https://blog.cloudflare.com/introducing-workers-durable-objects
[fauna-db]: https://fauna.com
[lru-cache]: https://www.npmjs.com/package/lru-cache
[redis]: https://www.npmjs.com/package/redis
[https-esbuild-github-io-analyze]: https://esbuild.github.io/analyze
[classic-remix-compiler]: ./vite#classic-remix-compiler-vs-remix-vite

---

## File: ./guides/presets.md

---

## title: Presets

# Presets

The [Remix Vite plugin][remix-vite] supports a `presets` option to ease integration with other tools and hosting providers.

Presets can only do two things:

- Configure the Remix Vite plugin on your behalf.
- Validate the resolved config.

The config returned by each preset is merged in the order they were defined. Any config directly passed to the Remix Vite plugin will be merged last. This means that user config will always take precedence over any presets.

## Creating a preset

Presets conform to the following `Preset` type:

```ts
type Preset = {
  name: string;

  remixConfig?: (args: {
    remixUserConfig: VitePluginConfig;
  }) => RemixConfigPreset | Promise<RemixConfigPreset>;

  remixConfigResolved?: (args: { remixConfig: ResolvedVitePluginConfig }) => void | Promise<void>;
};
```

### Defining preset config

As a basic example, let's create a preset that configures a [server bundles function][server-bundles]:

```ts filename=my-cool-preset.ts
import type { Preset } from '@remix-run/dev';

export function myCoolPreset(): Preset {
  return {
    name: 'my-cool-preset',
    remixConfig: () => ({
      serverBundles: ({ branch }) => {
        const isAuthenticatedRoute = branch.some((route) =>
          route.id.split('/').includes('_authenticated'),
        );

        return isAuthenticatedRoute ? 'authenticated' : 'unauthenticated';
      },
    }),
  };
}
```

### Validating config

It's important to remember that other presets and user config can still override the values returned from your preset.

In our example preset, the `serverBundles` function could be overridden with a different, conflicting implementation. If we want to validate that the final resolved config contains the `serverBundles` function from our preset, we can do this with the `remixConfigResolved` hook:

```ts filename=my-cool-preset.ts lines=[22-26]
import type { Preset, ServerBundlesFunction } from '@remix-run/dev';

const serverBundles: ServerBundlesFunction = ({ branch }) => {
  const isAuthenticatedRoute = branch.some((route) =>
    route.id.split('/').includes('_authenticated'),
  );

  return isAuthenticatedRoute ? 'authenticated' : 'unauthenticated';
};

export function myCoolPreset(): Preset {
  return {
    name: 'my-cool-preset',
    remixConfig: () => ({ serverBundles }),
    remixConfigResolved: ({ remixConfig }) => {
      if (remixConfig.serverBundles !== serverBundles) {
        throw new Error('`serverBundles` was overridden!');
      }
    },
  };
}
```

The `remixConfigResolved` hook should only be used in cases where it would be an error to merge or override your preset's config.

## Using a preset

Presets are designed to be published to npm and used within your Vite config.

```ts filename=vite.config.ts lines=[3,8]
import { vitePlugin as remix } from '@remix-run/dev';
import { myCoolPreset } from 'remix-preset-cool';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [
    remix({
      presets: [myCoolPreset()],
    }),
  ],
});
```

[remix-vite]: ./vite
[server-bundles]: ./server-bundles

---

## File: ./guides/progressive-enhancement.md

---

title: Progressive Enhancement
hidden: true

---

# Progressive Enhancement

---

## File: ./guides/resource-routes.md

---

## title: Resource Routes

# Resource Routes

Resource Routes are not part of your application UI, but are still part of your application. They can send any kind of Response.

Most routes in Remix are UI Routes, or routes that actually render a component. But routes don't always have to render components. There are a handful of cases where you want to use route as a general-purpose endpoint to your website. Here are a few examples:

- JSON API for a mobile app that reuses server-side code with the Remix UI
- Dynamically generating PDFs
- Dynamically generating social images for blog posts or other pages
- Webhooks for other services like Stripe or GitHub
- a CSS file that dynamically renders custom properties for a user's preferred theme

## Creating Resource Routes

If a route doesn't export a default component, it can be used as a Resource Route. If called with `GET`, the loader's response is returned and none of the parent route loaders are called either (because those are needed for the UI, but this is not the UI). If called with `POST`, the action's response is called.

For example, consider a UI Route that renders a report, note the link:

```tsx filename=app/routes/reports.$id.tsx lines=[12-14]
export async function loader({ params }: LoaderFunctionArgs) {
  return json(await getReport(params.id));
}

export default function Report() {
  const report = useLoaderData<typeof loader>();
  return (
    <div>
      <h1>{report.name}</h1>
      <Link to="pdf" reloadDocument>
        View as PDF
      </Link>
      {/* ... */}
    </div>
  );
}
```

It's linking to a PDF version of the page. To make this work we can create a Resource Route below it. Notice that it has no component: that makes it a Resource Route.

```tsx filename=app/routes/reports.$id[.pdf].tsx
export async function loader({ params }: LoaderFunctionArgs) {
  const report = await getReport(params.id);
  const pdf = await generateReportPDF(report);
  return new Response(pdf, {
    status: 200,
    headers: {
      'Content-Type': 'application/pdf',
    },
  });
}
```

When the user clicks the link from the UI route, they will navigate to the PDF.

## Linking to Resource Routes

<docs-error>It‚Äôs imperative that you use <code>reloadDocument</code> on any Links to Resource Routes</docs-error>

There's a subtle detail to be aware of when linking to resource routes. You need to link to it with `<Link reloadDocument>` or a plain `<a href>`. If you link to it with a normal `<Link to="pdf">` without `reloadDocument`, then the resource route will be treated as a UI route. Remix will try to get the data with `fetch` and render the component. Don't sweat it too much, you'll get a helpful error message if you make this mistake.

## URL Escaping

You'll probably want to add a file extension to your resource routes. This is tricky because one of Remix's route file naming conventions is that `.` becomes `/` so you can nest the URL without nesting the UI.

To add a `.` to a route's path, use the `[]` escape characters. Our PDF route file name would change like so:

```sh
# original
# /reports/123/pdf
app/routes/reports.$id.pdf.ts

# with a file extension
# /reports/123.pdf
app/routes/reports.$id[.pdf].ts

# or like this, the resulting URL is the same
app/routes/reports.$id[.]pdf.ts
```

## Handling different request methods

To handle `GET` requests export a loader function:

```tsx
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno

export const loader = async ({ request }: LoaderFunctionArgs) => {
  // handle "GET" request

  return json({ success: true }, 200);
};
```

To handle `POST`, `PUT`, `PATCH` or `DELETE` requests export an action function:

```tsx
import type { ActionFunctionArgs } from '@remix-run/node'; // or cloudflare/deno

export const action = async ({ request }: ActionFunctionArgs) => {
  switch (request.method) {
    case 'POST': {
      /* handle "POST" */
    }
    case 'PUT': {
      /* handle "PUT" */
    }
    case 'PATCH': {
      /* handle "PATCH" */
    }
    case 'DELETE': {
      /* handle "DELETE" */
    }
  }
};
```

## Webhooks

Resource routes can be used to handle webhooks. For example, you can create a webhook that receives notifications from GitHub when a new commit is pushed to a repository:

```tsx
import crypto from 'node:crypto';

import type { ActionFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno

export const action = async ({ request }: ActionFunctionArgs) => {
  if (request.method !== 'POST') {
    return json({ message: 'Method not allowed' }, 405);
  }
  const payload = await request.json();

  /* Validate the webhook */
  const signature = request.headers.get('X-Hub-Signature-256');
  const generatedSignature = `sha256=${crypto
    .createHmac('sha256', process.env.GITHUB_WEBHOOK_SECRET)
    .update(JSON.stringify(payload))
    .digest('hex')}`;
  if (signature !== generatedSignature) {
    return json({ message: 'Signature mismatch' }, 401);
  }

  /* process the webhook (e.g. enqueue a background job) */

  return json({ success: true }, 200);
};
```

---

## File: ./guides/server-bundles.md

---

## title: Server Bundles

# Server Bundles

<docs-warning>This is an advanced feature designed for hosting provider integrations. When compiling your app into multiple server bundles, there will need to be a custom routing layer in front of your app directing requests to the correct bundle.</docs-warning>

Remix typically builds your server code into a bundle that exposes a single request handler function. However, there are some scenarios where you might want to split your route tree into multiple server bundles that expose a request handler function for a subset of routes. To provide this level of flexibility, the [Remix Vite plugin][remix-vite] supports an `serverBundles` option which is a function for assigning routes to different server bundles.

The provided `serverBundles` function is called for each route in the tree (except for routes that aren't addressable, e.g. pathless layout routes) and returns a server bundle ID that you'd like to assign it to. These bundle IDs will be used as directory names in your server build directory.

For each route, this function is passed an array of routes leading to and including that route, referred to as the route `branch`. This allows you to create server bundles for different portions of the route tree. For example, you could use this to create a separate server bundle containing all routes within a particular layout route:

```ts filename=vite.config.ts lines=[7-15]
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [
    remix({
      serverBundles: ({ branch }) => {
        const isAuthenticatedRoute = branch.some((route) =>
          route.id.split('/').includes('_authenticated'),
        );

        return isAuthenticatedRoute ? 'authenticated' : 'unauthenticated';
      },
    }),
  ],
});
```

Each `route` in the `branch` array contains the following properties:

- `id` ‚Äî The unique ID for this route, named like its `file` but relative to the app directory and without the extension, e.g. `app/routes/gists.$username.tsx` will have an `id` of `routes/gists.$username`.
- `path` ‚Äî The path this route uses to match on the URL pathname.
- `file` ‚Äî The absolute path to the entry point for this route.
- `index` ‚Äî Whether or not this route is an index route.

## Build manifest

When the build is complete, Remix will call the Vite plugin's `buildEnd` hook passing a `buildManifest` object. This is useful if you need to inspect the build manifest to determine how to route requests to the correct server bundle.

```ts filename=vite.config.ts lines=[8-10]
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [
    remix({
      // ...
      buildEnd: async ({ buildManifest }) => {
        // ...
      },
    }),
  ],
});
```

When using server bundles, the build manifest contains the following properties:

- `serverBundles` ‚Äî An object that maps bundle IDs to the bundle's `id` and `file`.
- `routeIdToServerBundleId` ‚Äî An object that maps route IDs to its server bundle ID.
- `routes` ‚Äî A route manifest that maps route IDs to route metadata. This can be used to drive a custom routing layer in front of your Remix request handlers.

Alternatively, you can enable the `manifest` option on the Vite plugin to write this build manifest object to disk as `.remix/manifest.json` in your build directory.

[remix-vite]: ./vite
[pathless-layout-route]: ../file-conventions/routes#nested-layouts-without-nested-urls

---

## File: ./guides/single-fetch.md

---

## title: Single Fetch

# Single Fetch

Single Fetch is a new data loading strategy and streaming format. When you enable Single Fetch, Remix will make a single HTTP call to your server on client-side transitions, instead of multiple HTTP calls in parallel (one per loader). Additionally, Single Fetch also allows you to send down naked objects from your `loader` and `action`, such as `Date`, `Error`, `Promise`, `RegExp`, and more.

## Overview

Remix introduced support for "Single Fetch" ([RFC][rfc]) behind the [`future.unstable_singleFetch`][future-flags] flag in [`v2.9.0`][2.9.0] (later stabilized as `future.v3_singleFetch` in [`v2.13.0`][2.13.0]) which allows you to opt-into this behavior. Single Fetch will be the default in [React Router v7][merging-remix-and-rr].

Enabling Single Fetch is intended to be low-effort up-front, and then allow you to adopt all breaking changes iteratively over time. You can start by applying the minimal required changes to [enable Single Fetch][start], then use the [migration guide][migration-guide] to make incremental changes in your application to ensure a smooth, non-breaking upgrade to [React Router v7][merging-remix-and-rr].

Please also review the [Breaking Changes][breaking-changes] so you can be aware of some of the underlying behavior changes, specifically around serialization and status/header behavior.

## Enabling Single Fetch

**1. Enable the future flag**

```ts filename=vite.config.ts lines=[6]
export default defineConfig({
  plugins: [
    remix({
      future: {
        // ...
        v3_singleFetch: true,
      },
    }),
    // ...
  ],
});
```

**2. Deprecated `fetch` polyfill**

Single Fetch requires using [`undici`][undici] as your `fetch` polyfill, or using the built-in `fetch` on Node 20+, because it relies on APIs available there that are not in the `@remix-run/web-fetch` polyfill. Please refer to the [Undici][undici-polyfill] section in the 2.9.0 release notes below for more details.

- If you are using Node 20+, remove any calls to `installGlobals()` and use Node's built-in `fetch` (this is the same thing as `undici`).

- If you are managing your own server and calling `installGlobals()`, you will need to call `installGlobals({ nativeFetch: true })` to use `undici`.

  ```diff
  - installGlobals();
  + installGlobals({ nativeFetch: true });
  ```

- If you are using `remix-serve`, it will use `undici` automatically if Single Fetch is enabled.

- If you are using miniflare/cloudflare worker with your remix project, ensure your [compatibility flag][compatibility-flag] is set to `2023-03-01` or later as well.

**3. Adjust `headers` implementations (if necessary)**

With Single Fetch enabled, there will now only be one request made on client-side navigations even when multiple loaders need to run. To handle merging headers for the handlers called, the [`headers`][headers] export will now also apply to `loader`/`action` data requests. In many cases, the logic you already have in there for document requests should be close to sufficient for your new Single Fetch data requests.

```diff
-import { json } from "@remix-run/node";
+import { data } from "@remix-run/node";

// This example assumes you already have a headers function to handle header
// merging for your document requests
export function headers() {
  // ...
}

export async function loader({}: LoaderFunctionArgs) {
  let tasks = await fetchTasks();
-  return json(tasks, {
+  return data(tasks, {
    headers: {
      "Cache-Control": "public, max-age=604800"
    }
  });
}
```

‚ö†Ô∏è This is especially important to review for caching behaviors. Prior to Single Fetch, a given loader could choose it's own cache duration and it would apply to the singular HTTP response from that loader. But document requests would call multiple loaders and required an application to implement the `headers` method to intelligently merge headers returned from loaders across multiple routes. With Single fetch, document and data requests now behave the same so your `headers` function needs to return the proper headers/caching behavior for _all_ routes.

**4. Add a `nonce` (if you are using a CSP)**

If you have a [content security policy for scripts][csp] with [nonce-sources][csp-nonce], you will need to add that `nonce` to two places for the streaming Single Fetch implementation:

- `<RemixServer nonce={yourNonceValue}>` - this will add the `nonce` to the inline scripts rendered by this component that handle the streaming data on the client side
- In your `entry.server.tsx` in the `options.nonce` parameter to [`renderToPipeableStream`][rendertopipeablestream]/[`renderToReadableStream`][rendertoreadablestream]. See also the Remix [Streaming docs][streaming-nonce]

**5. Replace `renderToString` (if you are using it)**

For most Remix apps it's unlikely you're using `renderToString`, but if you have opted into using it in your `entry.server.tsx`, then continue reading, otherwise you can skip this step.

In order to maintain consistency between document and data requests, `turbo-stream` is also used as the format for sending down data in initial document requests. This means that once opted-into Single Fetch, your application can no longer use [`renderToString`][rendertostring] and must use a React streaming renderer API such as [`renderToPipeableStream`][rendertopipeablestream] or [`renderToReadableStream`][rendertoreadablestream]) in [`entry.server.tsx`][entry-server].

This does not mean you _have_ to stream down your HTTP response, you can still send the full document at once by leveraging the `onAllReady` option in `renderToPipeableStream`, or the `allReady` promise in `renderToReadableStream`.

On the client side, this also means that your need to wrap your client-side [`hydrateRoot`][hydrateroot] call in a [`startTransition`][starttransition] call because the streamed data will be coming down wrapped in a `Suspense` boundary.

## Breaking Changes

There are a handful of breaking changes introduced with Single Fetch - some of which you need to handle up-front when you enable the flag, and some you can handle incrementally after enabling the flag. You will need to ensure all of these have been handled prior to updating to the next major version.

**Changes that need to be addressed up front:**

- **Deprecated `fetch` polyfill**: The old `installGlobals()` polyfill doesn't work for Single Fetch, you must either use the native Node 20 `fetch` API or call `installGlobals({ nativeFetch: true })` in your custom server to get the [undici-based polyfill][undici-polyfill]
- **`headers` export applied to data requests**: The [`headers`][headers] function will now apply to both document and data requests

**Changes to be aware of that you may need to handle over-time:**

- **[New streaming Data format][streaming-format]**: Single fetch uses a new streaming format under the hood via [`turbo-stream`][turbo-stream], which means that we can stream down more complex data than just JSON
- **No more auto-serialization**: Naked objects returned from `loader` and `action` functions are no longer automatically converted into a JSON `Response` and are serialized as-is over the wire
- [**Updates to type inference**][type-inference-section]: To get the most accurate type inference, you should [augment][augment] Remix's `Future` interface with `v3_singleFetch: true`
- [**Default revalidation behavior changes to opt-out on GET navigations**][revalidation]: Default revalidation behavior on normal navigations changes from opt-in to opt-out and your server loaders will re-run by default
- [**Opt-in `action` revalidation**][action-revalidation]: Revalidation after an `action` `4xx`/`5xx` `Response` is now opt-in, versus opt-out

## Adding a New Route with Single Fetch

With Single Fetch enabled, you can go ahead and author routes that take advantage of the more powerful streaming format.

<docs-info>In order to get proper type inference, you need to [augment][augment] Remix's `Future` interface with `v3_singleFetch: true`. You can read more about this in the [Type Inference section][type-inference-section].</docs-info>

With Single Fetch you can return the following data types from your loader: `BigInt`, `Date`, `Error`, `Map`, `Promise`, `RegExp`, `Set`, `Symbol`, and `URL`.

```tsx
// routes/blog.$slug.tsx
import type { LoaderFunctionArgs } from '@remix-run/node';

export async function loader({ params }: LoaderFunctionArgs) {
  const { slug } = params;

  const comments = fetchComments(slug);
  const blogData = await fetchBlogData(slug);

  return {
    content: blogData.content, // <- string
    published: blogData.date, // <- Date
    comments, // <- Promise
  };
}

export default function BlogPost() {
  const blogData = useLoaderData<typeof loader>();
  //    ^? { content: string, published: Date, comments: Promise }

  return (
    <>
      <Header published={blogData.date} />
      <BlogContent content={blogData.content} />
      <Suspense fallback={<CommentsSkeleton />}>
        <Await resolve={blogData.comments}>
          {(comments) => <BlogComments comments={comments} />}
        </Await>
      </Suspense>
    </>
  );
}
```

## Migrating a Route with Single Fetch

If you are currently returning `Response` instances from your loaders (i.e., `json`/`defer`) then you shouldn't _need_ to make many changes to your app code to take advantage of Single Fetch.

However, to better prepare your upgrade to [React Router v7][merging-remix-and-rr] in the future, we recommend that you start making the following changes on a route-by-route basis, as that is the easiest way to validate that updating the headers and data types doesn't break anything.

### Type Inference

Without Single Fetch, any plain Javascript object returned from a `loader` or `action` is automatically serialized into a JSON response (as if you returned it via `json`). The type inference assumes this is the case and infers naked object returns as if they were JSON serialized.

With Single Fetch, naked objects will be streamed directly, so the built-in type inference is no longer accurate once you have opted-into Single Fetch. For example, they would assume that a `Date` would be serialized to a string on the client üòï.

#### Enable Single Fetch types

To switch over to Single Fetch types, you should [augment][augment] Remix's `Future` interface with `v3_singleFetch: true`.
You can do this in any file covered by your `tsconfig.json` > `include`.
We recommend you do this in your `vite.config.ts` to keep it colocated with the `future.v3_singleFetch` future flag in the Remix plugin:

```ts
declare module '@remix-run/server-runtime' {
  // or cloudflare, deno, etc.
  interface Future {
    v3_singleFetch: true;
  }
}
```

Now `useLoaderData`, `useActionData`, and any other utilities that use a `typeof loader` generic should be using Single Fetch types:

```ts
import { useLoaderData } from '@remix-run/react';

export function loader() {
  return {
    planet: 'world',
    date: new Date(),
  };
}

export default function Component() {
  const data = useLoaderData<typeof loader>();
  //    ^? { planet: string, date: Date }
}
```

#### Functions and class instances

In general, functions cannot be reliably sent over the network, so they get serialized as `undefined`:

```ts
import { useLoaderData } from '@remix-run/react';

export function loader() {
  return {
    planet: 'world',
    date: new Date(),
    notSoRandom: () => 7,
  };
}

export default function Component() {
  const data = useLoaderData<typeof loader>();
  //    ^? { planet: string, date: Date, notSoRandom: undefined }
}
```

Methods are also not serializable, so class instances get slimmed down to just their serializable properties:

```ts
import { useLoaderData } from '@remix-run/react';

class Dog {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  bark() {
    console.log('woof');
  }
}

export function loader() {
  return {
    planet: 'world',
    date: new Date(),
    spot: new Dog('Spot', 3),
  };
}

export default function Component() {
  const data = useLoaderData<typeof loader>();
  //    ^? { planet: string, date: Date, spot: { name: string, age: number, bark: undefined } }
}
```

#### `clientLoader` and `clientAction`

<docs-warning>Make sure to include types for the `clientLoader` args and `clientAction` args as that is how our types detect client data functions.</docs-warning>

Data from client-side loaders and actions are never serialized so types for those are preserved:

```ts
import { useLoaderData, type ClientLoaderFunctionArgs } from '@remix-run/react';

class Dog {
  /* ... */
}

// Make sure to annotate the types for the args! üëá
export function clientLoader(_: ClientLoaderFunctionArgs) {
  return {
    planet: 'world',
    date: new Date(),
    notSoRandom: () => 7,
    spot: new Dog('Spot', 3),
  };
}

export default function Component() {
  const data = useLoaderData<typeof clientLoader>();
  //    ^? { planet: string, date: Date, notSoRandom: () => number, spot: Dog }
}
```

### Headers

The [`headers`][headers] function is now used on both document and data requests when Single Fetch is enabled. You should use that function to merge any headers returned from loaders executed in parallel, or to return any given `actionHeaders`.

### Returned Responses

With Single Fetch, you no longer need to return `Response` instances and can just return your data directly via naked object returns. Therefore, the `json`/`defer` utilities should be considered deprecated when using Single Fetch. These will remain for the duration of v2 so you don't need to remove them immediately. They will likely be removed in the next major version, so we recommend remove them incrementally between now and then.

For v2, you may still continue returning normal `Response` instances and their `status`/`headers` will take effect the same way they do on document requests (merging headers via the `headers()` function).

Over time, you should start eliminating returned Responses from your loaders and actions.

- If your `loader`/`action` was returning `json`/`defer` without setting any `status`/`headers`, then you can just remove the call to `json`/`defer` and return the data directly
- If your `loader`/`action` was returning custom `status`/`headers` via `json`/`defer`, you should switch those to use the new [`data()`][data-utility] utility.

### Client Loaders

If your app has routes using [`clientLoader`][client-loader] functions, it's important to note that the behavior of Single Fetch will change slightly. Because `clientLoader` is intended to give you a way to opt-out of calling the server `loader` function - it would be incorrect for the Single Fetch call to execute that server loader. But we run all loaders in parallel and we don't want to _wait_ to make the call until we know which `clientLoader`'s are actually asking for server data.

For example, consider the following `/a/b/c` routes:

```ts
// routes/a.tsx
export function loader() {
  return { data: 'A' };
}

// routes/a.b.tsx
export function loader() {
  return { data: 'B' };
}

// routes/a.b.c.tsx
export function loader() {
  return { data: 'C' };
}

export function clientLoader({ serverLoader }) {
  await doSomeStuff();
  const data = await serverLoader();
  return { data };
}
```

If a user navigates from `/ -> /a/b/c`, then we need to run the server loaders for `a` and `b`, and the `clientLoader` for `c` - which may eventually (or may not) call it's own server `loader`. We can't decide to include the `c` server `loader` in a single fetch call when we want to fetch the `a`/`b` `loader`'s, nor can we delay until `c` actually makes the `serverLoader` call (or returns) without introducing a waterfall.

Therefore, when you export a `clientLoader` that route opts-out of Single Fetch and when you call `serverLoader` it will make a single fetch to get only it's route server `loader`. All routes that do not export a `clientLoader` will be fetched in a singular HTTP request.

So, on the above route setup a navigation from `/ -> /a/b/c` will result in a singular single-fetch call up front for routes `a` and `b`:

```
GET /a/b/c.data?_routes=routes/a,routes/b
```

And then when `c` calls `serverLoader`, it'll make it's own call for just the `c` server `loader`:

```
GET /a/b/c.data?_routes=routes/c
```

### Resource Routes

Because of the new [streaming format][streaming-format] used by Single Fetch, raw JavaScript objects returned from `loader` and `action` functions are no longer automatically converted to `Response` instances via the `json()` utility. Instead, in navigational data loads they're combined with the other loader data and streamed down in a `turbo-stream` response.

This poses an interesting conundrum for [resource routes][resource-routes] which are unique because they're intended to be hit individually -- and not always via Remix APIs. They can also be accessed via any other HTTP client (`fetch`, `cURL`, etc.).

If a resource route is intended for consumption by internal Remix APIs, we _want_ to be able to leverage the `turbo-stream` encoding to unlock the ability to stream down more complex structures such as `Date` and `Promise` instances. However, when accessed externally, we'd probably prefer to return the more easily consumable JSON structure. Thus, the behavior is slightly ambiguous if you return a raw object in v2 - should it be serialized via `turbo-stream` or `json()`?

To ease backwards-compatibility and ease the adoption of the Single Fetch future flag, Remix v2 will handle this based on whether it's accessed from a Remix API or externally. In the future Remix will require you to return your own [JSON response][returning-response] if you do not want raw objects to be streamed down for external consumption.

The Remix v2 behavior with Single Fetch enabled is as follows:

- When accessing from a Remix API such as `useFetcher`, raw Javascript objects will be returned as `turbo-stream` responses, just like normal loaders and actions (this is because `useFetcher` will append the `.data` suffix to the request)

- When accessing from an external tool such as `fetch` or `cURL`, we will continue this automatic conversion to `json()` for backwards-compatibility in v2:

  - Remix will log a deprecation warning when this situation is encountered
  - At your convenience, you can update impacted resource route handlers to return a `Response` object
  - Addressing these deprecation warnings will better prepare you for the eventual Remix v3 upgrade

  ```tsx filename=app/routes/resource.tsx bad
  export function loader() {
    return {
      message: 'My externally-accessed resource route',
    };
  }
  ```

  ```tsx filename=app/routes/resource.tsx good
  export function loader() {
    return Response.json({
      message: 'My externally-accessed resource route',
    });
  }
  ```

## Additional Details

### Streaming Data Format

Previously, Remix used `JSON.stringify` to serialize your loader/action data over the wire, and needed to implement a custom streaming format to support `defer` responses.

With Single Fetch, Remix now uses [`turbo-stream`][turbo-stream] under the hood which provides first class support for streaming and allows you to automatically serialize/deserialize more complex data than JSON. The following data types can be streamed down directly via `turbo-stream`: `BigInt`, `Date`, `Error`, `Map`, `Promise`, `RegExp`, `Set`, `Symbol`, and `URL`. Subtypes of `Error` are also supported as long as they have a globally available constructor on the client (`SyntaxError`, `TypeError`, etc.).

This may or may not require any immediate changes to your code once enabling Single Fetch:

- ‚úÖ `json` responses returned from `loader`/`action` functions will still be serialized via `JSON.stringify` so if you return a `Date`, you'll receive a `string` from `useLoaderData`/`useActionData`
- ‚ö†Ô∏è If you're returning a `defer` instance or a naked object, it will now be serialized via `turbo-stream`, so if you return a `Date`, you'll receive a `Date` from `useLoaderData`/`useActionData`
  - If you wish to maintain current behavior (excluding streaming `defer` responses), you may just wrap any existing naked object returns in `json`

This also means that you no longer need to use the `defer` utility to send `Promise` instances over the wire! You can include a `Promise` anywhere in a naked object and pick it up on `useLoaderData().whatever`. You can also nest `Promise`'s if needed - but beware of potential UX implications.

Once adopting Single Fetch, it is recommended that you incrementally remove the usage of `json`/`defer` throughout your application in favor of returning raw objects.

### Streaming Timeout

Previously, Remix has a concept of an `ABORT_TIMEOUT` built-into the default [`entry.server.tsx`][entry-server] files which would terminate the React renderer, but it didn't do anything in particular to clean up any pending deferred promises.

Now that Remix is streaming internally, we can cancel the `turbo-stream` processing and automatically reject any pending promises and stream up those errors to the client. By default, this happens after 4950ms - a value that was chosen to be just under the current 5000ms `ABORT_DELAY` in most entry.server.tsx files - since we need to cancel the promises and let the rejections stream up through the React renderer prior to aborting the React side of things.

You can control this by exporting a `streamTimeout` numeric value from your `entry.server.tsx` and Remix will use that as the number of milliseconds after which to reject any outstanding Promises from `loader`/`action`'s. It's recommended to decouple this value from the timeout in which you abort the React renderer - and you should always set the React timeout to a higher value so it has time to stream down the underlying rejections from your `streamTimeout`.

```tsx filename=app/entry.server.tsx lines=[1-2,32-33]
// Reject all pending promises from handler functions after 5 seconds
export const streamTimeout = 5000;

// ...

function handleBrowserRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext,
) {
  return new Promise((resolve, reject) => {
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer context={remixContext} url={request.url} abortDelay={ABORT_DELAY} />,
      {
        onShellReady() {
          /* ... */
        },
        onShellError(error: unknown) {
          /* ... */
        },
        onError(error: unknown) {
          /* ... */
        },
      },
    );

    // Automatically timeout the react renderer after 10 seconds
    setTimeout(abort, 10000);
  });
}
```

### Revalidations

#### Normal Navigation Behavior

In addition to the simpler mental model and the alignment of document and data requests, another benefit of Single Fetch is simpler (and hopefully better) caching behavior. Generally, Single Fetch will make fewer HTTP requests and hopefully cache those results more frequently compared to the previous multiple-fetch behavior.

To reduce cache fragmentation, Single Fetch changes the default revalidation behavior on GET navigations. Previously, Remix would not re-run loaders for reused ancestor routes unless you opted-in via `shouldRevalidate`. Now, Remix _will_ re-run those by default in the simple case for a Single Fetch request like `GET /a/b/c.data`. If you do not have any `shouldRevalidate` or `clientLoader` functions, this will be the behavior for your app.

Adding either a `shouldRevalidate` or a `clientLoader` to any of the active routes will trigger granular Single Fetch calls that include a `_routes` parameter specifying the subset of routes to run.

If a `clientLoader` calls `serverLoader()` internally, that will trigger a separate HTTP call for that specific route, akin to the old behavior.

For example, if you are on `/a/b` and you navigate to `/a/b/c`:

- When no `shouldRevalidate` or `clientLoader` functions exist: `GET /a/b/c.data`
- If all routes have loaders but `routes/a` opts out via `shouldRevalidate`:
  - `GET /a/b/c.data?_routes=root,routes/b,routes/c`
- If all routes have loaders but `routes/b` has a `clientLoader`:
  - `GET /a/b/c.data?_routes=root,routes/a,routes/c`
  - And then if B's `clientLoader` calls `serverLoader()`:
    - `GET /a/b/c.data?_routes=routes/b`

If this new behavior is sub-optimal for your application, you should be able to opt-back into the old behavior of not-revalidating by adding a `shouldRevalidate` that returns `false` in the desired scenarios to your parent routes.

Another option is to leverage a server-side cache for expensive parent loader calculations.

#### Submission Revalidation Behavior

Previously, Remix would always revalidate all active loaders after _any_ action submission, regardless of the result of the action. You could opt-out of revalidation on a per-route basis via [`shouldRevalidate`][should-revalidate].

With Single Fetch, if an `action` returns or throws a `Response` with a `4xx/5xx` status code, Remix will _not revalidate_ loaders by default. If an `action` returns or throws anything that is not a 4xx/5xx Response, then the revalidation behavior is unchanged. The reasoning here is that in most cases, if you return a `4xx`/`5xx` Response, you didn't actually mutate any data so there is no need to reload data.

If you _want_ to continue revalidating one or more loaders after a 4xx/5xx action response, you can opt-into revalidation on a per-route basis by returning `true` from your [`shouldRevalidate`][should-revalidate] function. There is also a new `actionStatus` parameter passed to the function that you can use if you need to decide based on the action status code.

Revalidation is handled via a `?_routes` query string parameter on the single fetch HTTP call which limits the loaders being called. This means that when you are doing fine-grained revalidation, you will have cache enumerations based on the routes being requested - but all of the information is in the URL so you should not need any special CDN configurations (as opposed to if this was done via a custom header that required your CDN to respect the `Vary` header).

[future-flags]: ../file-conventions/remix-config#future
[should-revalidate]: ../route/should-revalidate
[entry-server]: ../file-conventions/entry.server
[client-loader]: ../route/client-loader
[2.9.0]: https://github.com/remix-run/remix/blob/main/CHANGELOG.md#v290
[2.13.0]: https://github.com/remix-run/remix/blob/main/CHANGELOG.md#v2130
[rfc]: https://github.com/remix-run/remix/discussions/7640
[turbo-stream]: https://github.com/jacob-ebey/turbo-stream
[rendertopipeablestream]: https://react.dev/reference/react-dom/server/renderToPipeableStream
[rendertoreadablestream]: https://react.dev/reference/react-dom/server/renderToReadableStream
[rendertostring]: https://react.dev/reference/react-dom/server/renderToString
[hydrateroot]: https://react.dev/reference/react-dom/client/hydrateRoot
[starttransition]: https://react.dev/reference/react/startTransition
[headers]: ../route/headers
[resource-routes]: ../guides/resource-routes
[returning-response]: ../route/loader#returning-response-instances
[streaming-format]: #streaming-data-format
[undici-polyfill]: https://github.com/remix-run/remix/blob/main/CHANGELOG.md#undici
[undici]: https://github.com/nodejs/undici
[csp]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src
[csp-nonce]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#sources
[merging-remix-and-rr]: https://remix.run/blog/merging-remix-and-react-router
[migration-guide]: #migrating-a-route-with-single-fetch
[breaking-changes]: #breaking-changes
[revalidation]: #normal-navigation-behavior
[action-revalidation]: #submission-revalidation-behavior
[start]: #enabling-single-fetch
[type-inference-section]: #type-inference
[compatibility-flag]: https://developers.cloudflare.com/workers/configuration/compatibility-dates
[data-utility]: ../utils/data
[augment]: https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation
[streaming-nonce]: ./streaming#streaming-with-a-content-security-policy

---

## File: ./guides/spa-mode.md

---

## title: SPA Mode

# SPA Mode

From the beginning, Remix's opinion has always been that you own your server architecture. This is why Remix is built on top of the [Web Fetch API][fetch] and can run on any modern [runtime][runtimes] via built-in or community-provided adapters. While we believe that having a server provides the best UX/Performance/SEO/etc. for _most_ apps, it is also undeniable that there exist plenty of valid use cases for a Single Page Application in the real world:

- You don't want to manage a server and prefer to deploy your app via static files on Github Pages or another CDN
- You don't want to run a Node.js server
- You want to [migrate a React Router app][migrate-rr] to Remix
- You're developing a special type of embedded app that can't be server rendered
- "Your boss couldn't care less about the UX ceiling of SPA architecture and won't give your dev teams time/capacity to re-architect things" [- Kent C. Dodds][kent-tweet]

That's why we added support for **SPA Mode** in [2.5.0][2.5.0] ([RFC][rfc]), which builds heavily on top of the [Client Data][client-data] APIs.

<docs-info>SPA Mode requires your app to be using Vite and the [Remix Vite Plugin][remix-vite]</docs-info>

## What is SPA Mode?

SPA Mode is basically what you'd get if you had your own [React Router + Vite][rr-setup] setup using `createBrowserRouter`/`RouterProvider`, but along with some extra Remix goodies:

- File-based routing (or config-based via [`routes()`][routes-config])
- Automatic route-based code-splitting via [`route.lazy`][route-lazy]
- `<Link prefetch>` support to eagerly prefetch route modules
- `<head>` management via Remix [`<Meta>`][meta]/[`<Links>`][links] APIs

SPA Mode tells Remix that you do not plan on running a Remix server at runtime and that you wish to generate a static `index.html` file at build time and you will only use [Client Data][client-data] APIs for data loading and mutations.

The `index.html` is generated from the `HydrateFallback` component in your `root.tsx` route. The initial "render" to generate the `index.html` will not include any routes deeper than root. This ensures that the `index.html` file can be served/hydrated for paths beyond `/` (i.e., `/about`) if you configure your CDN/server to do so.

## Usage

You can get started quickly using the SPA Mode template in the repo:

```shellscript
npx create-remix@latest --template remix-run/remix/templates/spa
```

Or, you can manually opt-into SPA mode in your Remix+Vite app by setting `ssr: false` in your Remix Vite plugin config:

```js
// vite.config.ts
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [
    remix({
      ssr: false,
    }),
  ],
});
```

### Development

In SPA Mode, you develop the same way you would for a traditional Remix SSR app, and you actually use a running Remix dev server in order to enable HMR/HDR:

```sh
npx remix vite:dev
```

### Production

When you build your app in SPA Mode, Remix will call the server handler for the `/` route and save the rendered HTML in an `index.html` file alongside your client side assets (by default `build/client/index.html`).

```sh
npx remix vite:build
```

#### Preview

You can preview the production build locally with [vite preview][vite-preview]:

```shellscript
npx vite preview
```

<docs-warning>`vite preview` is not designed for use as a production server</docs-warning>

#### Deployment

To deploy, you can serve your app from any HTTP server of your choosing. The server should be configured to serve multiple paths from a single root `/index.html` file (commonly called "SPA fallback"). Other steps may be required if the server doesn't directly support this functionality.

For a simple example, you could use [sirv-cli][sirv-cli]:

```shellscript
npx sirv-cli build/client/ --single
```

Or, if you are serving via an `express` server (although at that point you may want to consider just running Remix in SSR mode üòâ):

```js
app.use('/assets', express.static('build/client/assets'));
app.get('*', (req, res, next) =>
  res.sendFile(path.join(process.cwd(), 'build/client/index.html'), next),
);
```

## Hydrating a div instead of the full document

If you don't want to hydrate the full HTML `document`, you can choose to use SPA mode and only hydrate a sub-section of the document such as `<div id="app">` with a few minor changes.

**1. Add an `index.html` file**

Since Remix won't render the HTML document, you will need to provide that HTML outside of Remix. The easiest way to do this is to just keep an `app/index.html` document with a placeholder you can replace with the Remix rendered HTML at build time to generate the final `index.html`

```html filename=app/index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>My Cool App!</title>
  </head>
  <body>
    <div id="app"><!-- Remix SPA --></div>
  </body>
</html>
```

The `<!-- Remix SPA -->` HTML comment is what we'll replace with the Remix HTML.

<docs-info>Because whitespace is meaningful in the DOM/VDOM tree - it's important not to include any spaces around it and the surrounding `div`, otherwise you will run into React hydration issues</docs-info>

**2. Update `root.tsx`**

Update your root route to render just the contents of `<div id="app">`:

```tsx filename=app/root.tsx
export function HydrateFallback() {
  return (
    <>
      <p>Loading...</p>
      <Scripts />
    </>
  );
}

export default function Component() {
  return (
    <>
      <Outlet />
      <Scripts />
    </>
  );
}
```

**3. Update `entry.server.tsx`**

In your `app/entry.server.tsx` file, you'll want to take the Remix-rendered HTML and insert it into your static `app/index.html` file placeholder. You'll also want to stop pre-pending the `<!DOCTYPE html>` declaration like the default `entry.server.tsx` file does since that should be in your `app/index.html` file).

```tsx filename=app/entry.server.tsx
import fs from 'node:fs';
import path from 'node:path';

import type { EntryContext } from '@remix-run/node';
import { RemixServer } from '@remix-run/react';
import { renderToString } from 'react-dom/server';

export default function handleRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext,
) {
  const shellHtml = fs.readFileSync(path.join(process.cwd(), 'app/index.html')).toString();

  const appHtml = renderToString(<RemixServer context={remixContext} url={request.url} />);

  const html = shellHtml.replace('<!-- Remix SPA -->', appHtml);

  return new Response(html, {
    headers: { 'Content-Type': 'text/html' },
    status: responseStatusCode,
  });
}
```

<docs-info>You may need to run `npx remix reveal` if you don't currently have an `app/entry.server.tsx` file in your app</docs-info>

**4. Update `entry.client.tsx`**

Update `app/entry.client.tsx` to hydrate the `<div id="app">` instead of the document:

```tsx filename=app/entry.client.tsx
import { RemixBrowser } from '@remix-run/react';
import { startTransition, StrictMode } from 'react';
import { hydrateRoot } from 'react-dom/client';

startTransition(() => {
  hydrateRoot(
    document.querySelector('#app'),
    <StrictMode>
      <RemixBrowser />
    </StrictMode>,
  );
});
```

<docs-info>You may need to run `npx remix reveal` if you don't currently have an `app/entry.client.tsx` file in your app</docs-info>

## Notes/Caveats

- SPA Mode only works when using Vite and the [Remix Vite plugin][remix-vite]

- You cannot use server APIs such as `headers`, `loader`, and `action` -- the build will throw an error if you export them

- You can only export a `HydrateFallback` from your `root.tsx` in SPA Mode -- the build will throw an error if you export one from any other routes.

- You cannot call `serverLoader`/`serverAction` from your `clientLoader`/`clientAction` methods since there is no running server -- those will throw a runtime error if called

### Server Build

It's important to note that Remix SPA mode generates your `index.html` file by performing a "pre-render" of your root route on the server during the build

- This means that while you're creating a SPA, you still have a "server build" and "server render" step, so you do need to be careful about using dependencies that reference client-only aspects such as `document`, `window`, `localStorage`, etc.
- Generally speaking, the way to resolve these issues is to import any browser-only libraries from `entry.client.tsx` so they don't end up in the server build
- Otherwise, you can generally solve these by using [`React.lazy`][react-lazy] or the [`<ClientOnly>`][client-only] component from `remix-utils`

### CJS/ESM Dependency Issues

If you are running into ESM/CJS issues with your app dependencies you may need to play with the Vite [ssr.noExternal][vite-ssr-noexternal] option to include certain dependencies in your server bundle:

```ts filename=vite.config.ts lines=[12-15]
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';
import tsconfigPaths from 'vite-tsconfig-paths';

export default defineConfig({
  plugins: [
    remix({
      ssr: false,
    }),
    tsconfigPaths(),
  ],
  ssr: {
    // Bundle `problematic-dependency` into the server build
    noExternal: ['problematic-dependency'],
  },
  // ...
});
```

These issues are usually due to dependencies whose published code is incorrectly-configured for CJS/ESM. By including the specific dependency in `ssr.noExternal`, Vite will bundle the dependency into the server build and can help avoid runtime import issues when running your server.

If you have the opposite use-case and you specifically want to keep dependencies external to the bundle, you can use the opposite [`ssr.external`][vite-ssr-external] option.

## Migrating from React Router

We also expect SPA Mode to be useful in helping folks migrate existing React router apps over to Remix apps (SPA or not!).

The first step towards this migration is getting your current React Router app running on `vite`, so that you've got whatever plugins you need for your non-JS code (i.e., CSS, SVG, etc.).

**If you are currently using `BrowserRouter`**

Once you're using vite, you should be able to drop your `BrowserRouter` app into a catch-all Remix route per the steps in the [this guide][migrating-rr].

**If you are currently using `RouterProvider`**

If you are currently using `RouterProvider`, then the best approach is to move your routes to individual files and load them via `route.lazy`:

- Name these files according to the Remix file conventions to make the move to Remix (SPA) easier
- Export your route components as a named `Component` export (for RR) and also a `default` export (for eventual use by Remix)

Once you've got all your routes living in their own files, you can:

- Move those files over into the Remix `app/` directory
- Enable SPA Mode
- Rename all `loader`/`action` function to `clientLoader`/`clientAction`
- Replace your React Router `index.html` file with an `app/root.tsx` route that exports a `default` component and `HydrateFallback`

[rfc]: https://github.com/remix-run/remix/discussions/7638
[client-data]: ../guides/client-data
[2.5.0]: https://github.com/remix-run/remix/blob/main/CHANGELOG.md#v250
[fetch]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[runtimes]: ../discussion/runtimes
[kent-tweet]: https://twitter.com/kentcdodds/status/1743030378334708017
[rr-setup]: https://reactrouter.com/v6/start/tutorial#setup
[routes-config]: ../file-conventions/remix-config#routes
[route-lazy]: https://reactrouter.com/v6/route/lazy
[meta]: ../components/meta
[links]: ../components/links
[migrating-rr]: https://remix.run/docs/en/main/guides/migrating-react-router-app
[remix-vite]: ./vite
[migrate-rr]: #migrating-from-react-router
[react-lazy]: https://react.dev/reference/react/lazy
[client-only]: https://github.com/sergiodxa/remix-utils?tab=readme-ov-file#clientonly
[vite-preview]: https://vitejs.dev/guide/cli#vite-preview
[sirv-cli]: https://www.npmjs.com/package/sirv-cli
[vite-ssr-noexternal]: https://vitejs.dev/config/ssr-options#ssr-noexternal
[vite-ssr-external]: https://vitejs.dev/config/ssr-options#ssr-external

---

## File: ./guides/streaming.md

---

title: Streaming
description: When, why, and how to stream with React 18 and Remix's deferred API.

---

# Streaming

Streaming allows you to enhance user experience by delivering content as soon as it's available, rather than waiting for the entire content of a page to be ready.

Ensure your hosting provider supports streaming, not all of them do. If your responses don't seem to stream, this might be the cause.

## Steps

There are three steps to streaming data:

1. **Project Setup:** we need to make sure our client and server entry points are set up to support streaming
2. **Component Setup:** we need to make sure our components can render streamed data
3. **Deferring Loader Data:** finally we can defer data in our loaders

## 1. Project Setup

**Ready from Start:** Remix apps created using starter templates are pre-configured for streaming.

**Manual Setup Needed?:** If your project began from scratch or used an older template, verify `entry.server.tsx` and `entry.client.tsx` have streaming support. If you don't see these files then you are using the defaults and streaming is supported. If you have created your own entries, the following are the template defaults for your reference:

- [entry.client.tsx][entry_client_tsx]
- entry.server.tsx:
  - [cloudflare][entry_server_cloudflare_tsx]
  - [deno][entry_server_deno_tsx]
  - [node][entry_server_node_tsx]

## 2. Component Setup

A route module without streaming might look like this:

```tsx
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData } from '@remix-run/react';

export async function loader({ params }: LoaderFunctionArgs) {
  const [product, reviews] = await Promise.all([
    db.getProduct(params.productId),
    db.getReviews(params.productId),
  ]);

  return json({ product, reviews });
}

export default function Product() {
  const { product, reviews } = useLoaderData<typeof loader>();
  return (
    <>
      <ProductPage data={product} />
      <ProductReviews data={reviews} />
    </>
  );
}
```

In order to render streamed data, you need to use [`<Suspense>`][suspense_component] from React and [`<Await>`][await_component] from Remix. It's a bit of boilerplate, but straightforward:

```tsx lines=[3-4,20-24]
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno
import { Await, useLoaderData } from '@remix-run/react';
import { Suspense } from 'react';

import { ReviewsSkeleton } from './reviews-skeleton';

export async function loader({ params }: LoaderFunctionArgs) {
  // existing code
}

export default function Product() {
  const { product, reviews } = useLoaderData<typeof loader>();
  return (
    <>
      <ProductPage data={product} />
      <Suspense fallback={<ReviewsSkeleton />}>
        <Await resolve={reviews}>{(reviews) => <ProductReviews data={reviews} />}</Await>
      </Suspense>
    </>
  );
}
```

This code will continue to work even before we start deferring data. It's a good idea to do the component code first. If you run into issues, it's easier to track down where the problem lies.

## 3. Deferring Data in Loaders

Now that our project and route component are set up stream data, we can start deferring data in our loaders. We'll use the [`defer`][defer] utility from Remix to do this.

Note the change in the async promise code.

```tsx lines=[2,11-19]
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { defer } from '@remix-run/node'; // or cloudflare/deno
import { Await, useLoaderData } from '@remix-run/react';
import { Suspense } from 'react';

import { ReviewsSkeleton } from './reviews-skeleton';

export async function loader({ params }: LoaderFunctionArgs) {
  // üëá note this promise is not awaited
  const reviewsPromise = db.getReviews(params.productId);
  // üëá but this one is
  const product = await db.getProduct(params.productId);

  return defer({
    product,
    reviews: reviewsPromise,
  });
}

export default function Product() {
  const { product, reviews } = useLoaderData<typeof loader>();
  // existing code
}
```

Instead of awaiting the reviews promise, we pass it to `defer`. This tells Remix to stream that promise over the network to the browser.

That's it! You should now be streaming data to the browser.

## Avoid Inefficient Streaming

It's important to initiate promises for deferred data _before_ you await any other promises, otherwise you won't get the full benefit of streaming. Note the difference with this less efficient code example:

```tsx bad
export async function loader({ params }: LoaderFunctionArgs) {
  const product = await db.getProduct(params.productId);
  // üëá this won't initiate loading until `product` is done
  const reviewsPromise = db.getReviews(params.productId);

  return defer({
    product,
    reviews: reviewsPromise,
  });
}
```

## Handling Server Timeouts

When using `defer` for streaming, you can tell Remix how long to wait for deferred data to resolve before timing out via the `<RemixServer abortDelay>` prop (which defaults to 5 seconds) in your `entry.server.tsx` file. If you don't currently have an `entry.server.tsx` file you can expose it via `npx remix reveal entry.server`. You can also use this value to abort the React `renderToPipeableStream` method via a `setTimeout`.

```tsx filename=entry.server.tsx lines=[1,9,16]
const ABORT_DELAY = 5_000;

// ...

const { pipe, abort } = renderToPipeableStream(
  <RemixServer context={remixContext} url={request.url} abortDelay={ABORT_DELAY} />,
  // ...
);

// ...

setTimeout(abort, ABORT_DELAY);
```

## Streaming with a Content Security Policy

Streaming works by inserting script tags into the DOM as deferred promises resolve. If your page includes a [Content Security Policy for scripts][csp], you'll either need to weaken your security policy by including `script-src 'self' 'unsafe-inline'` in your `Content-Security-Policy` header, or add nonces to all of your script tags.

If you are using a nonce, it needs to be included in three places:

- The `Content-Security-Policy` header, like so: `Content-Security-Policy: script-src 'nonce-secretnoncevalue'`
- The `<Scripts />`, `<ScrollRestoration />` and `<LiveReload />` components, like so: `<Scripts nonce="secretnoncevalue" />`
- In `entry.server.ts` where you call `renderToPipeableStream`, like so:

```tsx filename=entry.server.tsx
const { pipe, abort } = renderToPipeableStream(
  <RemixServer context={remixContext} url={request.url} abortDelay={ABORT_DELAY} />,
  {
    nonce: 'secretnoncevalue',
    /* ...remaining fields */
  },
);
```

This will ensure the nonce value is included on any deferred script tags.

[entry_client_tsx]: https://github.com/remix-run/remix/blob/dev/packages/remix-dev/config/defaults/entry.client.tsx
[entry_server_cloudflare_tsx]: https://github.com/remix-run/remix/blob/dev/packages/remix-dev/config/defaults/entry.server.cloudflare.tsx
[entry_server_deno_tsx]: https://github.com/remix-run/remix/blob/dev/packages/remix-dev/config/defaults/entry.server.deno.tsx
[entry_server_node_tsx]: https://github.com/remix-run/remix/blob/dev/packages/remix-dev/config/defaults/entry.server.node.tsx
[suspense_component]: https://react.dev/reference/react/Suspense
[await_component]: ../components/await
[defer]: ../utils/defer
[csp]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src

---

## File: ./guides/templates.md

---

title: Templates
description: The quickest way to get rocking and rolling with Remix

---

# Templates and Stacks

<docs-warning>Just getting started with Remix? The latest version of [Remix is now React Router v7][remix-now-react-router]. If you want to use the latest framework features, you should create your project using a [React Router template][react-router-templates].</docs-warning>

When using [`create-remix`][create_remix] to generate a new project, you can choose a Template or a Stack to quickly get up and running. Templates are minimal starting points to get you up and running. "Stacks" are templates that are more-complete and closer to production ready architectures (potentially including aspects such as testing, database, CI, and deployment configurations).

## Templates

If you run `create-remix` without providing the `--template` option, you'll get a basic template using the [Remix App Server][remix_app_server].

```shellscript nonumber
npx create-remix@latest
```

If you are not interested in using TypeScript, you can install the simpler Javascript template instead:

```shellscript nonumber
npx create-remix@latest --template remix-run/remix/templates/remix-javascript
```

This is a great place to start if you're just looking to try out Remix for the first time. You can always extend this starting point yourself or migrate to a more advanced template later.

### Official Templates

If you want more control over your server or wish to deploy to a non-node runtime‚Äîsuch as [Arc][arc], [Cloudflare][cloudflare], or [Deno][deno]‚Äîthen you can try one of our [official templates][official_templates] from the Remix repository:

```shellscript nonumber
npx create-remix@latest --template remix-run/remix/templates/cloudflare
npx create-remix@latest --template remix-run/remix/templates/cloudflare-workers
npx create-remix@latest --template remix-run/remix/templates/express
npx create-remix@latest --template remix-run/remix/templates/remix
npx create-remix@latest --template remix-run/remix/templates/remix-javascript

## SPA Mode
npx create-remix@latest --template remix-run/remix/templates/spa

## Classic Remix Compiler
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/arc
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/cloudflare-pages
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/cloudflare-workers
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/deno
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/express
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/fly
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/remix
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/remix-javascript
```

### Third-Party Templates

Some hosting providers maintain their own Remix templates. For more information, see their official integration guides listed below.

- [Netlify][netlify_template_docs]
- [Vercel][vercel_template_docs]

### Examples

We also provide a [community-driven examples repository][examples], with each example showcasing different Remix features, patterns, tools, hosting providers, etc. You can use these in a similar manner to install the working example:

```shellscript nonumber
npx create-remix@latest --template remix-run/examples/basic
```

## Stacks

When a template is closer to being a production-ready application, to the point that it provides opinions about the CI/CD pipeline, database and hosting platform, the Remix community refers to these templates as "stacks".

There are several official stacks provided, but you can also make your own (read more below).

[Read the feature announcement blog post][feature_announcement_blog_post] and [watch Remix Stacks videos on YouTube][remix_stacks_videos_on_youtube].

### Official Stacks

The official stacks come ready with common things you need for a production application including:

- Database
- Automatic deployment pipelines
- Authentication
- Testing
- Linting/Formatting/TypeScript

What you're left with is everything completely set up for you to just get to work building whatever amazing web experience you want to build with Remix. Here are the official stacks:

- [The Blues Stack][blues_stack]: Deployed to the edge (distributed) with a long-running Node.js server and PostgreSQL database. Intended for large and fast production-grade applications serving millions of users.
- [The Indie Stack][indie_stack]: Deployed to a long-running Node.js server with a persistent SQLite database. This stack is great for websites with dynamic data that you control (blogs, marketing, content sites). It's also a perfect, low-complexity bootstrap for MVPs, prototypes, and proof-of-concepts that can later be updated to the Blues stack easily.
- [The Grunge Stack][grunge_stack]: Deployed to a serverless function running Node.js with DynamoDB for persistence. Intended for folks who want to deploy a production-grade application on AWS infrastructure serving millions of users.

You can use these stacks by providing the `--template` option when running `create-remix`, for example:

```shellscript nonumber
npx create-remix@latest --template remix-run/blues-stack
```

Yes, these are named after music genres. ü§ò Rock on.

### Community Stacks

You can [browse the list of community stacks on GitHub][remix_stack_topic].

Community stacks can be used by passing the GitHub username/repo combo to the `--template` option when running `create-remix`, for example:

```shellscript nonumber
npx create-remix@latest --template :username/:repo
```

<docs-success>If you want to share your stack with the community, don't forget to tag it with the [remix-stack][remix_stack_topic] topic so others can find it ‚Äî and yes, we do recommend that you name your own stack after a music sub-genre (not "rock" but "indie"!).</docs-success>

## Other Information

### Private Templates

If your template is in a private GitHub repo, you can pass a GitHub token via the `--token` option:

```shellscript nonumber
npx create-remix@latest --template your-private/repo --token yourtoken
```

The [token just needs `repo` access][repo_access_token].

### Local Templates

You can provide a local directory or tarball on disk to the `--template` option, for example:

```shellscript nonumber
npx create-remix@latest --template /my/remix-stack
npx create-remix@latest --template /my/remix-stack.tar.gz
npx create-remix@latest --template /my/remix-stack.tgz
npx create-remix@latest --template file:///Users/michael/my-remix-stack.tar.gz
```

### Custom Template Tips

#### Dependency Versions

If you set any dependencies in package.json to `*`, the Remix CLI will change it to a semver caret of the installed Remix version:

```diff
-   "remix": "*",
+   "remix": "^2.0.0",
```

This allows you to not have to regularly update your template to the latest version of that specific package. Of course, you do not have to put `*` if you'd prefer to manually manage the version for that package.

#### Customize Initialization

If the template has a `remix.init/index.js` file at the root then that file will be executed after the project has been generated and dependencies have been installed. This gives you a chance to do anything you'd like as part of the initialization of your template. For example, in the blues stack, the `app` property has to be globally unique, so we use the `remix.init/index.js` file to change it to the name of the directory that was created for the project + a couple random characters.

You could even use `remix.init/index.js` to ask further questions to the developer for additional configuration (using something like [inquirer][inquirer]). Sometimes, you'll need dependencies installed to do this, but those deps are only useful during initialization. In that case, you can also create a `remix.init/package.json` with dependencies and the Remix CLI will install those before running your script.

After the init script has been run, the `remix.init` folder gets deleted, so you don't need to worry about it cluttering up the finished codebase.

<docs-warning>Do note that consumers can opt out of running the `remix.init` script. To do so manually, they'll need to run `remix init`.</docs-warning>

[create_remix]: ../other-api/create-remix
[remix_app_server]: ../other-api/serve
[repo_access_token]: https://github.com/settings/tokens/new?description=Remix%20Private%20Stack%20Access&scopes=repo
[inquirer]: https://npm.im/inquirer
[feature_announcement_blog_post]: /blog/remix-stacks
[remix_stacks_videos_on_youtube]: https://www.youtube.com/playlist?list=PLXoynULbYuEC8-gJCqyXo94RufAvSA6R3
[blues_stack]: https://github.com/remix-run/blues-stack
[indie_stack]: https://github.com/remix-run/indie-stack
[grunge_stack]: https://github.com/remix-run/grunge-stack
[remix_stack_topic]: https://github.com/topics/remix-stack
[official_templates]: https://github.com/remix-run/remix/tree/main/templates
[examples]: https://github.com/remix-run/examples
[vercel_template_docs]: https://vercel.com/docs/frameworks/remix
[netlify_template_docs]: https://docs.netlify.com/integrations/frameworks/remix
[arc]: https://arc.codes/docs/en/get-started/quickstart
[deno]: https://deno.com
[cloudflare]: https://www.cloudflare.com
[remix-now-react-router]: https://remix.run/blog/incremental-path-to-react-19
[react-router-templates]: https://github.com/remix-run/react-router-templates

---

## File: ./guides/typescript.md

---

title: TypeScript
toc: false

---

# TypeScript

Remix seamlessly supports both JavaScript and TypeScript. If you name a file with a `.ts` or `.tsx` extension, it will treat it as TypeScript (`.tsx` is for TypeScript files [with JSX][with-jsx] in them). But it isn't required. You can write all your files as `.js` files if you don't want TypeScript.

The Remix CLI will not perform any type checking. Instead, you'll want to use TypeScript's `tsc` CLI yourself. A common solution is to add a `typecheck` script to your package.json:

```json filename=package.json lines=[10]
{
  "name": "remix-app",
  "private": true,
  "sideEffects": false,
  "scripts": {
    "build": "remix vite:build",
    "dev": "remix vite:dev",
    "lint": "eslint --ignore-path .gitignore .",
    "start": "remix-serve ./build/index.js",
    "typecheck": "tsc"
  },
  "dependencies": {
    "@remix-run/node": "latest",
    "@remix-run/react": "latest",
    "@remix-run/serve": "latest",
    "isbot": "^4.1.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@remix-run/dev": "latest",
    "@types/react": "^18.2.20",
    "@types/react-dom": "^18.2.7",
    "eslint": "^8.23.1",
    "typescript": "^5.1.6",
    "vite": "^5.1.4"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

Then you can run that script as part of continuous integration, alongside your tests.

Remix has TypeScript type definitions built-in as well. For example, the starter templates create a `tsconfig.json` file that includes the necessary types for Remix and Vite:

```json filename=tsconfig.json lines=[12]
{
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "**/.server/**/*.ts",
    "**/.server/**/*.tsx",
    "**/.client/**/*.ts",
    "**/.client/**/*.tsx"
  ],
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "types": ["@remix-run/node", "vite/client"],
    "isolatedModules": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "target": "ES2022",
    "strict": true,
    "allowJs": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "~/*": ["./app/*"]
    },

    // Vite takes care of building everything, not tsc.
    "noEmit": true
  }
}
```

<docs-info>Note that the types referenced in the `types` array will depend on which environment you're running your app in. For example, there are different globals available in Cloudflare.</docs-info>

[with-jsx]: https://www.typescriptlang.org/docs/handbook/jsx.html

---

## File: ./guides/vite.md

---

## title: Vite

# Vite

[Vite][vite] is a powerful, performant and extensible development environment for JavaScript projects. In order to improve and extend Remix's bundling capabilities, we now support Vite as an alternative compiler. In the future, Vite will become the default compiler for Remix.

## Classic Remix Compiler vs. Remix Vite

The existing Remix compiler, accessed via the `remix build` and `remix dev` CLI commands and configured via `remix.config.js`, is now referred to as the "Classic Remix Compiler".

The Remix Vite plugin and the `remix vite:build` and `remix vite:dev` CLI commands are collectively referred to as "Remix Vite".

Moving forwards, documentation will assume usage of Remix Vite unless otherwise stated.

## Getting started

We've got a few different Vite-based templates to get you started.

```shellscript nonumber
# Minimal server:
npx create-remix@latest

# Express:
npx create-remix@latest --template remix-run/remix/templates/express

# Cloudflare:
npx create-remix@latest --template remix-run/remix/templates/cloudflare

# Cloudflare Workers:
npx create-remix@latest --template remix-run/remix/templates/cloudflare-workers
```

These templates include a `vite.config.ts` file which is where the Remix Vite plugin is configured.

## Configuration

The Remix Vite plugin is configured via a `vite.config.ts` file at the root of your project. For more information, see our [Vite config documentation][vite-config].

## Cloudflare

To get started with Cloudflare, you can use the [`cloudflare`][template-cloudflare] template:

```shellscript nonumber
npx create-remix@latest --template remix-run/remix/templates/cloudflare
```

There are two ways to run your Cloudflare app locally:

```shellscript nonumber
# Vite
remix vite:dev

# Wrangler
remix vite:build # build app before running wrangler
wrangler pages dev ./build/client
```

While Vite provides a better development experience, Wrangler provides closer emulation of the Cloudflare environment by running your server code in [Cloudflare's `workerd` runtime][cloudflare-workerd] instead of Node.

#### Cloudflare Proxy

To simulate the Cloudflare environment in Vite, Wrangler provides [Node proxies to local `workerd` bindings][wrangler-getplatformproxy].
Remix's Cloudflare Proxy plugin sets up these proxies for you:

```ts filename=vite.config.ts lines=[3,8]
import {
  vitePlugin as remix,
  cloudflareDevProxyVitePlugin as remixCloudflareDevProxy,
} from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [remixCloudflareDevProxy(), remix()],
});
```

The proxies are then available within `context.cloudflare` in your `loader` or `action` functions:

```ts
export const loader = ({ context }: LoaderFunctionArgs) => {
  const { env, cf, ctx } = context.cloudflare;
  // ... more loader code here...
};
```

Check out [Cloudflare's `getPlatformProxy` docs][wrangler-getplatformproxy-return] for more information on each of these proxies.

#### Bindings

To configure bindings for Cloudflare resources:

- For local development with Vite or Wrangler, use [wrangler.toml][wrangler-toml-bindings]
- For deployments, use the [Cloudflare dashboard][cloudflare-pages-bindings]

Whenever you change your `wrangler.toml` file, you'll need to run `wrangler types` to regenerate your bindings.

Then, you can access your bindings via `context.cloudflare.env`.
For example, with a [KV namespace][cloudflare-kv] bound as `MY_KV`:

```ts filename=app/routes/_index.tsx
export async function loader({ context }: LoaderFunctionArgs) {
  const { MY_KV } = context.cloudflare.env;
  const value = await MY_KV.get('my-key');
  return json({ value });
}
```

#### Augmenting load context

If you'd like to add additional properties to the load context,
you should export a `getLoadContext` function from a shared module so that **load context in Vite, Wrangler, and Cloudflare Pages are all augmented in the same way**:

```ts filename=load-context.ts lines=[1,4-9,20-33]
import { type AppLoadContext } from '@remix-run/cloudflare';
import { type PlatformProxy } from 'wrangler';

// When using `wrangler.toml` to configure bindings,
// `wrangler types` will generate types for those bindings
// into the global `Env` interface.
// Need this empty interface so that typechecking passes
// even if no `wrangler.toml` exists.
interface Env {}

type Cloudflare = Omit<PlatformProxy<Env>, 'dispose'>;

declare module '@remix-run/cloudflare' {
  interface AppLoadContext {
    cloudflare: Cloudflare;
    extra: string; // augmented
  }
}

type GetLoadContext = (args: {
  request: Request;
  context: { cloudflare: Cloudflare }; // load context _before_ augmentation
}) => AppLoadContext;

// Shared implementation compatible with Vite, Wrangler, and Cloudflare Pages
export const getLoadContext: GetLoadContext = ({ context }) => {
  return {
    ...context,
    extra: 'stuff',
  };
};
```

<docs-warning>You must pass in `getLoadContext` to **both** the Cloudflare Proxy plugin and the request handler in `functions/[[path]].ts`, otherwise you'll get inconsistent load context augmentation depending on how you run your app.</docs-warning>

First, pass in `getLoadContext` to the Cloudflare Proxy plugin in your Vite config to augment load context when running Vite:

```ts filename=vite.config.ts lines=[8,12]
import {
  vitePlugin as remix,
  cloudflareDevProxyVitePlugin as remixCloudflareDevProxy,
} from '@remix-run/dev';
import { defineConfig } from 'vite';
import tsconfigPaths from 'vite-tsconfig-paths';

import { getLoadContext } from './load-context';

export default defineConfig({
  plugins: [remixCloudflareDevProxy({ getLoadContext }), remix()],
});
```

Next, pass in `getLoadContext` to the request handler in your `functions/[[path]].ts` file to augment load context when running Wrangler or when deploying to Cloudflare Pages:

```ts filename=functions/[[path]].ts lines=[5,9]
import { createPagesFunctionHandler } from '@remix-run/cloudflare-pages';

// @ts-ignore - the server build file is generated by `remix vite:build`
import * as build from '../build/server';
import { getLoadContext } from '../load-context';

export const onRequest = createPagesFunctionHandler({
  build,
  getLoadContext,
});
```

## Splitting up client and server code

Vite handles mixed use of client and server code differently to the Classic Remix compiler. For more information, see our documentation on [splitting up client and server code][splitting-up-client-and-server-code].

## New build output paths

There is a notable difference with the way Vite manages the `public` directory compared to the existing Remix compiler. Vite copies files from the `public` directory into the client build directory, whereas the Remix compiler left the `public` directory untouched and used a subdirectory (`public/build`) as the client build directory.

In order to align the default Remix project structure with the way Vite works, the build output paths have been changed. There is now a single `buildDirectory` option that defaults to `"build"`, replacing the separate `assetsBuildDirectory` and `serverBuildDirectory` options. This means that, by default, the server is now compiled into `build/server` and the client is now compiled into `build/client`.

This also means that the following configuration defaults have been changed:

- [publicPath][public-path] has been replaced by [Vite's "base" option][vite-base] which defaults to `"/"` rather than `"/build/"`.
- [serverBuildPath][server-build-path] has been replaced by `serverBuildFile` which defaults to `"index.js"`. This file will be written into the server directory within your configured `buildDirectory`.

One of the reasons that Remix is moving to Vite is so you have less to learn when adopting Remix.
This means that, for any additional bundling features you'd like to use, you should reference [Vite documentation][vite] and the [Vite plugin community][vite-plugins] rather than the Remix documentation.

Vite has many [features][vite-features] and [plugins][vite-plugins] that are not built into the existing Remix compiler.
The use of any such features will render the existing Remix compiler unable to compile your app, so only use them if you intend to use Vite exclusively from here on out.

## Migrating

#### Setup Vite

üëâ **Install Vite as a development dependency**

```shellscript nonumber
npm install -D vite
```

Remix is now just a Vite plugin, so you'll need to hook it up to Vite.

üëâ **Replace `remix.config.js` with `vite.config.ts` at the root of your Remix app**

```ts filename=vite.config.ts
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [remix()],
});
```

The subset of [supported Remix config options][vite-config] should be passed directly to the plugin:

```ts filename=vite.config.ts lines=[3-5]
export default defineConfig({
  plugins: [
    remix({
      ignoredRouteFiles: ['**/*.css'],
    }),
  ],
});
```

#### HMR & HDR

Vite provides a robust client-side runtime for development features like HMR,
making the `<LiveReload />` component obsolete. When using the Remix Vite plugin in development,
the `<Scripts />` component will automatically include Vite's client-side runtime and other dev-only scripts.

üëâ **Remove `<LiveReload/>`, keep `<Scripts />`**

```diff
  import {
-   LiveReload,
    Outlet,
    Scripts,
  }

  export default function App() {
    return (
      <html>
        <head>
        </head>
        <body>
          <Outlet />
-         <LiveReload />
          <Scripts />
        </body>
      </html>
    )
  }
```

#### TypeScript integration

Vite handles imports for all sorts of different file types, sometimes in ways that differ from the existing Remix compiler, so let's reference Vite's types from `vite/client` instead of the obsolete types from `@remix-run/dev`.

Since the module types provided by `vite/client` are not compatible with the module types implicitly included with `@remix-run/dev`, you'll also need to enable the `skipLibCheck` flag in your TypeScript config. Remix won't require this flag in the future once the Vite plugin is the default compiler.

üëâ **Update `tsconfig.json`**

Update the `types` field in `tsconfig.json` and make sure `skipLibCheck`, `module`, and `moduleResolution` are all set correctly.

```json filename=tsconfig.json lines=[3-6]
{
  "compilerOptions": {
    "types": ["@remix-run/node", "vite/client"],
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "Bundler"
  }
}
```

üëâ **Update/remove `remix.env.d.ts`**

Remove the following type declarations in `remix.env.d.ts`

```diff filename=remix.env.d.ts
- /// <reference types="@remix-run/dev" />
- /// <reference types="@remix-run/node" />
```

If `remix.env.d.ts` is now empty, delete it

```shellscript nonumber
rm remix.env.d.ts
```

#### Migrating from Remix App Server

If you were using `remix-serve` in development (or `remix dev` without the `-c` flag), you'll need to switch to the new minimal dev server.
It comes built-in with the Remix Vite plugin and will take over when you run `remix vite:dev`.

The Remix Vite plugin doesn't install any [global Node polyfills][global-node-polyfills] so you'll need to install them yourself if you were relying on `remix-serve` to provide them. The easiest way to do this is by calling `installGlobals` at the top of your Vite config.

The Vite dev server's default port is different to `remix-serve` so you'll need to configure this via Vite's `server.port` option if you'd like to maintain the same port.

You'll also need to update to the new build output paths, which are `build/server` for the server and `build/client` for client assets.

üëâ **Update your `dev`, `build` and `start` scripts**

```json filename=package.json lines=[3-5]
{
  "scripts": {
    "dev": "remix vite:dev",
    "build": "remix vite:build",
    "start": "remix-serve ./build/server/index.js"
  }
}
```

üëâ **Install global Node polyfills in your Vite config**

```diff filename=vite.config.ts
import { vitePlugin as remix } from "@remix-run/dev";
+import { installGlobals } from "@remix-run/node";
import { defineConfig } from "vite";

+installGlobals();

export default defineConfig({
  plugins: [remix()],
});
```

üëâ **Configure your Vite dev server port (optional)**

```js filename=vite.config.ts lines=[2-4]
export default defineConfig({
  server: {
    port: 3000,
  },
  plugins: [remix()],
});
```

#### Migrating a custom server

If you were using a custom server in development, you'll need to edit your custom server to use Vite's `connect` middleware.
This will delegate asset requests and initial render requests to Vite during development, letting you benefit from Vite's excellent DX even with a custom server.

You can then load the virtual module named `"virtual:remix/server-build"` during development to create a Vite-based request handler.

You'll also need to update your server code to reference the new build output paths, which are `build/server` for the server build and `build/client` for client assets.

For example, if you were using Express, here's how you could do it.

üëâ **Update your `server.mjs` file**

```ts filename=server.mjs lines=[7-14,18-21,29,36-41]
import { createRequestHandler } from '@remix-run/express';
import { installGlobals } from '@remix-run/node';
import express from 'express';

installGlobals();

const viteDevServer =
  process.env.NODE_ENV === 'production'
    ? undefined
    : await import('vite').then((vite) =>
        vite.createServer({
          server: { middlewareMode: true },
        }),
      );

const app = express();

// handle asset requests
if (viteDevServer) {
  app.use(viteDevServer.middlewares);
} else {
  app.use(
    '/assets',
    express.static('build/client/assets', {
      immutable: true,
      maxAge: '1y',
    }),
  );
}
app.use(express.static('build/client', { maxAge: '1h' }));

// handle SSR requests
app.all(
  '*',
  createRequestHandler({
    build: viteDevServer
      ? () => viteDevServer.ssrLoadModule('virtual:remix/server-build')
      : await import('./build/server/index.js'),
  }),
);

const port = 3000;
app.listen(port, () => console.log('http://localhost:' + port));
```

üëâ **Update your `build`, `dev`, and `start` scripts**

```json filename=package.json lines=[3-5]
{
  "scripts": {
    "dev": "node ./server.mjs",
    "build": "remix vite:build",
    "start": "cross-env NODE_ENV=production node ./server.mjs"
  }
}
```

If you prefer, you can instead author your custom server in TypeScript.
You could then use tools like [`tsx`][tsx] or [`tsm`][tsm] to run your custom server:

```shellscript nonumber
tsx ./server.ts
node --loader tsm ./server.ts
```

Just remember that there might be some noticeable slowdown for initial server startup if you do this.

#### Migrating Cloudflare Functions

<docs-warning>

The Remix Vite plugin only officially supports [Cloudflare Pages][cloudflare-pages] which is specifically designed for fullstack applications, unlike [Cloudflare Workers Sites][cloudflare-workers-sites]. If you're currently on Cloudflare Workers Sites, refer to the [Cloudflare Pages migration guide][cloudflare-pages-migration-guide].

</docs-warning>

üëâ add `cloudflareDevProxyVitePlugin` **before** `remix` plugin to correctly override vite dev server's middleware!

```ts filename=vite.config.ts lines=[3,9]
import { vitePlugin as remix, cloudflareDevProxyVitePlugin } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [cloudflareDevProxyVitePlugin(), remix()],
});
```

Your Cloudflare app may be setting the [the Remix Config `server` field][remix-config-server] to generate a catch-all Cloudflare Function.
With Vite, this indirection is no longer necessary.
Instead, you can author a catch-all route directly for Cloudflare, just like how you would for Express or any other custom servers.

üëâ **Create a catch-all route for Remix**

```ts filename=functions/[[page]].ts
import { createPagesFunctionHandler } from '@remix-run/cloudflare-pages';

// @ts-ignore - the server build file is generated by `remix vite:build`
import * as build from '../build/server';

export const onRequest = createPagesFunctionHandler({
  build,
});
```

üëâ **Access Bindings and Environment Variables through `context.cloudflare.env` instead of `context.env`**

While you'll mostly use Vite during development, you can also use Wrangler to preview and deploy your app.

To learn more, see the [_Cloudflare_][cloudflare-vite] section of this document.

üëâ **Update your `package.json` scripts**

```json filename=package.json lines=[3-6]
{
  "scripts": {
    "dev": "remix vite:dev",
    "build": "remix vite:build",
    "preview": "wrangler pages dev ./build/client",
    "deploy": "wrangler pages deploy ./build/client"
  }
}
```

#### Migrate references to build output paths

When using the existing Remix compiler's default options, the server was compiled into `build` and the client was compiled into `public/build`. Due to differences with the way Vite typically works with its `public` directory compared to the existing Remix compiler, these output paths have changed.

üëâ **Update references to build output paths**

- The server is now compiled into `build/server` by default.
- The client is now compiled into `build/client` by default.

For example, to update the Dockerfile from the [Blues Stack][blues-stack]:

```diff filename=Dockerfile
-COPY --from=build /myapp/build /myapp/build
-COPY --from=build /myapp/public /myapp/public
+COPY --from=build /myapp/build/server /myapp/build/server
+COPY --from=build /myapp/build/client /myapp/build/client
```

#### Configure path aliases

The Remix compiler leverages the `paths` option in your `tsconfig.json` to resolve path aliases. This is commonly used in the Remix community to define `~` as an alias for the `app` directory.

Vite does not provide any path aliases by default. If you were relying on this feature, you can install the [vite-tsconfig-paths][vite-tsconfig-paths] plugin to automatically resolve path aliases from your `tsconfig.json` in Vite, matching the behavior of the Remix compiler:

üëâ **Install `vite-tsconfig-paths`**

```shellscript nonumber
npm install -D vite-tsconfig-paths
```

üëâ **Add `vite-tsconfig-paths` to your Vite config**

```ts filename=vite.config.ts lines=[3,6]
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';
import tsconfigPaths from 'vite-tsconfig-paths';

export default defineConfig({
  plugins: [remix(), tsconfigPaths()],
});
```

#### Remove `@remix-run/css-bundle`

Vite has built-in support for CSS side effect imports, PostCSS and CSS Modules, among other CSS bundling features. The Remix Vite plugin automatically attaches bundled CSS to the relevant routes.

The <nobr>[`@remix-run/css-bundle`][css-bundling]</nobr> package is redundant when using Vite since its `cssBundleHref` export will always be `undefined`.

üëâ **Uninstall `@remix-run/css-bundle`**

```shellscript nonumber
npm uninstall @remix-run/css-bundle
```

üëâ **Remove references to `cssBundleHref`**

```diff filename=app/root.tsx
- import { cssBundleHref } from "@remix-run/css-bundle";
  import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno

  export const links: LinksFunction = () => [
-   ...(cssBundleHref
-     ? [{ rel: "stylesheet", href: cssBundleHref }]
-     : []),
    // ...
  ];
```

If a route's `links` function is only used to wire up `cssBundleHref`, you can remove it entirely.

```diff filename=app/root.tsx
- import { cssBundleHref } from "@remix-run/css-bundle";
- import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno

- export const links: LinksFunction = () => [
-   ...(cssBundleHref
-     ? [{ rel: "stylesheet", href: cssBundleHref }]
-     : []),
- ];
```

#### Fix up CSS imports referenced in `links`

<docs-info>This is not required for other forms of [CSS bundling][css-bundling], e.g. CSS Modules, CSS side effect imports, Vanilla Extract, etc.</docs-info>

If you are [referencing CSS in a `links` function][regular-css], you'll need to update the corresponding CSS imports to use [Vite's explicit `?url` import syntax.][vite-url-imports]

üëâ **Add `?url` to CSS imports used in `links`**

<docs-warning>`.css?url` imports require Vite v5.1 or newer</docs-warning>

```diff
-import styles from "~/styles/dashboard.css";
+import styles from "~/styles/dashboard.css?url";

export const links = () => {
  return [
    { rel: "stylesheet", href: styles }
  ];
}
```

#### Enable Tailwind via PostCSS

If your project is using [Tailwind CSS][tailwind], you'll first need to ensure that you have a [PostCSS][postcss] config file which will get automatically picked up by Vite.
This is because the Remix compiler didn't require a PostCSS config file when Remix's `tailwind` option was enabled.

üëâ **Add PostCSS config if it's missing, including the `tailwindcss` plugin**

```js filename=postcss.config.mjs
export default {
  plugins: {
    tailwindcss: {},
  },
};
```

If your project already has a PostCSS config file, you'll need to add the `tailwindcss` plugin if it's not already present.
This is because the Remix compiler included this plugin automatically when Remix's [`tailwind` config option][tailwind-config-option] was enabled.

üëâ **Add the `tailwindcss` plugin to your PostCSS config if it's missing**

```js filename=postcss.config.mjs lines=[3]
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```

üëâ **Migrate Tailwind CSS import**

If you're [referencing your Tailwind CSS file in a `links` function][regular-css], you'll need to [migrate your Tailwind CSS import statement.][fix-up-css-imports-referenced-in-links]

#### Add Vanilla Extract plugin

If you're using [Vanilla Extract][vanilla-extract], you'll need to set up the Vite plugin.

üëâ **Install the official [Vanilla Extract plugin for Vite][vanilla-extract-vite-plugin]**

```shellscript nonumber
npm install -D @vanilla-extract/vite-plugin
```

üëâ **Add the Vanilla Extract plugin to your Vite config**

```ts filename=vite.config.ts lines=[2,6]
import { vitePlugin as remix } from '@remix-run/dev';
import { vanillaExtractPlugin } from '@vanilla-extract/vite-plugin';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [remix(), vanillaExtractPlugin()],
});
```

#### Add MDX plugin

If you're using [MDX][mdx], since Vite's plugin API is an extension of the [Rollup][rollup] plugin API, you should use the official [MDX Rollup plugin][mdx-rollup-plugin]:

üëâ **Install the MDX Rollup plugin**

```shellscript nonumber
npm install -D @mdx-js/rollup
```

<docs-info>

The Remix plugin expects to process JavaScript or TypeScript files, so any transpilation from other languages ‚Äî like MDX ‚Äî must be done first.
In this case, that means putting the MDX plugin _before_ the Remix plugin.

</docs-info>

üëâ **Add the MDX Rollup plugin to your Vite config**

```ts filename=vite.config.ts lines=[1,6]
import mdx from '@mdx-js/rollup';
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [mdx(), remix()],
});
```

##### Add MDX frontmatter support

The Remix compiler allowed you to define [frontmatter in MDX][mdx-frontmatter]. If you were using this feature, you can achieve this in Vite using [remark-mdx-frontmatter].

üëâ **Install the required [Remark][remark] frontmatter plugins**

```shellscript nonumber
npm install -D remark-frontmatter remark-mdx-frontmatter
```

üëâ **Pass the Remark frontmatter plugins to the MDX Rollup plugin**

```ts filename=vite.config.ts lines=[3-4,9-14]
import mdx from '@mdx-js/rollup';
import { vitePlugin as remix } from '@remix-run/dev';
import remarkFrontmatter from 'remark-frontmatter';
import remarkMdxFrontmatter from 'remark-mdx-frontmatter';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [
    mdx({
      remarkPlugins: [remarkFrontmatter, remarkMdxFrontmatter],
    }),
    remix(),
  ],
});
```

In the Remix compiler, the frontmatter export was named `attributes`. This differs from the frontmatter plugin's default export name of `frontmatter`. Although it's possible to configure the frontmatter export name, we recommend updating your app code to use the default export name instead.

üëâ **Rename MDX `attributes` export to `frontmatter` within MDX files**

```diff filename=app/posts/first-post.mdx
  ---
  title: Hello, World!
  ---

- # {attributes.title}
+ # {frontmatter.title}
```

üëâ **Rename MDX `attributes` export to `frontmatter` for consumers**

```diff filename=app/routes/posts/first-post.tsx
  import Component, {
-   attributes,
+   frontmatter,
  } from "./posts/first-post.mdx";
```

###### Define types for MDX files

üëâ **Add types for `*.mdx` files to `env.d.ts`**

```ts filename=env.d.ts lines=[4-8]
/// <reference types="@remix-run/node" />
/// <reference types="vite/client" />

declare module '*.mdx' {
  let MDXComponent: (props: any) => JSX.Element;
  export const frontmatter: any;
  export default MDXComponent;
}
```

###### Map MDX frontmatter to route exports

The Remix compiler allowed you to define `headers`, `meta` and `handle` route exports in your frontmatter. This Remix-specific feature is obviously not supported by the `remark-mdx-frontmatter` plugin. If you were using this feature, you should manually map frontmatter to route exports yourself:

üëâ **Map frontmatter to route exports for MDX routes**

```mdx lines=[10-11]
---
meta:
  - title: My First Post
  - name: description
    content: Isn't this awesome?
headers:
  Cache-Control: no-cache
---

export const meta = frontmatter.meta;
export const headers = frontmatter.headers;

# Hello World
```

Note that, since you're explicitly mapping MDX route exports, you're now free to use whatever frontmatter structure you like.

```mdx
---
title: My First Post
description: Isn't this awesome?
---

export const meta = () => {
  return [
    { title: frontmatter.title },
    {
      name: 'description',
      content: frontmatter.description,
    },
  ];
};

# Hello World
```

###### Update MDX filename usage

The Remix compiler also provided a `filename` export from all MDX files. This was primarily designed to enable linking to collections of MDX routes. If you were using this feature, you can achieve this in Vite via [glob imports][glob-imports] which give you a handy data structure that maps file names to modules. This makes it much easier to maintain a list of MDX files since you no longer need to import each one manually.

For example, to import all MDX files in the `posts` directory:

```ts
const posts = import.meta.glob('./posts/*.mdx');
```

This is equivalent to writing this by hand:

```ts
const posts = {
  './posts/a.mdx': () => import('./posts/a.mdx'),
  './posts/b.mdx': () => import('./posts/b.mdx'),
  './posts/c.mdx': () => import('./posts/c.mdx'),
  // etc.
};
```

You can also eagerly import all MDX files if you'd prefer:

```ts
const posts = import.meta.glob('./posts/*.mdx', {
  eager: true,
});
```

## Debugging

You can use the [`NODE_OPTIONS` environment variable][node-options] to start a debugging session:

```shellscript nonumber
NODE_OPTIONS="--inspect-brk" npm run dev
```

Then you can attach a debugger from your browser.
For example, in Chrome you can open up `chrome://inspect` or click the NodeJS icon in the dev tools to attach the debugger.

#### vite-plugin-inspect

[`vite-plugin-inspect`][vite-plugin-inspect] shows you each how each Vite plugin transforms your code and how long each plugin takes.

## Performance

Remix includes a `--profile` flag for performance profiling.

```shellscript nonumber
remix vite:build --profile
```

When running with `--profile`, a `.cpuprofile` file will be generated that can be shared or upload to speedscope.app to for analysis.

You can also profile in dev by pressing `p + enter` while the dev server is running to start a new profiling session or stop the current session.
If you need to profile dev server startup, you can also use the `--profile` flag to initialize a profiling session on startup:

```shellscript nonumber
remix vite:dev --profile
```

Remember that you can always check the [Vite performance docs][vite-perf] for more tips!

#### Bundle analysis

To visualize and analyze your bundle, you can use the [rollup-plugin-visualizer][rollup-plugin-visualizer] plugin:

```ts filename=vite.config.ts
import { vitePlugin as remix } from '@remix-run/dev';
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
  plugins: [
    remix(),
    // `emitFile` is necessary since Remix builds more than one bundle!
    visualizer({ emitFile: true }),
  ],
});
```

Then when you run `remix vite:build`, it'll generate a `stats.html` file in each of your bundles:

```
build
‚îú‚îÄ‚îÄ client
‚îÇ   ‚îú‚îÄ‚îÄ assets/
‚îÇ   ‚îú‚îÄ‚îÄ favicon.ico
‚îÇ   ‚îî‚îÄ‚îÄ stats.html üëà
‚îî‚îÄ‚îÄ server
    ‚îú‚îÄ‚îÄ index.js
    ‚îî‚îÄ‚îÄ stats.html üëà
```

Open up `stats.html` in your browser to analyze your bundle.

## Troubleshooting

Check the [debugging][debugging] and [performance][performance] sections for general troubleshooting tips.
Also, see if anyone else is having a similar problem by looking through the [known issues with the remix vite plugin on github][issues-vite].

#### HMR

If you are expecting hot updates but getting full page reloads,
check out our [discussion on Hot Module Replacement][hmr] to learn more about the limitations of React Fast Refresh and workarounds for common issues.

#### ESM / CJS

Vite supports both ESM and CJS dependencies, but sometimes you might still run into issues with ESM / CJS interop.
Usually, this is because a dependency is not properly configured to support ESM.
And we don't blame them, its [really tricky to support both ESM and CJS properly][modernizing-packages-to-esm].

For a walkthrough of fixing an example bug, check out [üé• How to Fix CJS/ESM Bugs in Remix][how-fix-cjs-esm].

To diagnose if one of your dependencies is misconfigured, check [publint][publint] or [_Are The Types Wrong_][arethetypeswrong].
Additionally, you can use the [vite-plugin-cjs-interop plugin][vite-plugin-cjs-interop] smooth over issues with `default` exports for external CJS dependencies.

Finally, you can also explicitly configure which dependencies to bundle into your server bundled
with [Vite's `ssr.noExternal` option][ssr-no-external] to emulate the Remix compiler's [`serverDependenciesToBundle`][server-dependencies-to-bundle] with the Remix Vite plugin.

#### Server code errors in browser during development

If you see errors in the browser console during development that point to server code, you likely need to [explicitly isolate server-only code][explicitly-isolate-server-only-code].
For example, if you see something like:

```shellscript
Uncaught ReferenceError: process is not defined
```

Then you'll need to track down which module is pulling in dependencies that except server-only globals like `process` and isolate code either in a [separate `.server` module or with `vite-env-only`][explicitly-isolate-server-only-code].
Since Vite uses Rollup to treeshake your code in production, these errors only occur in development.

#### Plugin usage with other Vite-based tools (e.g. Vitest, Storybook)

The Remix Vite plugin is only intended for use in your application's development server and production builds.
While there are other Vite-based tools such as Vitest and Storybook that make use of the Vite config file, the Remix Vite plugin has not been designed for use with these tools.
We currently recommend excluding the plugin when used with other Vite-based tools.

For Vitest:

```ts filename=vite.config.ts lines=[5]
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig, loadEnv } from 'vite';

export default defineConfig({
  plugins: [!process.env.VITEST && remix()],
  test: {
    environment: 'happy-dom',
    // Additionally, this is to load ".env.test" during vitest
    env: loadEnv('test', process.cwd(), ''),
  },
});
```

For Storybook:

```ts filename=vite.config.ts lines=[7]
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

const isStorybook = process.argv[1]?.includes('storybook');

export default defineConfig({
  plugins: [!isStorybook && remix()],
});
```

Alternatively, you can use separate Vite config files for each tool.
For example, to use a Vite config specifically scoped to Remix:

```shellscript nonumber
remix vite:dev --config vite.config.remix.ts
```

When not providing the Remix Vite plugin, your setup might also need to provide [Vite Plugin React][vite-plugin-react]. For example, when using Vitest:

```ts filename=vite.config.ts lines=[2,6]
import { vitePlugin as remix } from '@remix-run/dev';
import react from '@vitejs/plugin-react';
import { defineConfig, loadEnv } from 'vite';

export default defineConfig({
  plugins: [!process.env.VITEST ? remix() : react()],
  test: {
    environment: 'happy-dom',
    // Additionally, this is to load ".env.test" during vitest
    env: loadEnv('test', process.cwd(), ''),
  },
});
```

#### Styles disappearing in development when document remounts

When React is used to render the entire document (as Remix does) you can run into issues when elements are dynamically injected into the `head` element. If the document is re-mounted, the existing `head` element is removed and replaced with an entirely new one, removing any `style` elements that Vite injects during development.

This is a known React issue that is fixed in their [canary release channel][react-canaries]. If you understand the risks involved, you can pin your app to a specific [React version][react-versions] and then use [package overrides][package-overrides] to ensure this is the only version of React used throughout your project. For example:

```json filename=package.json
{
  "dependencies": {
    "react": "18.3.0-canary-...",
    "react-dom": "18.3.0-canary-..."
  },
  "overrides": {
    "react": "18.3.0-canary-...",
    "react-dom": "18.3.0-canary-..."
  }
}
```

<docs-info>For reference, this is how Next.js treats React versioning internally on your behalf, so this approach is more widely used than you might expect, even though it's not something Remix provides as a default.</docs-info>

It's worth stressing that this issue with styles that were injected by Vite only happens in development. **Production builds won't have this issue** since static CSS files are generated.

In Remix, this issue can surface when rendering alternates between your [root route's default component export][route-component] and its [ErrorBoundary][error-boundary] and/or [HydrateFallback][hydrate-fallback] exports since this results in a new document-level component being mounted.

It can also happen due to hydration errors since it causes React to re-render the entire page from scratch. Hydration errors can be caused by your app code, but they can also be caused by browser extensions that manipulate the document.

This is relevant for Vite because‚Äîduring development‚ÄîVite transforms CSS imports into JS files that inject their styles into the document as a side-effect. Vite does this to support lazy-loading and HMR of static CSS files.

For example, let's assume your app has the following CSS file:

<!-- prettier-ignore -->
```css filename=app/styles.css
* { margin: 0 }
```

During development, this CSS file will be transformed into the following JavaScript code when imported as a side effect:

<!-- prettier-ignore-start -->

<!-- eslint-skip -->

```js
import {createHotContext as __vite__createHotContext} from "/@vite/client";
import.meta.hot = __vite__createHotContext("/app/styles.css");
import {updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle} from "/@vite/client";
const __vite__id = "/path/to/app/styles.css";
const __vite__css = "*{margin:0}"
__vite__updateStyle(__vite__id, __vite__css);
import.meta.hot.accept();
import.meta.hot.prune(()=>__vite__removeStyle(__vite__id));
```

<!-- prettier-ignore-end -->

This transformation is not applied to production code, which is why this styling issue only affects development.

#### Wrangler errors in development

When using Cloudflare Pages, you may encounter the following error from `wrangler pages dev`:

```txt nonumber
ERROR: Your worker called response.clone(), but did not read the body of both clones.
This is wasteful, as it forces the system to buffer the entire response body
in memory, rather than streaming it through. This may cause your worker to be
unexpectedly terminated for going over the memory limit. If you only meant to
copy the response headers and metadata (e.g. in order to be able to modify
them), use `new Response(response.body, response)` instead.
```

This is a [known issue with Wrangler][cloudflare-request-clone-errors].

</docs-info>

## Acknowledgements

Vite is an amazing project, and we're grateful to the Vite team for their work.
Special thanks to [Matias Capeletto, Arnaud Barr√©, and Bjorn Lu from the Vite team][vite-team] for their guidance.

The Remix community was quick to explore Vite support, and we're grateful for their contributions:

- [Discussion: Consider using Vite][consider-using-vite]
- [remix-kit][remix-kit]
- [remix-vite][remix-vite]
- [vite-plugin-remix][vite-plugin-remix]

Finally, we were inspired by how other frameworks implemented Vite support:

- [Astro][astro]
- [SolidStart][solidstart]
- [SvelteKit][sveltekit]

[vite]: https://vitejs.dev
[template-cloudflare]: https://github.com/remix-run/remix/tree/main/templates/cloudflare
[public-path]: ../file-conventions/remix-config#publicpath
[server-build-path]: ../file-conventions/remix-config#serverbuildpath
[vite-config]: ../file-conventions/vite-config
[vite-plugins]: https://vitejs.dev/plugins
[vite-features]: https://vitejs.dev/guide/features
[tsx]: https://github.com/esbuild-kit/tsx
[tsm]: https://github.com/lukeed/tsm
[vite-tsconfig-paths]: https://github.com/aleclarson/vite-tsconfig-paths
[css-bundling]: ../styling/bundling
[regular-css]: ../styling/css
[vite-url-imports]: https://vitejs.dev/guide/assets.html#explicit-url-imports
[tailwind]: https://tailwindcss.com
[postcss]: https://postcss.org
[tailwind-config-option]: ../file-conventions/remix-config#tailwind
[vanilla-extract]: https://vanilla-extract.style
[vanilla-extract-vite-plugin]: https://vanilla-extract.style/documentation/integrations/vite
[mdx]: https://mdxjs.com
[rollup]: https://rollupjs.org
[mdx-rollup-plugin]: https://mdxjs.com/packages/rollup
[mdx-frontmatter]: https://mdxjs.com/guides/frontmatter
[remark-mdx-frontmatter]: https://github.com/remcohaszing/remark-mdx-frontmatter
[remark]: https://remark.js.org
[glob-imports]: https://vitejs.dev/guide/features.html#glob-import
[issues-vite]: https://github.com/remix-run/remix/labels/vite
[hmr]: ../discussion/hot-module-replacement
[vite-team]: https://vitejs.dev/team
[consider-using-vite]: https://github.com/remix-run/remix/discussions/2427
[remix-kit]: https://github.com/jrestall/remix-kit
[remix-vite]: https://github.com/sudomf/remix-vite
[vite-plugin-remix]: https://github.com/yracnet/vite-plugin-remix
[astro]: https://astro.build/
[solidstart]: https://start.solidjs.com/getting-started/what-is-solidstart
[sveltekit]: https://kit.svelte.dev/
[modernizing-packages-to-esm]: https://blog.isquaredsoftware.com/2023/08/esm-modernization-lessons/
[arethetypeswrong]: https://arethetypeswrong.github.io/
[publint]: https://publint.dev/
[vite-plugin-cjs-interop]: https://github.com/cyco130/vite-plugin-cjs-interop
[ssr-no-external]: https://vitejs.dev/config/ssr-options.html#ssr-noexternal
[server-dependencies-to-bundle]: https://remix.run/docs/en/main/file-conventions/remix-config#serverdependenciestobundle
[blues-stack]: https://github.com/remix-run/blues-stack
[global-node-polyfills]: ../other-api/node#polyfills
[vite-plugin-inspect]: https://github.com/antfu/vite-plugin-inspect
[vite-perf]: https://vitejs.dev/guide/performance.html
[node-options]: https://nodejs.org/api/cli.html#node_optionsoptions
[rollup-plugin-visualizer]: https://github.com/btd/rollup-plugin-visualizer
[debugging]: #debugging
[performance]: #performance
[explicitly-isolate-server-only-code]: #splitting-up-client-and-server-code
[route-component]: ../route/component
[error-boundary]: ../route/error-boundary
[hydrate-fallback]: ../route/hydrate-fallback
[react-canaries]: https://react.dev/blog/2023/05/03/react-canaries
[react-versions]: https://www.npmjs.com/package/react?activeTab=versions
[package-overrides]: https://docs.npmjs.com/cli/v10/configuring-npm/package-json#overrides
[wrangler-toml-bindings]: https://developers.cloudflare.com/workers/wrangler/configuration/#bindings
[cloudflare-pages]: https://pages.cloudflare.com
[cloudflare-workers-sites]: https://developers.cloudflare.com/workers/configuration/sites
[cloudflare-pages-migration-guide]: https://developers.cloudflare.com/pages/migrations/migrating-from-workers
[cloudflare-request-clone-errors]: https://github.com/cloudflare/workers-sdk/issues/3259
[cloudflare-pages-bindings]: https://developers.cloudflare.com/pages/functions/bindings/
[cloudflare-kv]: https://developers.cloudflare.com/pages/functions/bindings/#kv-namespaces
[cloudflare-workerd]: https://blog.cloudflare.com/workerd-open-source-workers-runtime
[wrangler-getplatformproxy]: https://developers.cloudflare.com/workers/wrangler/api/#getplatformproxy
[wrangler-getplatformproxy-return]: https://developers.cloudflare.com/workers/wrangler/api/#return-type-1
[remix-config-server]: https://remix.run/docs/en/main/file-conventions/remix-config#server
[cloudflare-vite]: #cloudflare
[vite-base]: https://vitejs.dev/config/shared-options.html#base
[how-fix-cjs-esm]: https://www.youtube.com/watch?v=jmNuEEtwkD4
[fix-up-css-imports-referenced-in-links]: #fix-up-css-imports-referenced-in-links
[vite-plugin-react]: https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react
[splitting-up-client-and-server-code]: ../discussion/server-vs-client

---

## File: ./hooks/index.md

---

title: Hooks
order: 6

---

---

## File: ./hooks/use-action-data.md

---

title: useActionData
toc: false

---

# `useActionData`

Returns the serialized data from the most recent route [action][action] or `undefined` if there isn't one. This hook only returns action data from the route in context - it can not access data from other parent or child routes.

```tsx lines=[10,14]
import type { ActionFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno
import { Form, useActionData } from '@remix-run/react';

export async function action({ request }: ActionFunctionArgs) {
  const body = await request.formData();
  const name = body.get('visitorsName');
  return json({ message: `Hello, ${name}` });
}

export default function Invoices() {
  const data = useActionData<typeof action>();
  return (
    <Form method="post">
      <input type="text" name="visitorsName" />
      {data ? data.message : 'Waiting...'}
    </Form>
  );
}
```

## Additional Resources

**Guides**

- [Form Validation][form_validation]

**Related API**

- [`action`][action]
- [`useNavigation`][use_navigation]

**Discussions**

- [Fullstack Data Flow][fullstack_data_flow]

[form_validation]: ../guides/form-validation
[action]: ../route/action
[use_navigation]: ../hooks/use-navigation
[fullstack_data_flow]: ../discussion/data-flow

---

## File: ./hooks/use-async-error.md

---

title: useAsyncError
new: true

---

# `useAsyncError`

Returns the rejection value from the closest [`<Await>`][await_component] component.

```tsx lines[4,12]
import { Await, useAsyncError } from '@remix-run/react';

function ErrorElement() {
  const error = useAsyncError();
  return <p>Uh Oh, something went wrong! {error.message}</p>;
}

<Await resolve={promiseThatRejects} errorElement={<ErrorElement />} />;
```

## Additional Resources

**Guides**

- [Streaming][streaming_guide]

**API**

- [`<Await/>`][await_component]
- [`useAsyncValue()`][use_async_value]

[await_component]: ../components/await
[streaming_guide]: ../guides/streaming
[use_async_value]: ../hooks/use-async-value

---

## File: ./hooks/use-async-value.md

---

title: useAsyncValue
new: true

---

# `useAsyncValue`

Returns the resolved data from the closest [`<Await>`][await_component] ancestor component.

```tsx
function SomeDescendant() {
  const value = useAsyncValue();
  // ...
}
```

```tsx
<Await resolve={somePromise}>
  <SomeDescendant />
</Await>
```

## Additional Resources

**Guides**

- [Streaming][streaming_guide]

**API**

- [`<Await/>`][await_component]
- [`useAsyncError`][use_async_error]

[await_component]: ../components/await
[streaming_guide]: ../guides/streaming
[use_async_error]: ../hooks/use-async-error

---

## File: ./hooks/use-before-unload.md

---

title: useBeforeUnload
toc: false

---

# `useBeforeUnload`

This hook is just a helper around [`window.beforeunload`][window_before_unload].

When users click links to pages they haven't visited yet, Remix loads the code-split modules for that page. If you deploy in the middle of a user's session, and you or your host removes the old files from the server (many do üò≠), then Remix's requests for those modules will fail. Remix recovers by automatically reloading the browser at the new URL. This should start over from the server with the latest version of your application. Most of the time this works out great, and user doesn't even know anything happened.

In this situation, you may need to save important application state on the page (to something like the browser's local storage), because the automatic page reload will lose any state you had.

Remix or not, this is a good practice. The user can change the url, accidentally close the browser window, etc.

```tsx lines=[1,7-11]
import { useBeforeUnload } from '@remix-run/react';

function SomeForm() {
  const [state, setState] = React.useState(null);

  // save it off before the automatic page reload
  useBeforeUnload(
    React.useCallback(() => {
      localStorage.stuff = state;
    }, [state]),
  );

  // read it in when they return
  React.useEffect(() => {
    if (state === null && localStorage.stuff != null) {
      setState(localStorage.stuff);
    }
  }, [state]);

  return <>{/*... */}</>;
}
```

[window_before_unload]: https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event

---

## File: ./hooks/use-blocker.md

---

## title: useBlocker

# `useBlocker`

The `useBlocker` hook allows you to prevent the user from navigating away from the current location, and present them with a custom UI to allow them to confirm the navigation.

<docs-info>
This only works for client-side navigations within your React Router application and will not block document requests. To prevent document navigations you will need to add your own <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event" target="_blank">`beforeunload`</a> event handler.
</docs-info>

<docs-warning>
Blocking a user from navigating is a bit of an anti-pattern, so please carefully consider any usage of this hook and use it sparingly. In the de-facto use case of preventing a user navigating away from a half-filled form, you might consider persisting unsaved state to `sessionStorage` and automatically re-filling it if they return instead of blocking them from navigating away.
</docs-warning>

```tsx
function ImportantForm() {
  const [value, setValue] = React.useState('');

  // Block navigating elsewhere when data has been entered into the input
  const blocker = useBlocker(
    ({ currentLocation, nextLocation }) =>
      value !== '' && currentLocation.pathname !== nextLocation.pathname,
  );

  return (
    <Form method="post">
      <label>
        Enter some important data:
        <input name="data" value={value} onChange={(e) => setValue(e.target.value)} />
      </label>
      <button type="submit">Save</button>

      {blocker.state === 'blocked' ? (
        <div>
          <p>Are you sure you want to leave?</p>
          <button onClick={() => blocker.proceed()}>Proceed</button>
          <button onClick={() => blocker.reset()}>Cancel</button>
        </div>
      ) : null}
    </Form>
  );
}
```

For a more complete example, please refer to the [example][example] in the repository.

## Properties

### `state`

The current state of the blocker

- `unblocked` - the blocker is idle and has not prevented any navigation
- `blocked` - the blocker has prevented a navigation
- `proceeding` - the blocker is proceeding through from a blocked navigation

### `location`

When in a `blocked` state, this represents the location to which we blocked a navigation. When in a `proceeding` state, this is the location being navigated to after a `blocker.proceed()` call.

## Methods

### `proceed()`

When in a `blocked` state, you may call `blocker.proceed()` to proceed to the blocked location.

### `reset()`

When in a `blocked` state, you may call `blocker.reset()` to return the blocker back to an `unblocked` state and leave the user at the current location.

[example]: https://github.com/remix-run/react-router/tree/main/examples/navigation-blocking

---

## File: ./hooks/use-fetcher.md

---

## title: useFetcher

# `useFetcher`

A hook for interacting with the server outside of navigation.

```tsx
import { useFetcher } from '@remix-run/react';

export function SomeComponent() {
  const fetcher = useFetcher();
  // ...
}
```

## Options

### `key`

By default, `useFetcher` generates a unique fetcher scoped to that component (however, it may be looked up in [`useFetchers()`][use_fetchers] while in-flight). If you want to identify a fetcher with your own key such that you can access it from elsewhere in your app, you can do that with the `key` option:

```tsx lines=[2,8]
function AddToBagButton() {
  const fetcher = useFetcher({ key: 'add-to-bag' });
  return <fetcher.Form method="post">...</fetcher.Form>;
}

// Then, up in the header...
function CartCount({ count }) {
  const fetcher = useFetcher({ key: 'add-to-bag' });
  const inFlightCount = Number(fetcher.formData?.get('quantity') || 0);
  const optimisticCount = count + inFlightCount;
  return (
    <>
      <BagIcon />
      <span>{optimisticCount}</span>
    </>
  );
}
```

## Components

### `fetcher.Form`

Just like [`<Form>`][form_component] except it doesn't cause a navigation.

```tsx
function SomeComponent() {
  const fetcher = useFetcher();
  return (
    <fetcher.Form method="post" action="/some/route">
      <input type="text" />
    </fetcher.Form>
  );
}
```

## Methods

### `fetcher.submit(formData, options)`

Submits form data to a route. While multiple nested routes can match a URL, only the leaf route will be called.

The `formData` can be multiple types:

- [`FormData`][form_data] - A `FormData` instance.
- [`HTMLFormElement`][html_form_element] - A [`<form>`][form_element] DOM element.
- `Object` - An object of key/value pairs that will be converted to a `FormData` instance by default. You can pass a more complex object and serialize it as JSON by specifying `encType: "application/json"`. See [`useSubmit`][use-submit] for more details.

If the method is `GET`, then the route [`loader`][loader] is being called and with the `formData` serialized to the url as [`URLSearchParams`][url_search_params]. If `DELETE`, `PATCH`, `POST`, or `PUT`, then the route [`action`][action] is being called with `formData` as the body.

```tsx
// Submit a FormData instance (GET request)
const formData = new FormData();
fetcher.submit(formData);

// Submit the HTML form element
fetcher.submit(event.currentTarget.form, {
  method: 'POST',
});

// Submit key/value JSON as a FormData instance
fetcher.submit({ serialized: 'values' }, { method: 'POST' });

// Submit raw JSON
fetcher.submit(
  {
    deeply: {
      nested: {
        json: 'values',
      },
    },
  },
  {
    method: 'POST',
    encType: 'application/json',
  },
);
```

`fetcher.submit` is a wrapper around a [`useSubmit`][use-submit] call for the fetcher instance, so it also accepts the same options as `useSubmit`.

### `fetcher.load(href, options)`

Loads data from a route loader. While multiple nested routes can match a URL, only the leaf route will be called.

```ts
fetcher.load('/some/route');
fetcher.load('/some/route?foo=bar');
```

`fetcher.load`'s revalidate by default after action submissions and explicit revalidation requests via [`useRevalidator`][userevalidator]. Because `fetcher.load` loads a specific URL they don't revalidate on changes to route param or URL search param. You can use [`shouldRevalidate`][shouldrevalidate] to optimize which data should be reloaded.

#### `options.flushSync`

The `flushSync` option tells React Router DOM to wrap the initial state update for this `fetcher.load` in a [`ReactDOM.flushSync`][flush-sync] call instead of the default [`React.startTransition`][start-transition]. This allows you to perform synchronous DOM actions immediately after the update is flushed to the DOM.

<docs-warning>`ReactDOM.flushSync` de-optimizes React and can hurt the performance of your app.</docs-warning>

## Properties

### `fetcher.state`

You can know the state of the fetcher with `fetcher.state`. It will be one of:

- **idle** - Nothing is being fetched.
- **submitting** - A form has been submitted. If the method is `GET`, then the route `loader` is being called. If `DELETE`, `PATCH`, `POST`, or `PUT`, then the route `action` is being called.
- **loading** - The loaders for the routes are being reloaded after an `action` submission.

### `fetcher.data`

The returned response data from your `action` or `loader` is stored here. Once the data is set, it persists on the fetcher even through reloads and resubmissions (like calling `fetcher.load()` again after having already read the data).

### `fetcher.formData`

The `FormData` instance that was submitted to the server is stored here. This is useful for optimistic UIs.

### `fetcher.formAction`

The URL of the submission.

### `fetcher.formMethod`

The form method of the submission.

## Additional Resources

**Discussions**

- [Form vs. Fetcher][form_vs_fetcher]
- [Network Concurrency Management][network_concurrency_management]

**Videos**

- [Concurrent Mutations w/ useFetcher][concurrent_mutations_with_use_fetcher]
- [Optimistic UI][optimistic_ui]

[form_component]: ../components/form
[form_data]: https://developer.mozilla.org/en-US/docs/Web/API/FormData
[html_form_element]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement
[form_element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form
[loader]: ../route/loader
[url_search_params]: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams
[action]: ../route/action
[form_vs_fetcher]: ../discussion/form-vs-fetcher
[network_concurrency_management]: ../discussion/concurrency
[concurrent_mutations_with_use_fetcher]: https://www.youtube.com/watch?v=vTzNpiOk668&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6
[optimistic_ui]: https://www.youtube.com/watch?v=EdB_nj01C80&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6
[use_fetchers]: ./use-fetchers
[flush-sync]: https://react.dev/reference/react-dom/flushSync
[start-transition]: https://react.dev/reference/react/startTransition
[use-submit]: ./use-submit
[userevalidator]: ./use-revalidator
[shouldrevalidate]: ../route/should-revalidate#shouldrevalidate

---

## File: ./hooks/use-fetchers.md

---

title: useFetchers
toc: false

---

# `useFetchers`

Returns an array of all in-flight fetchers. This is useful for components throughout the app that didn't create the fetchers but want to use their submissions to participate in optimistic UI.

```tsx
import { useFetchers } from '@remix-run/react';

function SomeComponent() {
  const fetchers = useFetchers();
  fetchers[0].formData; // FormData
  fetchers[0].state; // etc.
  // ...
}
```

The fetchers don't contain [`fetcher.Form`][fetcher_form], [`fetcher.submit`][fetcher_submit], or [`fetcher.load`][fetcher_load], only the states like [`fetcher.formData`][fetcher_form_data], [`fetcher.state`][fetcher_state], etc.

## Additional Resources

**Discussions**

- [Form vs. Fetcher][form_vs_fetcher]
- [Pending, Optimistic UI][pending_optimistic_ui]

**API**

- [`useFetcher`][use_fetcher]
- [`v3_fetcherPersist`][fetcherpersist]

[fetcher_form]: ./use-fetcher#fetcherform
[fetcher_submit]: ./use-fetcher#fetchersubmitformdata-options
[fetcher_load]: ./use-fetcher#fetcherloadhref
[fetcher_form_data]: ./use-fetcher#fetcherformdata
[fetcher_state]: ./use-fetcher#fetcherstate
[form_vs_fetcher]: ../discussion/form-vs-fetcher
[pending_optimistic_ui]: ../discussion/pending-ui
[use_fetcher]: ./use-fetcher
[fetcherpersist]: ../file-conventions/remix-config#future

---

## File: ./hooks/use-form-action.md

---

## title: useFormAction

# `useFormAction`

Resolves the URL to the closest route in the component hierarchy instead of the current URL of the app.

This is used internally by [`<Form>`][form_component] to resolve the action to the closest route, but can be used generically as well.

```tsx
import { useFormAction } from '@remix-run/react';

function SomeComponent() {
  // closest route URL
  const action = useFormAction();

  // closest route URL + "destroy"
  const destroyAction = useFormAction('destroy');
}
```

## Signature

```
useFormAction(action, options)
```

### `action`

Optional. The action to append to the closest route URL.

### `options`

The only option is `{ relative: "route" | "path"}`.

- **route** default - relative to the route hierarchy, not the URL
- **path** - makes the action relative to the URL paths, so `..` will remove one URL segment.

[form_component]: ../components/form

---

## File: ./hooks/use-href.md

---

## title: useHref

# `useHref`

Resolves a full URL against the current location to be used as an [`href`][anchor_element_href_attribute] to a [`link`][anchor_element]. If a relative path is supplied, it will resolve to a full URL.

```tsx
import { useHref } from '@remix-run/react';

function SomeComponent() {
  const href = useHref('some/where');

  return <a href={href}>Link</a>;
}
```

## Signature

```
useHref(to, options)
```

### `to`

Optional. The path to append to the resolved URL.

<docs-info>Please see the [Splat Paths][relativesplatpath] section on the `useResolvedPath` docs for a note on the behavior of the `future.v3_relativeSplatPath` future flag for relative `useHref()` behavior within splat routes</docs-info>

### `options`

The only option is `{ relative: "route" | "path"}`, which defines the behavior when resolving relative URLs.

- **route** default - relative to the route hierarchy, not the URL
- **path** - makes the action relative to the URL paths, so `..` will remove one URL segment.

[anchor_element_href_attribute]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#href
[anchor_element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link
[relativesplatpath]: ./use-resolved-path#splat-paths

---

## File: ./hooks/use-loader-data.md

---

## title: useLoaderData

# `useLoaderData`

Returns the serialized data from the closest route [`loader`][loader].

```tsx lines=[2,9]
import { json } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData } from '@remix-run/react';

export async function loader() {
  return json(await fakeDb.invoices.findAll());
}

export default function Invoices() {
  const invoices = useLoaderData<typeof loader>();
  // ...
}
```

## Additional Resources

**Discussions**

- [Fullstack Data Flow][fullstack_data_flow]
- [State Management][state_management]

**API**

- [`loader`][loader]
- [`useFetcher`][use_fetcher]

[loader]: ../route/loader
[fullstack_data_flow]: ../discussion/data-flow
[state_management]: ../discussion/state-management
[use_fetcher]: ./use-fetcher

---

## File: ./hooks/use-location.md

---

## title: useLocation

# `useLocation`

Returns the current location object.

```tsx
import { useLocation } from '@remix-run/react';

function SomeComponent() {
  const location = useLocation();
  // ...
}
```

## Properties

### `location.hash`

The hash of the current URL.

### `location.key`

The unique key of this location.

### `location.pathname`

The path of the current URL.

### `location.search`

The query string of the current URL.

### `location.state`

The state value of the location created by [`<Link state>`][link_component_state] or [`navigate`][navigate].

[link_component_state]: ../components/link#state
[navigate]: ./use-navigate

---

## File: ./hooks/use-matches.md

---

title: useMatches
toc: false

---

# `useMatches`

Returns the current route matches on the page. This is useful for creating layout abstractions with your current routes.

```tsx
function SomeComponent() {
  const matches = useMatches();

  // ...
}
```

`matches` has the following shape:

```ts
[
  { id, pathname, data, params, handle }, // root route
  { id, pathname, data, params, handle }, // layout route
  { id, pathname, data, params, handle }, // child route
  // etc.
];
```

## Additional Resources

- [Breadcrumbs Guide][breadcrumbs-guide]

[breadcrumbs-guide]: ../guides/breadcrumbs

---

## File: ./hooks/use-navigate.md

---

## title: useNavigate

# `useNavigate`

The `useNavigate` hook returns a function that lets you navigate programmatically in the browser in response to user interactions or effects.

```tsx
import { useNavigate } from '@remix-run/react';

function SomeComponent() {
  const navigate = useNavigate();
  return (
    <button
      onClick={() => {
        navigate(-1);
      }}
    />
  );
}
```

It's often better to use [`redirect`][redirect] in [`action`][action]s and [`loader`][loader]s than this hook, but it still has use cases.

## Arguments

### `to: string`

The most basic usage takes an href string:

```tsx
navigate('/some/path');
```

Paths can be relative:

```tsx
navigate('..');
navigate('../other/path');
```

<docs-info>Please see the [Splat Paths][relativesplatpath] section on the `useResolvedPath` docs for a note on the behavior of the `future.v3_relativeSplatPath` future flag for relative `useNavigate()` behavior within splat routes</docs-info>

### `to: Partial<Path>`

You can also pass a `Partial<Path>` value:

```tsx
navigate({
  pathname: '/some/path',
  search: '?query=string',
  hash: '#hash',
});
```

### `to: Number`

Passing a number will tell the browser to go back or forward in the history stack:

```tsx
navigate(-1); // go back
navigate(1); // go forward
navigate(-2); // go back two
```

Note that this may send you out of your application since the history stack of the browser isn't scoped to just your application.

### `options`

The second argument is an options object:

```tsx
navigate('.', {
  replace: true,
  relative: 'path',
  state: { some: 'state' },
});
```

- **replace**: boolean - replace the current entry in the history stack instead of pushing a new one
- **relative**: `"route" | "path"` - defines the relative path behavior for the link
  - `"route"` will use the route hierarchy so `".."` will remove all URL segments of the current route pattern while `"path"` will use the URL path so `".."` will remove one URL segment
- **state**: any - adds persistent client side routing state to the next location
- **preventScrollReset**: boolean - if you are using [`<ScrollRestoration>`][scroll-restoration], prevent the scroll position from being reset to the top of the window when navigating
- **flushSync**: boolean - wraps the initial state update for this navigation in a [`ReactDOM.flushSync`][flush-sync] call instead of the default [`React.startTransition`][start-transition]
- **viewTransition**: boolean - enables a [View Transition][view-transitions] for this navigation by wrapping the final state update in `document.startViewTransition()`
  - If you need to apply specific styles for this view transition, you will also need to leverage the [`useViewTransitionState()`][use-view-transition-state]

[redirect]: ../utils/redirect
[flush-sync]: https://react.dev/reference/react-dom/flushSync
[start-transition]: https://react.dev/reference/react/startTransition
[view-transitions]: https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API
[use-view-transition-state]: ../hooks//use-view-transition-state
[action]: ../route/action
[loader]: ../route/loader
[relativesplatpath]: ./use-resolved-path#splat-paths
[scroll-restoration]: ../components/scroll-restoration#preventing-scroll-reset

---

## File: ./hooks/use-navigation.md

---

## title: useNavigation

# `useNavigation`

This hook provides information about a pending page navigation.

```js
import { useNavigation } from '@remix-run/react';

function SomeComponent() {
  const navigation = useNavigation();
  // ...
}
```

## Properties

### `navigation.formAction`

The action of the form that was submitted, if any.

```tsx
// set from either one of these
<Form action="/some/where" />;
submit(formData, { action: '/some/where' });
```

### `navigation.formMethod`

The method of the form that was submitted, if any.

```tsx
// set from either one of these
<Form method="get" />;
submit(formData, { method: 'get' });
```

### `navigation.formData`

Any `DELETE`, `PATCH`, `POST`, or `PUT` navigation that started from a [`<Form>`][form-component] or [`useSubmit`][use-submit] will have your form's submission data attached to it. This is primarily useful to build "Optimistic UI" with the `submission.formData` [`FormData`][form-data] object.

For example:

```tsx
// This form has the `email` field
<Form method="post" action="/signup">
  <input name="email" />
</Form>;

// So a navigation will have the field's value in `navigation.formData`
// while the navigation is pending.
navigation.formData.get('email');
```

In the case of a `GET` form submission, `formData` will be empty and the data will be reflected in `navigation.location.search`.

### `navigation.location`

This tells you what the next location is going to be.

### `navigation.state`

- **idle** - There is no navigation pending.
- **submitting** - A route action is being called due to a form submission using POST, PUT, PATCH, or DELETE
- **loading** - The loaders for the next routes are being called to render the next page

Normal navigations and GET form submissions transition through these states:

```
idle ‚Üí loading ‚Üí idle
```

Form submissions with POST, PUT, PATCH, or DELETE transition through these states:

```
idle ‚Üí submitting ‚Üí loading ‚Üí idle
```

[form-component]: ../components/form
[use-submit]: ./use-submit
[form-data]: https://developer.mozilla.org/en-US/docs/Web/API/FormData

---

## File: ./hooks/use-navigation-type.md

---

## title: useNavigationType

# `useNavigationType`

Returns the type of navigation used when the user arrived at the current location.

```tsx
import { useNavigationType } from '@remix-run/react';

function SomeComponent() {
  const navigationType = useNavigationType();
  // ...
}
```

## Return Values

- **PUSH**: The user came to the current page via a push action on the history stack: clicking a link or submitting a form, etc.
- **REPLACE**: The user came to the current page via a replace action on the history stack: clicking a link with `<Link replace>`, submitting a form with `<Form replace>` or calling `navigate(to, { replace: true })`, etc.
- **POP**: The user came to the current page via a pop action on the history stack: clicking the back or forward button, calling `navigate(-1)` or `navigate(1)`, etc.

## Additional Resources

- [`<Link replace>`][link-replace]
- [`<Form replace>`][form-replace]
- [`navigate` options][navigate-options]

[link-replace]: ../components/link#replace
[form-replace]: ../components/form#replace
[navigate-options]: ../hooks/use-navigate#options

---

## File: ./hooks/use-outlet.md

---

## title: useOutlet

# `useOutlet`

Returns the element for the child route at this level of the route hierarchy. This hook is used internally by [`<Outlet>`][outlet-component] to render child routes.

```tsx
import { useOutlet } from '@remix-run/react';
```

[outlet-component]: ../components/outlet

---

## File: ./hooks/use-outlet-context.md

---

## title: useOutletContext

# `useOutletContext`

Convenience API over [React Context][react-context] that returns the context value from the closest parent [`<Outlet context={val} />`][outlet-context] component.

```tsx
import { useOutletContext } from '@remix-run/react';

function Child() {
  const myValue = useOutletContext();
  // ...
}
```

## Additional Resources

- [`<Outlet context>`][outlet-context]

[react-context]: https://react.dev/learn/passing-data-deeply-with-context
[outlet-context]: ../components/outlet#context

---

## File: ./hooks/use-params.md

---

## title: useParams

# `useParams`

Returns an object of key/value pairs of the dynamic params from the current URL that were matched by the routes. Child routes inherit all params from their parent routes.

```tsx
import { useParams } from '@remix-run/react';

function SomeComponent() {
  const params = useParams();
  // ...
}
```

Assuming a route like `routes/posts/$postId.tsx` is matched by `/posts/123` then `params.postId` will be `"123"`. Params for [splat routes][splat-routes] are available as `params["*"]`.

[splat-routes]: ../file-conventions/routes#splat-routes

---

## File: ./hooks/use-prompt.md

---

## title: unstable_usePrompt

# `unstable_usePrompt`

The `unstable_usePrompt` hook allows you to prompt the user for confirmation via [`window.confirm`][window-confirm] prior to navigating away from the current location.

<docs-info>
This only works for client-side navigations within your React Router application and will not block document requests. To prevent document navigations you will need to add your own <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event" target="_blank">`beforeunload`</a> event handler.
</docs-info>

<docs-warning>
Blocking a user from navigating is a bit of an anti-pattern, so please carefully consider any usage of this hook and use it sparingly. In the de-facto use case of preventing a user navigating away from a half-filled form, you might consider persisting unsaved state to `sessionStorage` and automatically re-filling it if they return instead of blocking them from navigating away.
</docs-warning>

<docs-warning>
We do not plan to remove the `unstable_` prefix from this hook because the behavior is non-deterministic across browsers when the prompt is open, so React Router cannot guarantee correct behavior in all scenarios.  To avoid this non-determinism, we recommend using `useBlocker` instead which also gives you control over the confirmation UX.
</docs-warning>

```tsx
function ImportantForm() {
  const [value, setValue] = React.useState('');

  // Block navigating elsewhere when data has been entered into the input
  unstable_usePrompt({
    message: 'Are you sure?',
    when: ({ currentLocation, nextLocation }) =>
      value !== '' && currentLocation.pathname !== nextLocation.pathname,
  });

  return (
    <Form method="post">
      <label>
        Enter some important data:
        <input name="data" value={value} onChange={(e) => setValue(e.target.value)} />
      </label>
      <button type="submit">Save</button>
    </Form>
  );
}
```

[window-confirm]: https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm

---

## File: ./hooks/use-resolved-path.md

---

## title: useResolvedPath

# `useResolvedPath`

Resolves the `pathname` of the given `to` value against the pathname of the current location and returns a `Path` object.

```tsx
import { useResolvedPath } from '@remix-run/react';

function SomeComponent() {
  const path = useResolvedPath('../some/where');
  path.pathname;
  path.search;
  path.hash;
  // ...
}
```

This is useful when building links from relative values and used internally for [`<NavLink>`][nav-link-component].

## Splat Paths

The original logic for React Router's `useResolvedPath` hook behaved differently for splat paths which in hindsight was incorrect/buggy behavior. Please see the [React Router Docs][rr-use-resolved-path-splat] for a longer explanation but this was determined to be a "breaking bug fix" and was fixed behind a future flag in React Router and exposed up through a [`v3_relativeSplatPath`][remix-config-future] Future Flag in Remix. This will become the default behavior in Remix v3, so it is recommended to update your applications at your convenience to be better prepared for the eventual v3 upgrade.

It should be noted that this is the foundation for all relative routing in Remix, so this applies to the following relative path code flows as well:

- `<Link to>`
- `useNavigate()`
- `useHref()`
- `<Form action>`
- `useSubmit()`
- Relative path `redirect` responses returned from loaders and actions

### Behavior without the flag

When this flag is not enabled, the default behavior is that when resolving relative paths inside of a splat route, the splat portion of the path is ignored. So, within a `routes/dashboard.$.tsx` file, `useResolvedPath(".")` would resolve to `/dashboard` even if the current URL was `/dashboard/teams`.

### Behavior with the flag

When you enable the flag, this "bug" is fixed so that path resolution is consistent across all route types, and `useResolvedPath(".")` always resolves to the current pathname for the contextual route. This includes any dynamic param or splat param values, so within a `routes/dashboard.$.tsx` file, `useResolvedPath(".")` would resolve to `/dashboard/teams` when the current URL was `/dashboard/teams`.

## Additional Resources

- [`resolvePath`][rr-resolve-path]

[nav-link-component]: ../components/nav-link
[rr-resolve-path]: https://reactrouter.com/v6/utils/resolve-path
[rr-use-resolved-path-splat]: https://reactrouter.com/v6/hooks/use-resolved-path#splat-paths
[remix-config-future]: https://remix.run/docs/en/main/file-conventions/remix-config#future

---

## File: ./hooks/use-revalidator.md

---

title: useRevalidator
new: true

---

# `useRevalidator`

Revalidate the data on the page for reasons outside of normal data mutations like window focus or polling on an interval.

```tsx
import { useRevalidator } from '@remix-run/react';

function WindowFocusRevalidator() {
  const revalidator = useRevalidator();

  useFakeWindowFocus(() => {
    revalidator.revalidate();
  });

  return <div hidden={revalidator.state === 'idle'}>Revalidating...</div>;
}
```

Remix already revalidates the data on the page automatically when actions are called. If you find yourself using this for normal CRUD operations on your data in response to user interactions, you're probably not taking advantage of the other APIs like [`<Form>`][form-component], [`useSubmit`][use-submit], or [`useFetcher`][use-fetcher] that do this automatically.

## Properties

### `revalidator.state`

The state of the revalidation. Either `"idle"` or `"loading"`.

### `revalidator.revalidate()`

Initiates a revalidation.

```tsx
function useLivePageData() {
  const revalidator = useRevalidator();
  const interval = useInterval(5000);

  useEffect(() => {
    if (revalidator.state === 'idle') {
      revalidator.revalidate();
    }
  }, [interval, revalidator]);
}
```

## Notes

While you can render multiple occurrences of `useRevalidator` at the same time, underneath it is a singleton. This means when one `revalidator.revalidate()` is called, all instances go into the `"loading"` state together (or rather, they all update to report the singleton state).

Race conditions are automatically handled when calling `revalidate()` when a revalidation is already in progress for any other reason.

If a navigation happens while a revalidation is in flight, the revalidation will be cancelled and fresh data will be requested from all loaders for the next page.

[form-component]: ../components/form
[use-fetcher]: ./use-fetcher
[use-submit]: ./use-submit

---

## File: ./hooks/use-route-error.md

---

title: useRouteError
new: true

---

# `useRouteError`

Accesses the error thrown during an [`action`][action], [`loader`][loader], or rendering to be used in an [`ErrorBoundary`][error-boundary].

```jsx filename=routes/some-route.tsx
export function ErrorBoundary() {
  const error = useRouteError();
  return <div>{error.message}</div>;
}
```

## Additional Resources

**Guides**

- [Error Handling Guide][error-handling-guide]

**API Reference**

- [`ErrorBoundary`][error-boundary]

[action]: ../route/action
[loader]: ../route/loader
[error-boundary]: ../route/error-boundary
[error-handling-guide]: ../guides/errors

---

## File: ./hooks/use-route-loader-data.md

---

title: useRouteLoaderData
toc: false

---

# `useRouteLoaderData`

Returns the loader data for a given route by ID.

```tsx
import { useRouteLoaderData } from '@remix-run/react';

function SomeComponent() {
  const { user } = useRouteLoaderData('root');
}
```

Remix creates the route IDs automatically. They are simply the path of the route file relative to the app folder without the extension.

| Route Filename             | Route ID             |
| -------------------------- | -------------------- |
| `app/root.tsx`             | `"root"`             |
| `app/routes/teams.tsx`     | `"routes/teams"`     |
| `app/routes/teams.$id.tsx` | `"routes/teams.$id"` |

---

## File: ./hooks/use-search-params.md

---

## title: useSearchParams

# `useSearchParams`

Returns a tuple of the current URL's [`searchParams`][search-params] and a function to update them. Setting the search params causes a navigation.

```tsx
import { useSearchParams } from '@remix-run/react';

export function SomeComponent() {
  const [searchParams, setSearchParams] = useSearchParams();
  // ...
}
```

## Signature

<!-- eslint-disable -->

```tsx
const [searchParams, setSearchParams] = useSearchParams();
```

### `searchParams`

The first value returned is a Web [URLSearchParams][url-search-params] object.

### `setSearchParams(params, navigateOptions)`

The second value returned is a function to set new search params and causes a navigation when called. You can pass an optional second argument with [navigate options][navigateoptions] to configure the navigation.

```tsx
<button
  onClick={() => {
    const params = new URLSearchParams();
    params.set('someKey', 'someValue');
    setSearchParams(params, {
      preventScrollReset: true,
    });
  }}
/>
```

### `setSearchParams((prevParams) => newParams, navigateOptions)`

The setter function also supports a function for setting new search params.

```tsx
<button
  onClick={() => {
    setSearchParams((prev) => {
      prev.set('someKey', 'someValue');
      return prev;
    });
  }}
/>
```

[search-params]: https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams
[url-search-params]: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams
[navigateoptions]: ./use-navigate#options

---

## File: ./hooks/use-submit.md

---

## title: useSubmit

# `useSubmit`

The imperative version of [`<Form>`][form-component] that lets you, the programmer, submit a form instead of the user.

```tsx
import { useSubmit } from '@remix-run/react';

function SomeComponent() {
  const submit = useSubmit();
  return (
    <Form
      onChange={(event) => {
        submit(event.currentTarget);
      }}
    />
  );
}
```

## Signature

```tsx
submit(targetOrData, options);
```

### `targetOrData`

Can be any of the following:

**[`HTMLFormElement`][html-form-element] instance**

```tsx
<Form
  onSubmit={(event) => {
    submit(event.currentTarget);
  }}
/>
```

**[`FormData`][form-data] instance**

```tsx
const formData = new FormData();
formData.append('myKey', 'myValue');
submit(formData, { method: 'post' });
```

**Plain object that will be serialized as `FormData`**

```tsx
submit({ myKey: 'myValue' }, { method: 'post' });
```

**Plain object that will be serialized as JSON**

```tsx
submit({ myKey: 'myValue' }, { method: 'post', encType: 'application/json' });
```

### `options`

Options for the submission, the same as [`<Form>`][form-component] props. All options are optional.

- **action**: The href to submit to. Default is the current route path.
- **method**: The HTTP method to use like POST, default is GET.
- **encType**: The encoding type to use for the form submission: `application/x-www-form-urlencoded`, `multipart/form-data`, `application/json`, or `text/plain`. Default is `application/x-www-form-urlencoded`.
- **navigate**: Specify `false` to submit using a fetcher instead of performing a navigation
- **fetcherKey**: The fetcher key to use when submitting using a fetcher via `navigate: false`
- **preventScrollReset**: Prevents the scroll position from being reset to the top of the window when the data is submitted. Default is `false`.
- **replace**: Replaces the current entry in the history stack, instead of pushing the new entry. Default is `false`.
- **relative**: Defines relative route resolution behavior. Either `"route"` (relative to the route hierarchy) or `"path"` (relative to the URL).
- **flushSync**: Wraps the initial state update for this navigation in a [`ReactDOM.flushSync`][flush-sync] call instead of the default [`React.startTransition`][start-transition]
- **viewTransition**: Enables a [View Transition][view-transitions] for this navigation by wrapping the final state update in `document.startViewTransition()`
  - If you need to apply specific styles for this view transition, you will also need to leverage the [`useViewTransitionState()`][use-view-transition-state]

```tsx
submit(data, {
  action: '',
  method: 'post',
  encType: 'application/x-www-form-urlencoded',
  preventScrollReset: false,
  replace: false,
  relative: 'route',
});
```

<docs-info>Please see the [Splat Paths][relativesplatpath] section on the `useResolvedPath` docs for a note on the behavior of the `future.v3_relativeSplatPath` future flag for relative `useSubmit()` behavior within splat routes</docs-info>

## Additional Resources

**Discussion**

- [Form vs. Fetcher][form-vs-fetcher]

**Related API**

- [`<Form>`][form-component]
- [`fetcher.submit`][fetcher-submit]

[form-component]: ../components/form
[html-form-element]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement
[form-data]: https://developer.mozilla.org/en-US/docs/Web/API/FormData
[form-vs-fetcher]: ../discussion/form-vs-fetcher
[fetcher-submit]: ../hooks/use-fetcher#fetchersubmitformdata-options
[flush-sync]: https://react.dev/reference/react-dom/flushSync
[start-transition]: https://react.dev/reference/react/startTransition
[view-transitions]: https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API
[use-view-transition-state]: ../hooks//use-view-transition-state
[relativesplatpath]: ./use-resolved-path#splat-paths

---

## File: ./hooks/use-view-transition-state.md

---

title: useViewTransitionState
toc: false

---

# `useViewTransitionState`

This hook returns `true` when there is an active [View Transition][view-transitions] to the specified location. This can be used to apply finer-grained styles to elements to further customize the view transition. This requires that view transitions have been enabled for the given navigation via the `viewTransition` prop on the [`Link`][link-component-view-transition] (or the [`Form`][form-component-view-transition], [`NavLink`][nav-link-component-view-transition], `navigate`, or `submit` call).

Consider clicking on an image in a list that you need to expand into the hero image on the destination page:

```jsx
function NavImage({ src, alt, id }) {
  const to = `/images/${idx}`;
  const vt = useViewTransitionState(to);
  return (
    <Link to={to} viewTransition>
      <img
        src={src}
        alt={alt}
        style={{
          viewTransitionName: vt ? 'image-expand' : '',
        }}
      />
    </Link>
  );
}
```

[view-transitions]: https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API
[link-component-view-transition]: ../components/link#viewtransition
[form-component-view-transition]: ../components/form#viewtransition
[nav-link-component-view-transition]: ../components/nav-link#viewtransition

---

## File: ./index.md

---

title: Remix Docs Home
order: 1
description: Learn how to Build Better Websites with Remix.
toc: false
hidden: true

---

# Remix Docs

<docs-warning>Just getting started with Remix? The latest version of [Remix is now React Router v7][remix-now-react-router]. If you want to use the latest framework features, you should use the [React Router docs to get started][react-router-get-started].</docs-warning>

```shellscript nonumber
npx create-remix@latest
```

<docs-cards>
  <a href="/discussion/introduction" aria-label="Technical Explanation">
    <docs-card>
      <h4 class="text-blue-brand">I'm just curious...</h4>
      <p>Start with the <span style="text-decoration:underline">Technical Explanation</span>. Remix is a new kind of web framework that we like to call "centerstack". It blends old and new web development models in a unique way that deserves some explanation!</p>
    </docs-card>
  </a>
  <a href="/start/tutorial" aria-label="Developer Blog Tutorial">
    <docs-card>
      <h4 class="text-green-brand">I want to try it out...</h4>
      <p>Spend your first few minutes with Remix in the <span style="text-decoration:underline">Tutorial</span>. It introduces the core features as quickly as possible building a little contact management app. You'll see data loading, actions, form validation, search, redirects, and more.</p>
    </docs-card>
  </a>
  <a href="/discussion/runtimes" aria-label="Runtimes, Adapters, Stacks, and Deployment">
    <docs-card>
      <h4 class="text-pink-brand">I'm in, let's go.</h4>
      <p>The <b>Discussions</b> will help you get a deep understanding of Remix. Get yourself a drink and some snacks then dive deep into building better web apps with Remix.</p>
    </docs-card>
  </a>
  <a href="/start/community" aria-label="Remix API">
    <docs-card>
      <h4 class="text-red-brand">I'm stuck!</h4>
      <p>Need help? Want to contribute? Remix is developed in the open with a helpful community. Come and see where to find us on the <b>Community</b> page, follow along with Remix development, get help, and contribute back!</p>
    </docs-card>
  </a>
</docs-cards>

<!--

{Add this when I'm done moving things around}

## How to Use These Docs

- **Tutorials**: These are step-by-step guides that walk you through building a specific app. They're great for getting started with Remix and learning the basics.
- **Discussions**: These help you understand Remix by diving into a topic and how various APIs work together to meet use cases or explain some behavior that might not be obvious just from the API.
- **Reference**: These are the docs for the APIs and conventions that Remix provides. They're great for looking up how to use a specific API or feature but don't contain a lot of conversation about how to use them together.
- **Guides**: They're great for learning how to use Remix in a specific way or for a specific use case.

-->

[remix-now-react-router]: https://remix.run/blog/incremental-path-to-react-19
[react-router-get-started]: https://reactrouter.com/start/framework/installation

---

## File: ./other-api/adapter.md

---

title: "@remix-run/{adapter}"
order: 3

---

# Server Adapters

## Official Adapters

Idiomatic Remix apps can generally be deployed anywhere because Remix adapts the server's request/response to the [Web Fetch API][web-fetch-api]. It does this through adapters. We maintain a few adapters:

- `@remix-run/architect`
- `@remix-run/cloudflare-pages`
- `@remix-run/cloudflare-workers`
- `@remix-run/express`

These adapters are imported into your server's entry and are not used inside your Remix app itself.

If you initialized your app with `npx create-remix@latest` with something other than the built-in Remix App Server, you will note a `server/index.js` file that imports and uses one of these adapters.

<docs-info>If you're using the built-in Remix App Server, you don't interact with this API</docs-info>

Each adapter has the same API. In the future we may have helpers specific to the platform you're deploying to.

## Community Adapters

- [`@fastly/remix-server-adapter`][fastly-remix-server-adapter] - For [Fastly Compute][fastly-compute].
- [`@mcansh/remix-fastify`][remix-fastify] - For [Fastify][fastify].
- [`@mcansh/remix-raw-http`][remix-raw-http] - For a good old bare bones Node server.
- [`@netlify/remix-adapter`][netlify-remix-adapter] - For [Netlify][netlify].
- [`@netlify/remix-edge-adapter`][netlify-remix-edge-adapter] - For [Netlify][netlify] Edge.
- [`@vercel/remix`][vercel-remix] - For [Vercel][vercel].
- [`remix-google-cloud-functions`][remix-google-cloud-functions] - For [Google Cloud][google-cloud-functions] and [Firebase][firebase-functions] functions.
- [`partymix`][partymix] - For [PartyKit][partykit].
- [`@scandinavianairlines/remix-azure-functions`][remix-azure-functions]: For [Azure Functions][azure-functions] and [Azure Static Web Apps][azure-static-web-apps].

## Creating an Adapter

### `createRequestHandler`

Creates a request handler for your server to serve the app. This is the ultimate entry point of your Remix application.

```ts
const { createRequestHandler } = require('@remix-run/{adapter}');
createRequestHandler({ build, getLoadContext });
```

Here's a full example with express:

```ts lines=[1-3,11-22]
const { createRequestHandler } = require('@remix-run/express');
const express = require('express');

const app = express();

// needs to handle all verbs (GET, POST, etc.)
app.all(
  '*',
  createRequestHandler({
    // `remix build` and `remix dev` output files to a build directory, you need
    // to pass that build to the request handler
    build: require('./build'),

    // return anything you want here to be available as `context` in your
    // loaders and actions. This is where you can bridge the gap between Remix
    // and your server
    getLoadContext(req, res) {
      return {};
    },
  }),
);
```

Here's an example with Architect (AWS):

```ts
const { createRequestHandler } = require('@remix-run/architect');
exports.handler = createRequestHandler({
  build: require('./build'),
});
```

Here's an example with the simplified Cloudflare Workers API:

```ts
import { createEventHandler } from '@remix-run/cloudflare-workers';

import * as build from '../build';

addEventListener('fetch', createEventHandler({ build }));
```

Here's an example with the lower-level Cloudflare Workers API:

```ts
import { createRequestHandler, handleAsset } from '@remix-run/cloudflare-workers';

import * as build from '../build';

const handleRequest = createRequestHandler({ build });

const handleEvent = async (event: FetchEvent) => {
  let response = await handleAsset(event, build);

  if (!response) {
    response = await handleRequest(event);
  }

  return response;
};

addEventListener('fetch', (event) => {
  try {
    event.respondWith(handleEvent(event));
  } catch (e: any) {
    if (process.env.NODE_ENV === 'development') {
      event.respondWith(
        new Response(e.message || e.toString(), {
          status: 500,
        }),
      );
    }

    event.respondWith(new Response('Internal Error', { status: 500 }));
  }
});
```

[web-fetch-api]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[fastly-remix-server-adapter]: https://github.com/fastly/remix-compute-js/tree/main/packages/remix-server-adapter
[fastly-compute]: https://developer.fastly.com/learning/compute/
[remix-google-cloud-functions]: https://github.com/penx/remix-google-cloud-functions
[google-cloud-functions]: https://cloud.google.com/functions
[firebase-functions]: https://firebase.google.com/docs/functions
[remix-fastify]: https://github.com/mcansh/remix-fastify
[fastify]: https://www.fastify.io
[remix-raw-http]: https://github.com/mcansh/remix-node-http-server
[netlify-remix-adapter]: https://github.com/netlify/remix-compute/tree/main/packages/remix-adapter
[netlify-remix-edge-adapter]: https://github.com/netlify/remix-compute/tree/main/packages/remix-edge-adapter
[netlify]: https://netlify.com
[vercel-remix]: https://github.com/vercel/remix/blob/main/packages/vercel-remix
[vercel]: https://vercel.com
[partykit]: https://partykit.io
[partymix]: https://github.com/partykit/partykit/tree/main/packages/partymix
[remix-azure-functions]: https://github.com/scandinavianairlines/remix-azure-functions
[azure-functions]: https://azure.microsoft.com/en-us/products/functions/
[azure-static-web-apps]: https://azure.microsoft.com/en-us/products/app-service/static

---

## File: ./other-api/create-remix.md

---

## title: "create-remix (CLI)"

# `create-remix`

<docs-warning>Just getting started with Remix? The latest version of [Remix is now React Router v7][remix-now-react-router]. If you want to use the latest framework features, you should use the [`create-react-router` CLI to start a new project][create-react-router].</docs-warning>

The `create-remix` CLI will create a new Remix project. Without passing arguments, this command will launch an interactive CLI to configure the new project and set it up in a given directory.

```sh
npx create-remix@latest
```

Optionally you can pass the desired directory path as an argument:

```sh
npx create-remix@latest <projectDir>
```

The default application is a TypeScript app using the built in [Remix App Server][remix-app-server]. If you wish to create your application based on a different setup, you can use the [`--template`][template-flag-hash-link] flag:

```sh
npx create-remix@latest --template <templateUrl>
```

To get a full list of available commands and flags, run:

```sh
npx create-remix@latest --help
```

### Package managers

`create-remix` can also be invoked using various package managers, allowing you to choose between npm, Yarn, pnpm, and Bun for managing the install process.

```sh
npm create remix@latest <projectDir>
# or
yarn create remix@latest <projectDir>
# or
pnpm create remix@latest <projectDir>
# or
bunx create-remix@latest <projectDir>
```

### `create-remix --template`

For a more comprehensive guide to available templates, see our [templates page.][templates]

A valid template can be:

- a GitHub repo shorthand ‚Äî `:username/:repo` or `:username/:repo/:directory`
- the URL of a GitHub repo (or directory within it) ‚Äî `https://github.com/:username/:repo` or `https://github.com/:username/:repo/tree/:branch/:directory`
  - The branch name (`:branch`) cannot have a `/` when using this format since `create-remix` cannot unable to differentiate the branch name from the directory path
- the URL of a remote tarball ‚Äî `https://example.com/remix-template.tar.gz`
- a local file path to a directory of files ‚Äî `./path/to/remix-template`
- a local file path to a tarball ‚Äî `./path/to/remix-template.tar.gz`

```sh
npx create-remix@latest ./my-app --template remix-run/grunge-stack
npx create-remix@latest ./my-app --template remix-run/remix/templates/remix
npx create-remix@latest ./my-app --template remix-run/examples/basic
npx create-remix@latest ./my-app --template :username/:repo
npx create-remix@latest ./my-app --template :username/:repo/:directory
npx create-remix@latest ./my-app --template https://github.com/:username/:repo
npx create-remix@latest ./my-app --template https://github.com/:username/:repo/tree/:branch
npx create-remix@latest ./my-app --template https://github.com/:username/:repo/tree/:branch/:directory
npx create-remix@latest ./my-app --template https://github.com/:username/:repo/archive/refs/tags/:tag.tar.gz
npx create-remix@latest ./my-app --template https://github.com/:username/:repo/releases/latest/download/:tag.tar.gz
npx create-remix@latest ./my-app --template https://example.com/remix-template.tar.gz
npx create-remix@latest ./my-app --template ./path/to/remix-template
npx create-remix@latest ./my-app --template ./path/to/remix-template.tar.gz
```

<aside aria-label="Private GitHub repo templates">
<docs-info>

To create a new project from a template in a private GitHub repo, pass the `--token` flag a personal access token with access to that repo.

</docs-info>
</aside>

### `create-remix --overwrite`

If `create-remix` detects any file collisions between the template and the directory you are creating your app in, it will prompt you for confirmation that it's OK to overwrite those files with the template versions. You may skip this prompt with the `--overwrite` CLI flag.

[templates]: ../guides/templates
[remix-app-server]: ./serve
[template-flag-hash-link]: #create-remix---template
[remix-now-react-router]: https://remix.run/blog/incremental-path-to-react-19
[create-react-router]: https://reactrouter.com/start/framework/installation

---

## File: ./other-api/dev.md

---

title: "@remix-run/dev CLI"
order: 2
new: true

---

# Remix CLI

The Remix CLI comes from the `@remix-run/dev` package. It also includes the compiler. Make sure it is in your `package.json` `devDependencies` so it doesn't get deployed to your server.

To get a full list of available commands and flags, run:

```shellscript nonumber
npx @remix-run/dev -h
```

## `remix vite:build`

Builds your app for production with [Remix Vite][remix-vite]. This command will set `process.env.NODE_ENV` to `production` and minify the output for deployment.

```shellscript nonumber
remix vite:build
```

| Flag                  | Description                                             | Type                                                | Default     |
| --------------------- | ------------------------------------------------------- | --------------------------------------------------- | ----------- |
| `--assetsInlineLimit` | Static asset base64 inline threshold in bytes           | `number`                                            | `4096`      |
| `--clearScreen`       | Allow/disable clear screen when logging                 | `boolean`                                           |             |
| `--config`, `-c`      | Use specified config file                               | `string`                                            |             |
| `--emptyOutDir`       | Force empty outDir when it's outside of root            | `boolean`                                           |             |
| `--logLevel`, `-l`    | Use specified log level                                 | `"info" \| "warn" \| "error" \| "silent" \| string` |             |
| `--minify`            | Enable/disable minification, or specify minifier to use | `boolean \| "terser" \| "esbuild"`                  | `"esbuild"` |
| `--mode`, `-m`        | Set env mode                                            | `string`                                            |             |
| `--profile`           | Start built-in Node.js inspector                        |                                                     |             |
| `--sourcemapClient`   | Output source maps for client build                     | `boolean \| "inline" \| "hidden"`                   | `false`     |
| `--sourcemapServer`   | Output source maps for server build                     | `boolean \| "inline" \| "hidden"`                   | `false`     |

## `remix vite:dev`

Runs your app in development mode with [Remix Vite][remix-vite].

```shellscript nonumber
remix vite:dev
```

| Flag               | Description                                           | Type                                                | Default |
| ------------------ | ----------------------------------------------------- | --------------------------------------------------- | ------- |
| `--clearScreen`    | Allow/disable clear screen when logging               | `boolean`                                           |         |
| `--config`, `-c`   | Use specified config file                             | `string`                                            |         |
| `--cors`           | Enable CORS                                           | `boolean`                                           |         |
| `--force`          | Force the optimizer to ignore the cache and re-bundle | `boolean`                                           |         |
| `--host`           | Specify hostname                                      | `string`                                            |         |
| `--logLevel`, `-l` | Use specified log level                               | `"info" \| "warn" \| "error" \| "silent" \| string` |         |
| `--mode`, `-m`     | Set env mode                                          | `string`                                            |         |
| `--open`           | Open browser on startup                               | `boolean \| string`                                 |         |
| `--port`           | Specify port                                          | `number`                                            |         |
| `--profile`        | Start built-in Node.js inspector                      |                                                     |         |
| `--strictPort`     | Exit if specified port is already in use              | `boolean`                                           |         |

## Classic Remix Compiler Commands

<docs-warning>This documentation is only relevant when using the [Classic Remix Compiler][classic-remix-compiler].</docs-warning>

### `remix build`

Builds your app for production with the [Classic Remix Compiler][classic-remix-compiler]. This command will set `process.env.NODE_ENV` to `production` and minify the output for deployment.

```shellscript nonumber
remix build
```

#### Options

| Option                                   | flag          | config | default |
| ---------------------------------------- | ------------- | ------ | ------- |
| Generate sourcemaps for production build | `--sourcemap` | N/A    | `false` |

## `remix dev`

Runs the [Classic Remix Compiler][classic-remix-compiler] in watch mode and spins up your app server.

The Remix compiler will:

1. Set `NODE_ENV` to `development`
2. Watch your app code for changes and trigger rebuilds
3. Restart your app server whenever rebuilds succeed
4. Send code updates to the browser via Live Reload and HMR + Hot Data Revalidation

üé• For an introduction and deep dive into HMR and HDR in Remix, check out our videos:

- [HMR and Hot Data Revalidation üî•][hmr_and_hdr]
- [Mental model for the new dev flow üß†][mental_model]
- [Migrating your project to v2 dev flow üöö][migrating]

<docs-info>

What is "Hot Data Revalidation"?

Like HMR, HDR is a way of hot updating your app without needing to refresh the page.
That way you can keep your app state as your edits are applied in your app.
HMR handles client-side code updates like when you change the components, markup, or styles in your app.
Likewise, HDR handles server-side code updates.

That means any time your change a [`loader`][loader] on your current page (or any code that your `loader` depends on), Remix will re-fetch data from your changed loader.
That way your app is _always_ up-to-date with the latest code changes, client-side or server-side.

To learn more about how HMR and HDR work together, check out [Pedro's talk at Remix Conf 2023][legendary_dx].

</docs-info>

#### With custom app server

If you used a template to get started, hopefully it's already integrated with `remix dev` out-of-the-box.
If not, you can follow these steps to integrate your project with `remix dev`:

1. Replace your dev scripts in `package.json` and use `-c` to specify your app server command:

   ```json filename=package.json
   {
     "scripts": {
       "dev": "remix dev -c \"node ./server.js\""
     }
   }
   ```

2. Ensure `broadcastDevReady` is called when your app server is up and running:

   ```ts filename=server.ts lines=[12,25-27]
   import path from 'node:path';

   import { broadcastDevReady } from '@remix-run/node';
   import express from 'express';

   const BUILD_DIR = path.resolve(__dirname, 'build');
   const build = require(BUILD_DIR);

   const app = express();

   // ... code for setting up your express app goes here ...

   app.all('*', createRequestHandler({ build }));

   const port = 3000;
   app.listen(port, () => {
     console.log(`üëâ http://localhost:${port}`);

     if (process.env.NODE_ENV === 'development') {
       broadcastDevReady(build);
     }
   });
   ```

   <docs-info>

   For CloudFlare, use `logDevReady` instead of `broadcastDevReady`.

   Why? `broadcastDevReady` uses [`fetch`][fetch] to send a ready message to the Remix compiler,
   but CloudFlare does not support async I/O like `fetch` outside of request handling.

   </docs-info>

#### Options

Options priority order is: 1. flags, 2. config, 3. defaults.

| Option          | flag               | config    | default                           | description                                              |
| --------------- | ------------------ | --------- | --------------------------------- | -------------------------------------------------------- |
| Command         | `-c` / `--command` | `command` | `remix-serve <server build path>` | Command used to run your app server                      |
| Manual          | `--manual`         | `manual`  | `false`                           | See [guide for manual mode][manual_mode]                 |
| Port            | `--port`           | `port`    | Dynamically chosen open port      | Internal port used by the Remix compiler for hot updates |
| TLS key         | `--tls-key`        | `tlsKey`  | N/A                               | TLS key for configuring local HTTPS                      |
| TLS certificate | `--tls-cert`       | `tlsCert` | N/A                               | TLS certificate for configuring local HTTPS              |

For example:

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  dev: {
    // ...any other options you want to set go here...
    manual: true,
    tlsKey: './key.pem',
    tlsCert: './cert.pem',
  },
};
```

#### Setting a custom port

The `remix dev --port` option sets the internal port used for hot updates.
**It does not affect the port your app runs on.**

To set your app server port, set it the way you normally would in production.
For example, you may have it hardcoded in your `server.js` file.

If you are using `remix-serve` as your app server, you can use its `--port` flag to set the app server port:

```shellscript nonumber
remix dev -c "remix-serve --port 8000 ./build/index.js"
```

In contrast, the `remix dev --port` option is an escape-hatch for users who need fine-grain control of network ports.
Most users, should not need to use `remix dev --port`.

#### Manual mode

By default, `remix dev` will restart your app server whenever a rebuild occurs.
If you'd like to keep your app server running without restarts across rebuilds, check out our [guide for manual mode][manual_mode].

You can see if app server restarts are a bottleneck for your project by comparing the times reported by `remix dev`:

- `rebuilt (Xms)` üëâ the Remix compiler took `X` milliseconds to rebuild your app
- `app server ready (Yms)` üëâ Remix restarted your app server, and it took `Y` milliseconds to start with the new code changes

#### Pick up changes from other packages

If you are using a monorepo, you might want Remix to perform hot updates not only when your app code changes, but whenever you change code in any of your apps dependencies.

For example, you could have a UI library package (`packages/ui`) that is used within your Remix app (`packages/app`).
To pick up changes in `packages/ui`, you can configure [watchPaths][watch_paths] to include your packages.

#### How to set up MSW

To use [Mock Service Worker][msw] in development, you'll need to:

1. Run MSW as part of your app server
2. Configure MSW to not mock internal "dev ready" messages to the Remix compiler

Make sure that you are setting up your mocks for your _app server_ within the `-c` flag so that the `REMIX_DEV_ORIGIN` environment variable is available to your mocks.
For example, you can use `NODE_OPTIONS` to set Node's `--require` flag when running `remix-serve`:

```json filename=package.json
{
  "scripts": {
    "dev": "remix dev -c \"npm run dev:app\"",
    "dev:app": "cross-env NODE_OPTIONS=\"--require ./mocks\" remix-serve ./build"
  }
}
```

If you're using ESM as the default module system you will need to set the `--import` flag instead of `--require`:

```json filename=package.json
{
  "scripts": {
    "dev": "remix dev -c \"npm run dev:app\"",
    "dev:app": "cross-env NODE_OPTIONS=\"--import ./mocks/index.js\" remix-serve ./build/index.js"
  }
}
```

Next, you can use `REMIX_DEV_ORIGIN` to let MSW forward internal "dev ready" messages on `/ping`:

```ts
import { http, passthrough } from 'msw';

const REMIX_DEV_PING = new URL(process.env.REMIX_DEV_ORIGIN);
REMIX_DEV_PING.pathname = '/ping';

export const server = setupServer(
  http.post(REMIX_DEV_PING.href, () => passthrough()),
  // ... other request handlers go here ...
);
```

#### How to integrate with a reverse proxy

Let's say you have the app server and Remix compiler both running on the same machine:

- App server üëâ `http://localhost:1234`
- Remix compiler üëâ `http://localhost:5678`

Then, you set up a reverse proxy in front of the app server:

- Reverse proxy üëâ `https://myhost`

But the internal HTTP and WebSocket connections to support hot updates will still try to reach the Remix compiler's unproxied origin:

- Hot updates üëâ `http://localhost:5678` / `ws://localhost:5678` ‚ùå

To get the internal connections to point to the reverse proxy, you can use the `REMIX_DEV_ORIGIN` environment variable:

```shellscript nonumber
REMIX_DEV_ORIGIN=https://myhost remix dev
```

Now, hot updates will be sent correctly to the proxy:

- Hot updates üëâ `https://myhost` / `wss://myhost` ‚úÖ

#### Performance tuning and debugging

##### Path imports

Currently, when Remix rebuilds your app, the compiler has to process your app code along with any of its dependencies.
The compiler tree-shakes unused code from app so that you don't ship any unused code to browser and so that you keep your server as slim as possible.
But the compiler still needs to _crawl_ all the code to know what to keep and what to tree shake away.

In short, this means that the way you do imports and exports can have a big impact on how long it takes to rebuild your app.
For example, if you are using a library like Material UI or AntD you can likely speed up your builds by using [path imports][path_imports]:

```diff
- import { Button, TextField } from '@mui/material';
+ import Button from '@mui/material/Button';
+ import TextField from '@mui/material/TextField';
```

In the future, Remix could pre-bundle dependencies in development to avoid this problem entirely.
But today, you can help the compiler out by using path imports.

##### Debugging bundles

Depending on your app and dependencies, you might be processing much more code than your app needs.
Check out our [bundle analysis guide][bundle_analysis] for more details.

#### Troubleshooting

##### HMR

If you are expecting hot updates but getting full page reloads,
check out our [discussion on Hot Module Replacement][hmr] to learn more about the limitations of React Fast Refresh and workarounds for common issues.

##### HDR: every code change triggers HDR

Hot Data Revalidation detects loader changes by trying to bundle each loader and then fingerprinting the content for each.
It relies on tree shaking to determine whether your changes affect each loader or not.

To ensure that tree shaking can reliably detect changes to loaders, make sure you declare that your app's package is side effect free:

```json filename=package.json
{
  "sideEffects": false
}
```

##### HDR: harmless console errors when loader data is removed

When you delete a loader or remove some of the data being returned by that loader, your app should be hot updated correctly.
But you may notice console errors logged in your browser.

React strict-mode and React Suspense can cause multiple renders when hot updates are applied.
Most of these render correctly, including the final render that is visible to you.
But intermediate renders can sometimes use new loader data with old React components, which is where those errors come from.

We are continuing to investigate the underlying race condition to see if we can smooth that over.
In the meantime, if those console errors bother you, you can refresh the page whenever they occur.

##### HDR: performance

When the Remix compiler builds (and rebuilds) your app, you may notice a slight slowdown as the compiler needs to crawl the dependencies for each loader.
That way Remix can detect loader changes on rebuilds.

While the initial build slowdown is inherently a cost for HDR, we plan to optimize rebuilds so that there is no perceivable slowdown for HDR rebuilds.

[hmr_and_hdr]: https://www.youtube.com/watch?v=2c2OeqOX72s
[mental_model]: https://www.youtube.com/watch?v=zTrjaUt9hLo
[migrating]: https://www.youtube.com/watch?v=6jTL8GGbIuc
[legendary_dx]: https://www.youtube.com/watch?v=79M4vYZi-po
[loader]: ../route/loader
[fetch]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[watch_paths]: ../file-conventions/remix-config#watchpaths
[react_keys]: https://react.dev/learn/rendering-lists#why-does-react-need-keys
[use_loader_data]: ../hooks/use-loader-data
[react_refresh]: https://github.com/facebook/react/tree/main/packages/react-refresh
[msw]: https://mswjs.io
[path_imports]: https://mui.com/material-ui/guides/minimizing-bundle-size/#option-one-use-path-imports
[bundle_analysis]: ../guides/performance
[manual_mode]: ../guides/manual-mode
[hmr]: ../discussion/hot-module-replacement
[remix-vite]: ../guides/vite
[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite

---

## File: ./other-api/index.md

---

title: Other API
order: 9

---

---

## File: ./other-api/node.md

---

## title: "@remix-run/node"

# `@remix-run/node`

This package contains utilities and polyfills for Node.js.

## Polyfills

Since Remix relies on browser APIs such as `fetch` that aren't natively & stably available yet in Node.js you may find that your unit tests fail without these globals when running with tools such as Jest.

Your testing framework should provide you with a hook or location to polyfill globals / mock out APIs; here you can add the following lines to install the globals that Remix relies on:

```ts
import { installGlobals } from '@remix-run/node';

// This installs globals such as "fetch", "Response", "Request" and "Headers".
installGlobals();
```

<docs-info>
  Keep in mind that we install these for you automatically in your actual app, so you should only need to do this in your test environment.
</docs-info>

## Version Support

Remix officially supports **Active** and **Maintenance** [Node LTS versions][node-releases] at any given point in time. Dropped support for End of Life Node versions is done in a Remix Minor release.

[node-releases]: https://nodejs.org/en/about/previous-releases

---

## File: ./other-api/serve.md

---

title: "@remix-run/serve"
order: 3

---

# Remix App Server

Remix is designed for you to own your server, but if you don't want to set one up you can use the Remix App Server instead. It's a production-ready, but basic Node.js server built with Express.

By design, we do not provide options to customize the Remix App Server because if you need to customize the underlying `express` server, we'd rather you manage the server completely instead of creating an abstraction to handle all of the possible customizations you may require. If you find you want to customize it, you should use the `@remix-run/express` adapter instead.

You can see the underlying `express` server configuration in [packages/remix-serve/cli.ts][remix-serve-code]. By default it uses the following Express middlewares (please refer to their documentation for default behaviors):

- [`compression`][compression]
- [`express.static`][express-static] (and thus [`serve-static`][serve-static])
- [`morgan`][morgan]

## `HOST` environment variable

You can configure the hostname for your Express app via `process.env.HOST` and that value will be passed to the internal [`app.listen`][express-listen] method when starting the server.

```shellscript nonumber
HOST=127.0.0.1 npx remix-serve build/index.js
```

```shellscript nonumber
remix-serve <server-build-path>
# e.g.
remix-serve build/index.js
```

## `PORT` environment variable

You can change the port of the server with an environment variable.

```shellscript nonumber
PORT=4000 npx remix-serve build/index.js
```

## Development Environment

Depending on `process.env.NODE_ENV`, the server will boot in development or production mode.

The `server-build-path` needs to point to the `serverBuildPath` defined in `remix.config.js`.

Because only the build artifacts (`build/`, `public/build/`) need to be deployed to production, the `remix.config.js` is not guaranteed to be available in production, so you need to tell Remix where your server build is with this option.

In development, `remix-serve` will ensure the latest code is run by purging the `require` cache for every request. This has some effects on your code you might need to be aware of:

- Any values in the module scope will be "reset"

  ```tsx lines=[1-3]
  // this will be reset for every request because the module cache was
  // cleared and this will be required brand new
  const cache = new Map();

  export async function loader({ params }: LoaderFunctionArgs) {
    if (cache.has(params.foo)) {
      return json(cache.get(params.foo));
    }

    const record = await fakeDb.stuff.find(params.foo);
    cache.set(params.foo, record);
    return json(record);
  }
  ```

  If you need a workaround for preserving cache in development, you can set up a [singleton][singleton] in your server.

- Any **module side effects** will remain in place! This may cause problems, but should probably be avoided anyway.

  ```tsx lines=[3-6]
  import { json } from '@remix-run/node'; // or cloudflare/deno

  // this starts running the moment the module is imported
  setInterval(() => {
    console.log(Date.now());
  }, 1000);

  export async function loader() {
    // ...
  }
  ```

  If you need to write your code in a way that has these types of module side effects, you should set up your own [@remix-run/express][remix-run-express] server and a tool in development like pm2-dev or nodemon to restart the server on file changes instead.

In production this doesn't happen. The server boots up and that's the end of it.

[remix-run-express]: ./adapter#createrequesthandler
[singleton]: ../guides/manual-mode#keeping-in-memory-server-state-across-rebuilds
[express-listen]: https://expressjs.com/en/api.html#app.listen
[remix-serve-code]: https://github.com/remix-run/remix/blob/main/packages/remix-serve/cli.ts
[compression]: https://expressjs.com/en/resources/middleware/compression.html
[express-static]: https://expressjs.com/en/4x/api.html#express.static
[serve-static]: https://expressjs.com/en/resources/middleware/serve-static.html
[morgan]: https://expressjs.com/en/resources/middleware/morgan.html

---

## File: ./other-api/testing.md

---

## title: "@remix-run/testing"

# `@remix-run/testing`

This package contains utilities to assist in unit testing portions of your Remix application. This is accomplished by mocking the Remix route modules/assets manifest output by the compiler and generating an in-memory React Router app via [createMemoryRouter][create-memory-router].

The general usage of this is to test components/hooks that rely on Remix hooks/components which you do not have the ability to cleanly mock ([`useLoaderData`][use-loader-data], [`useFetcher`][use-fetcher], etc.). While it can also be used for more advanced testing such as clicking links and navigating to pages, those are better suited for End-to-End tests via something like [Cypress][cypress] or [Playwright][playwright].

## Usage

To use [`createRemixStub`][create-remix-stub], define your routes using React Router-like route objects, where you specify the `path`, `Component`, `loader`, etc. These are essentially mocking the nesting and exports of the route files in your Remix app:

```tsx
import { createRemixStub } from '@remix-run/testing';

const RemixStub = createRemixStub([
  {
    path: '/',
    Component: MyComponent,
    loader() {
      return json({ message: 'hello' });
    },
  },
]);
```

Then you can render the `<RemixStub />` component and assert against it:

```tsx
render(<RemixStub />);
await screen.findByText('Some rendered text');
```

## Example

Here's a full working example testing using [`jest`][jest] and [React Testing Library][rtl]:

```tsx
import { json } from '@remix-run/node';
import { useLoaderData } from '@remix-run/react';
import { createRemixStub } from '@remix-run/testing';
import { render, screen, waitFor } from '@testing-library/react';

test('renders loader data', async () => {
  // ‚ö†Ô∏è This would usually be a component you import from your app code
  function MyComponent() {
    const data = useLoaderData() as { message: string };
    return <p>Message: {data.message}</p>;
  }

  const RemixStub = createRemixStub([
    {
      path: '/',
      Component: MyComponent,
      loader() {
        return json({ message: 'hello' });
      },
    },
  ]);

  render(<RemixStub />);

  await waitFor(() => screen.findByText('Message: hello'));
});
```

[create-memory-router]: https://reactrouter.com/v6/routers/create-memory-router
[use-loader-data]: ../hooks/use-loader-data
[use-fetcher]: ../hooks/use-fetcher
[cypress]: https://www.cypress.io
[playwright]: https://playwright.dev
[create-remix-stub]: ../utils/create-remix-stub
[jest]: https://jestjs.io
[rtl]: https://testing-library.com/docs/react-testing-library/intro

---

## File: ./route/action.md

---

## title: action

# `action`

<docs-success>Watch the <a href="https://www.youtube.com/playlist?list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6">üìº Remix Singles</a>: <a href="https://www.youtube.com/watch?v=Iv25HAHaFDs&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6">Data Mutations with Form + action</a> and <a href="https://www.youtube.com/watch?v=w2i-9cYxSdc&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6">Multiple Forms and Single Button Mutations</a></docs-success>

A route `action` is a server only function to handle data mutations and other actions. If a non-`GET` request is made to your route (`DELETE`, `PATCH`, `POST`, or `PUT`) then the action is called before the [`loader`][loader]s.

`action`s have the same API as `loader`s, the only difference is when they are called. This enables you to co-locate everything about a data set in a single route module: the data read, the component that renders the data, and the data writes:

```tsx
import type { ActionFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json, redirect } from '@remix-run/node'; // or cloudflare/deno
import { Form } from '@remix-run/react';

import { TodoList } from '@/components/TodoList';
import { fakeCreateTodo, fakeGetTodos } from '@/utils/db';

export async function action({ request }: ActionFunctionArgs) {
  const body = await request.formData();
  const todo = await fakeCreateTodo({
    title: body.get('title'),
  });
  return redirect(`/todos/${todo.id}`);
}

export async function loader() {
  return json(await fakeGetTodos());
}

export default function Todos() {
  const data = useLoaderData<typeof loader>();
  return (
    <div>
      <TodoList todos={data} />
      <Form method="post">
        <input type="text" name="title" />
        <button type="submit">Create Todo</button>
      </Form>
    </div>
  );
}
```

When a `POST` is made to a URL, multiple routes in your route hierarchy will match the URL. Unlike a `GET` to loaders, where all of them are called to build the UI, _only one action is called_.

<docs-info>The route called will be the deepest matching route, unless the deepest matching route is an "index route". In this case, it will post to the parent route of the index (because they share the same URL, the parent wins).</docs-info>

If you want to post to an index route use `?index` in the action: `<Form action="/accounts?index" method="post" />`

| action url        | route action                     |
| ----------------- | -------------------------------- |
| `/accounts?index` | `app/routes/accounts._index.tsx` |
| `/accounts`       | `app/routes/accounts.tsx`        |

Also note that forms without an action prop (`<Form method="post">`) will automatically post to the same route within which they are rendered, so using the `?index` param to disambiguate between parent and index routes is only useful if you're posting to an index route from somewhere besides the index route itself. If you're posting from the index route to itself, or from the parent route to itself, you don't need to define a `<Form action>` at all, just omit it: `<Form method="post">`.

See also:

- [`<Form>`][form-component]
- [`<Form action>`][form-component-action]
- [`?index` query param][index-query-param]

[loader]: ./loader
[form-component]: ../components/form
[form-component-action]: ../components/form#action
[index-query-param]: ../guides/index-query-param

---

## File: ./route/client-action.md

---

## title: clientAction

# `clientAction`

In addition to (or in place of) your [`action`][action], you may define a `clientAction` function that will execute on the client.

Each route can define a `clientAction` function that handles mutations:

```tsx
export const clientAction = async ({ request, params, serverAction }: ClientActionFunctionArgs) => {
  invalidateClientSideCache();
  const data = await serverAction();
  return data;
};
```

This function is only ever run on the client, and can be used in a few ways:

- Instead of a server `action` for full-client routes
- To use alongside a `clientLoader` cache by invalidating the cache on mutations
- To facilitate a migration from React Router

## Arguments

### `params`

This function receives the same [`params`][action-params] argument as an [`action`][action].

### `request`

This function receives the same [`request`][action-request] argument as an [`action`][action].

### `serverAction`

`serverAction` is an asynchronous function that makes the [fetch][fetch] call to the server `action` for this route.

See also:

- [Client Data Guide][client-data-guide]
- [clientLoader][clientloader]

[action]: ./action
[action-params]: ./loader#params
[action-request]: ./loader#request
[fetch]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[client-data-guide]: ../guides/client-data
[clientloader]: ./client-loader

---

## File: ./route/client-loader.md

---

## title: clientLoader

# `clientLoader`

In addition to (or in place of) your [`loader`][loader], you may define a `clientLoader` function that will execute on the client.

Each route can define a `clientLoader` function that provides data to the route when rendering:

```tsx
export const clientLoader = async ({ request, params, serverLoader }: ClientLoaderFunctionArgs) => {
  // call the server loader
  const serverData = await serverLoader();
  // And/or fetch data on the client
  const data = getDataFromClient();
  // Return the data to expose through useLoaderData()
  return data;
};
```

This function is only ever run on the client, and can be used in a few ways:

- Instead of a server `loader` for full-client routes
- To use alongside a `clientLoader` cache by invalidating the cache on mutations
  - Maintaining a client-side cache to skip calls to the server
  - Bypassing the Remix [BFF][bff] hop and hitting your API directly from the client
- To further augment data loaded from the server
  - I.e., loading user-specific preferences from `localStorage`
- To facilitate a migration from React Router

## Hydration Behavior

By default, `clientLoader` **will not** execute for the route during hydration of your Remix app on the initial SSR document request. This is for the primary (and simpler) use-case where the `clientLoader` does not change the shape of the server `loader` data and is just an optimization on subsequent client side navigations (to read from a cache or hit an API directly).

```tsx
export async function loader() {
  // During SSR, we talk to the DB directly
  const data = getServerDataFromDb();
  return json(data);
}

export async function clientLoader() {
  // During client-side navigations, we hit our exposed API endpoints directly
  const data = await fetchDataFromApi();
  return data;
}

export default function Component() {
  const data = useLoaderData<typeof loader>();
  return <>...</>;
}
```

### `clientLoader.hydrate`

If you need to run your `clientLoader` during hydration on the initial document request, you can opt-in by setting `clientLoader.hydrate=true`. This will tell Remix that it needs to run the `clientLoader` on hydration. Without a `HydrateFallback`, your route component will be SSR'd with the server `loader` data - and then `clientLoader` will run and the returned data will be updated in-place in the hydrated route Component.

<docs-info>If a route exports a `clientLoader` and does not export a server `loader`, then `clientLoader.hydrate` is automatically treated as `true` since there is no server data to SSR with. Therefore, we always need to run the `clientLoader` on hydration before rendering the route component.</docs-info>

### HydrateFallback

If you need to avoid rendering your default route component during SSR because you have data that must come from a `clientLoader`, you can export a [`HydrateFallback`][hydratefallback] component from your route that will be rendered during SSR, and only once the `clientLoader` runs on hydration will your router component be rendered.

## Arguments

### `params`

This function receives the same [`params`][loader-params] argument as a [`loader`][loader].

### `request`

This function receives the same [`request`][loader-request] argument as a [`loader`][loader].

### `serverLoader`

`serverLoader` is an asynchronous function to get the data from the server `loader` for this route. On client-side navigations, this will make a [fetch][fetch] call to the Remix server `loader`. If you opt-into running your `clientLoader` on hydration, then this function will return you the data that was already loaded on the server (via `Promise.resolve`).

See also:

- [Client Data Guide][client-data-guide]
- [HydrateFallback][hydratefallback]
- [clientAction][clientaction]

[loader]: ./loader
[loader-params]: ./loader#params
[loader-request]: ./loader#request
[clientaction]: ./client-action
[hydratefallback]: ./hydrate-fallback
[bff]: ../guides/bff
[fetch]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[client-data-guide]: ../guides/client-data

---

## File: ./route/component.md

---

## title: Component

# Route Component

The default export of a route module defines the component that will render when the route matches.

```tsx filename=app/routes/my-route.tsx
export default function MyRouteComponent() {
  return (
    <div>
      <h1>Look ma!</h1>
      <p>I'm still using React after like 8 years.</p>
    </div>
  );
}
```

---

## File: ./route/error-boundary.md

---

## title: ErrorBoundary

# `ErrorBoundary`

A Remix `ErrorBoundary` component works just like normal React [error boundaries][error-boundaries], but with a few extra capabilities. When there is an error in your route component, the `ErrorBoundary` will be rendered in its place, nested inside any parent routes. `ErrorBoundary` components also render when there is an error in the `loader` or `action` functions for a route, so all errors for that route may be handled in one spot.

The most common use-cases tend to be:

- You may intentionally throw a 4xx `Response` to trigger an error UI
  - Throwing a 400 on bad user input
  - Throwing a 401 for unauthorized access
  - Throwing a 404 when you can't find requested data
- React may unintentionally throw an `Error` if it encounters a runtime error during rendering

To obtain the thrown object, you can use the [`useRouteError`][use-route-error] hook. When a `Response` is thrown, it will be automatically unwrapped into an `ErrorResponse` instance with `state`/`statusText`/`data` fields so that you don't need to bother with `await response.json()` in your component. To differentiate thrown `Response`'s from thrown `Error`'s you can use the [`isRouteErrorResponse`][is-route-error-response] utility.

```tsx
import { isRouteErrorResponse, useRouteError } from '@remix-run/react';

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    return (
      <div>
        <h1>
          {error.status} {error.statusText}
        </h1>
        <p>{error.data}</p>
      </div>
    );
  } else if (error instanceof Error) {
    return (
      <div>
        <h1>Error</h1>
        <p>{error.message}</p>
        <p>The stack trace is:</p>
        <pre>{error.stack}</pre>
      </div>
    );
  } else {
    return <h1>Unknown Error</h1>;
  }
}
```

[error-boundaries]: https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary
[use-route-error]: ../hooks/use-route-error
[is-route-error-response]: ../utils/is-route-error-response

---

## File: ./route/handle.md

---

## title: handle

# `handle`

Exporting a handle allows you to create application conventions with the [`useMatches`][use-matches] hook. You can put whatever values you want on it:

```tsx
export const handle = {
  its: 'all yours',
};
```

This is almost always used in conjunction with `useMatches`. To see what kinds of things you can do with it, refer to [`useMatches`][use-matches] for more information.

## Additional Resources

- [Breadcrumbs Guide][breadcrumbs-guide]
- [`useMatches`][use-matches]

[use-matches]: ../hooks/use-matches
[breadcrumbs-guide]: ../guides/breadcrumbs

---

## File: ./route/headers.md

---

## title: headers

# `headers`

Each route can define its own HTTP headers. One of the common headers is the [`Cache-Control` header][cache-control-header] that indicates to browser and CDN caches where and for how long a page is able to be cached.

```tsx
import type { HeadersFunction } from '@remix-run/node'; // or cloudflare/deno

export const headers: HeadersFunction = ({
  actionHeaders,
  errorHeaders,
  loaderHeaders,
  parentHeaders,
}) => ({
  'X-Stretchy-Pants': 'its for fun',
  'Cache-Control': 'max-age=300, s-maxage=3600',
});
```

Usually your data is a better indicator of your cache duration than your route module (data tends to be more dynamic than markup), so the [`action`][action]'s & [`loader`][loader]'s headers are passed in to `headers()` too:

```tsx
import type { HeadersFunction } from '@remix-run/node'; // or cloudflare/deno

export const headers: HeadersFunction = ({ loaderHeaders }) => ({
  'Cache-Control': loaderHeaders.get('Cache-Control'),
});
```

Note: `actionHeaders` & `loaderHeaders` are an instance of the [Web Fetch API `Headers`][headers] class.

If an `action` or a `loader` threw a [`Response`][response] and we're rendering a boundary, any headers from the thrown `Response` will be available in `errorHeaders`. This allows you to access headers from a child loader that threw in a parent error boundary.

## Nested Routes

Because Remix has nested routes, there's a battle of the headers to be won when nested routes match. The default behavior is that Remix only leverages the resulting headers from the deepest `headers` function it finds in the renderable matches (up to and including the boundary route if an error is present).

```
‚îú‚îÄ‚îÄ users.tsx
‚îú‚îÄ‚îÄ users.$userId.tsx
‚îî‚îÄ‚îÄ users.$userId.profile.tsx
```

If we are looking at `/users/123/profile` then three routes are rendering:

```tsx
<Users>
  <UserId>
    <Profile />
  </UserId>
</Users>
```

If a user is looking at `/users/123/profile` and `users.$userId.profile.tsx` does not export a `headers` function, then Remix will use the return value of `users.$userId.tsx`'s `headers` function. If that file doesn't export one, then it will use the result of the one in `users.tsx`, and so on.

If all three define `headers`, the deepest module wins, in this case `users.$userId.profile.tsx`. However, if your `users.$userId.profile.tsx`'s `loader` threw and bubbled to a boundary in `users.$userId.tsx` - then `users.$userId.tsx`'s `headers` function would be used as it is the leaf rendered route.

We don't want surprise headers in your responses, so it's your job to merge them if you'd like. Remix passes in the `parentHeaders` to your `headers` function. So `users.tsx` headers get passed to `users.$userId.tsx`, and then `users.$userId.tsx`'s `headers` are passed to `users.$userId.profile.tsx`'s `headers`.

That is all to say that Remix has given you a very large gun with which to shoot your foot. You need to be careful not to send a `Cache-Control` from a child route module that is more aggressive than a parent route. Here's some code that picks the least aggressive caching in these cases:

```tsx
import type { HeadersFunction } from '@remix-run/node'; // or cloudflare/deno
import parseCacheControl from 'parse-cache-control';

export const headers: HeadersFunction = ({ loaderHeaders, parentHeaders }) => {
  const loaderCache = parseCacheControl(loaderHeaders.get('Cache-Control'));
  const parentCache = parseCacheControl(parentHeaders.get('Cache-Control'));

  // take the most conservative between the parent and loader, otherwise
  // we'll be too aggressive for one of them.
  const maxAge = Math.min(loaderCache['max-age'], parentCache['max-age']);

  return {
    'Cache-Control': `max-age=${maxAge}`,
  };
};
```

All that said, you can avoid this entire problem by _not defining headers in parent routes_ and only in leaf routes. Every layout that can be visited directly will likely have an "index route". If you only define headers on your leaf routes, not your parent routes, you will never have to worry about merging headers.

Note that you can also add headers in your [`entry.server.tsx`][entry-server] file for things that should be global, for example:

```tsx filename=app/entry.server.tsx lines=[20]
import type { AppLoadContext, EntryContext } from '@remix-run/node'; // or cloudflare/deno
import { RemixServer } from '@remix-run/react';
import { renderToString } from 'react-dom/server';

export default function handleRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext,
  loadContext: AppLoadContext,
) {
  const markup = renderToString(<RemixServer context={remixContext} url={request.url} />);

  responseHeaders.set('Content-Type', 'text/html');
  responseHeaders.set('X-Powered-By', 'Hugs');

  return new Response('<!DOCTYPE html>' + markup, {
    headers: responseHeaders,
    status: responseStatusCode,
  });
}
```

Just keep in mind that doing this will apply to _all_ document requests, but does not apply to `data` requests (for client-side transitions for example). For those, use [`handleDataRequest`][handle-data-request].

[cache-control-header]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control
[action]: ./action
[loader]: ./loader
[headers]: https://developer.mozilla.org/en-US/docs/Web/API/Headers
[response]: https://developer.mozilla.org/en-US/docs/Web/API/Response
[entry-server]: ../file-conventions/entry.server
[handle-data-request]: ../file-conventions/entry.server#handledatarequest

---

## File: ./route/hydrate-fallback.md

---

## title: HydrateFallback

# `HydrateFallback`

A `HydrateFallback` component is your way of informing Remix that you do not want to render your route component until _after_ the `clientLoader` has run on hydration. When exported, Remix will render the fallback during SSR instead of your default route component, and will render your route component client-side once the `clientLoader` completes.

The most common use-cases for this are client-only routes (such an in-browser canvas game) and augmenting your server data with client-side data (such as saved user preferences).

```tsx filename=routes/client-only-route.tsx
export async function clientLoader() {
  const data = await loadSavedGameOrPrepareNewGame();
  return data;
}
// Note clientLoader.hydrate is implied without a server loader

export function HydrateFallback() {
  return <p>Loading Game...</p>;
}

export default function Component() {
  const data = useLoaderData<typeof clientLoader>();
  return <Game data={data} />;
}
```

```tsx filename=routes/augmenting-server-data.tsx
export async function loader() {
  const data = getServerData();
  return json(data);
}

export async function clientLoader({ request, params, serverLoader }: ClientLoaderFunctionArgs) {
  const [serverData, preferences] = await Promise.all([serverLoader(), getUserPreferences()]);
  return {
    ...serverData,
    preferences,
  };
}
clientLoader.hydrate = true;

export function HydrateFallback() {
  return <p>Loading user preferences...</p>;
}

export default function Component() {
  const data = useLoaderData<typeof clientLoader>();
  if (data.preferences.display === 'list') {
    return <ListView items={data.items} />;
  } else {
    return <GridView items={data.items} />;
  }
}
```

There are a few nuances worth noting around the behavior of `HydrateFallback`:

- It is only relevant on initial document request and hydration, and will not be rendered on any subsequent client-side navigations
- It is only relevant when you are also setting [`clientLoader.hydrate=true`][hydrate-true] on a given route
- It is also relevant if you do have a `clientLoader` without a server `loader`, as this implies `clientLoader.hydrate=true` since there is otherwise no loader data at all to return from `useLoaderData`
  - Even if you do not specify a `HydrateFallback` in this case, Remix will not render your route component and will bubble up to any ancestor `HydrateFallback` component
  - This is to ensure that `useLoaderData` remains "happy-path"
  - Without a server `loader`, `useLoaderData` would return `undefined` in any rendered route components
- You cannot render an `<Outlet/>` in a `HydrateFallback` because children routes can't be guaranteed to operate correctly since their ancestor loader data may not yet be available if they are running `clientLoader` functions on hydration (i.e., use cases such as `useRouteLoaderData()` or `useMatches()`)

See also:

- [clientLoader][clientloader]

[hydrate-true]: ./client-loader#clientloaderhydrate
[clientloader]: ./client-loader

---

## File: ./route/index.md

---

title: Route Module
order: 4

---

---

## File: ./route/links.md

---

## title: links

# `links`

The links function defines which [`<link>` element][link-element]s to add to the page when the user visits a route.

```tsx
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

export const links: LinksFunction = () => {
  return [
    {
      rel: 'icon',
      href: '/favicon.png',
      type: 'image/png',
    },
    {
      rel: 'stylesheet',
      href: 'https://example.com/some/styles.css',
    },
    { page: '/users/123' },
    {
      rel: 'preload',
      href: '/images/banner.jpg',
      as: 'image',
    },
  ];
};
```

There are two types of link descriptors you can return:

#### `HtmlLinkDescriptor`

This is an object representation of a normal `<link {...props} />` element. [View the MDN docs for the link API][link-element].

The `links` export from a route should return an array of `HtmlLinkDescriptor` objects.

Examples:

```tsx
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

import stylesHref from '../styles/something.css';

export const links: LinksFunction = () => {
  return [
    // add a favicon
    {
      rel: 'icon',
      href: '/favicon.png',
      type: 'image/png',
    },

    // add an external stylesheet
    {
      rel: 'stylesheet',
      href: 'https://example.com/some/styles.css',
      crossOrigin: 'anonymous',
    },

    // add a local stylesheet, remix will fingerprint the file name for
    // production caching
    { rel: 'stylesheet', href: stylesHref },

    // prefetch an image into the browser cache that the user is likely to see
    // as they interact with this page, perhaps they click a button to reveal in
    // a summary/details element
    {
      rel: 'prefetch',
      as: 'image',
      href: '/img/bunny.jpg',
    },

    // only prefetch it if they're on a bigger screen
    {
      rel: 'prefetch',
      as: 'image',
      href: '/img/bunny.jpg',
      media: '(min-width: 1000px)',
    },
  ];
};
```

#### `PageLinkDescriptor`

These descriptors allow you to prefetch the resources for a page the user is likely to navigate to. While this API is useful, you might get more mileage out of `<Link prefetch="render">` instead. But if you'd like, you can get the same behavior with this API.

```tsx
export const links: LinksFunction = () => {
  return [{ page: '/posts/public' }];
};
```

This loads up the JavaScript modules, loader data, and the stylesheets (defined in the `links` exports of the next routes) into the browser cache before the user even navigates there.

<docs-warning>Be careful with this feature. You don't want to download 10MB of JavaScript and data for pages the user probably won't ever visit.</docs-warning>

[link-element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link

---

## File: ./route/loader.md

---

## title: loader

# `loader`

<docs-success>Watch the <a href="https://www.youtube.com/playlist?list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6">üìº Remix Single</a>: <a href="https://www.youtube.com/watch?v=NXqEP_PsPNc&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6">Loading data into components</a></docs-success>

Each route can define a `loader` function that provides data to the route when rendering.

```tsx
import { json } from '@remix-run/node'; // or cloudflare/deno

export const loader = async () => {
  return json({ ok: true });
};
```

This function is only ever run on the server. On the initial server render, it will provide data to the HTML document. On navigations in the browser, Remix will call the function via [`fetch`][fetch] from the browser.

This means you can talk directly to your database, use server-only API secrets, etc. Any code that isn't used to render the UI will be removed from the browser bundle.

Using the database ORM [Prisma][prisma] as an example:

```tsx lines=[3,5-7]
import { useLoaderData } from '@remix-run/react';

import { prisma } from '../db';

export async function loader() {
  return json(await prisma.user.findMany());
}

export default function Users() {
  const data = useLoaderData<typeof loader>();
  return (
    <ul>
      {data.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

Because `prisma` is only used in the `loader` it will be removed from the browser bundle by the compiler, as illustrated by the highlighted lines.

<docs-error>
Note that whatever you return from your `loader` will be exposed to the client, even if the component doesn't render it. Treat your `loader`s with the same care as public API endpoints.
</docs-error>

## Type Safety

You can get type safety over the network for your `loader` and component with `useLoaderData<typeof loader>`.

```tsx lines=[9]
import { json } from '@remix-run/node';
import { useLoaderData } from '@remix-run/react';

export async function loader() {
  return json({ name: 'Ryan', date: new Date() });
}

export default function SomeRoute() {
  const data = useLoaderData<typeof loader>();
}
```

- `data.name` will know that it's a string
- `data.date` will also know that it's a string even though we passed a date object to [`json`][json]. When data is fetched for client transitions, the values are serialized over the network with [`JSON.stringify`][json-stringify], and the types are aware of that

## `params`

Route params are defined by route file names. If a segment begins with `$` like `$invoiceId`, the value from the URL for that segment will be passed to your `loader`.

```tsx filename=app/routes/invoices.$invoiceId.tsx nocopy
// if the user visits /invoices/123
export async function loader({ params }: LoaderFunctionArgs) {
  params.invoiceId; // "123"
}
```

Params are mostly useful for looking up records by ID:

```tsx filename=app/routes/invoices.$invoiceId.tsx
// if the user visits /invoices/123
export async function loader({ params }: LoaderFunctionArgs) {
  const invoice = await fakeDb.getInvoice(params.invoiceId);
  if (!invoice) throw new Response('', { status: 404 });
  return json(invoice);
}
```

## `request`

This is a [Fetch Request][request] instance. You can read the MDN docs to see all of its properties.

The most common use cases in `loader`s are reading [headers][request-headers] (like cookies) and URL [`URLSearchParams`][url-search-params] from the request:

```tsx
export async function loader({ request }: LoaderFunctionArgs) {
  // read a cookie
  const cookie = request.headers.get('Cookie');

  // parse the search params for `?q=`
  const url = new URL(request.url);
  const query = url.searchParams.get('q');
}
```

## `context`

This is the context passed in to your server adapter's `getLoadContext()` function. It's a way to bridge the gap between the adapter's request/response API with your Remix app.

<docs-info>This API is an escape hatch, it‚Äôs uncommon to need it</docs-info>

Using the express adapter as an example:

```ts filename=server.ts
const { createRequestHandler } = require('@remix-run/express');

app.all(
  '*',
  createRequestHandler({
    getLoadContext(req, res) {
      // this becomes the loader context
      return { expressUser: req.user };
    },
  }),
);
```

And then your `loader` can access it.

```tsx filename=app/routes/some-route.tsx
export async function loader({ context }: LoaderFunctionArgs) {
  const { expressUser } = context;
  // ...
}
```

## Returning Response Instances

You need to return a [Fetch Response][response] from your `loader`.

```tsx
export async function loader() {
  const users = await db.users.findMany();
  const body = JSON.stringify(users);
  return new Response(body, {
    headers: {
      'Content-Type': 'application/json',
    },
  });
}
```

Using the [`json` helper][json] simplifies this, so you don't have to construct them yourself, but these two examples are effectively the same!

```tsx
import { json } from '@remix-run/node'; // or cloudflare/deno

export const loader = async () => {
  const users = await fakeDb.users.findMany();
  return json(users);
};
```

You can see how `json` just does a little of the work to make your `loader` a lot cleaner. You can also use the `json` helper to add headers or a status code to your response:

```tsx
import { json } from '@remix-run/node'; // or cloudflare/deno

export const loader = async ({ params }: LoaderFunctionArgs) => {
  const project = await fakeDb.project.findOne({
    where: { id: params.id },
  });

  if (!project) {
    return json('Project not found', { status: 404 });
  }

  return json(project);
};
```

See also:

- [`headers`][headers]
- [MDN Response Docs][response]

## Throwing Responses in Loaders

Along with returning responses, you can also throw `Response` objects from your `loader`s. This allows you to break through the call stack and do one of two things:

- Redirect to another URL
- Show an alternate UI with contextual data through the `ErrorBoundary`

Here is a full example showing how you can create utility functions that throw responses to stop code execution in the loader and show an alternative UI.

```ts filename=app/db.ts
import { json } from '@remix-run/node'; // or cloudflare/deno

export function getInvoice(id) {
  const invoice = db.invoice.find({ where: { id } });
  if (invoice === null) {
    throw json('Not Found', { status: 404 });
  }
  return invoice;
}
```

```ts filename=app/http.ts
import { redirect } from '@remix-run/node'; // or cloudflare/deno

import { getSession } from './session';

export async function requireUserSession(request) {
  const session = await getSession(request.headers.get('cookie'));
  if (!session) {
    // You can throw our helpers like `redirect` and `json` because they
    // return `Response` objects. A `redirect` response will redirect to
    // another URL, while other  responses will trigger the UI rendered
    // in the `ErrorBoundary`.
    throw redirect('/login', 302);
  }
  return session.get('user');
}
```

```tsx filename=app/routes/invoice.$invoiceId.tsx
import type { LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json } from '@remix-run/node'; // or cloudflare/deno
import { isRouteErrorResponse, useLoaderData, useRouteError } from '@remix-run/react';

import { getInvoice } from '@/db';
import { requireUserSession } from '@/http';

export const loader = async ({ params, request }: LoaderFunctionArgs) => {
  const user = await requireUserSession(request);
  const invoice = getInvoice(params.invoiceId);

  if (!invoice.userIds.includes(user.id)) {
    throw json({ invoiceOwnerEmail: invoice.owner.email }, { status: 401 });
  }

  return json(invoice);
};

export default function InvoiceRoute() {
  const invoice = useLoaderData<typeof loader>();
  return <InvoiceView invoice={invoice} />;
}

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    switch (error.status) {
      case 401:
        return (
          <div>
            <p>You don't have access to this invoice.</p>
            <p>Contact {error.data.invoiceOwnerEmail} to get access</p>
          </div>
        );
      case 404:
        return <div>Invoice not found!</div>;
    }

    return (
      <div>
        Something went wrong: {error.status} {error.statusText}
      </div>
    );
  }

  return <div>Something went wrong: {error?.message || 'Unknown Error'}</div>;
}
```

[fetch]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[prisma]: https://www.prisma.io
[json]: ../utils/json
[json-stringify]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
[request]: https://developer.mozilla.org/en-US/docs/Web/API/Request
[request-headers]: https://developer.mozilla.org/en-US/docs/Web/API/Response/headers
[url-search-params]: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams
[response]: https://developer.mozilla.org/en-US/docs/Web/API/Response
[headers]: ../route/headers

---

## File: ./route/meta.md

---

## title: meta

# `meta`

The `meta` export allows you to add metadata HTML tags for every route in your app. These tags are important for things like search engine optimization (SEO) and browser directives for determining certain behaviors. They can also be used by social media sites to display rich previews of your app.

The `meta` function should return an array of `MetaDescriptor` objects. These objects map one-to-one with HTML tags. So this meta function:

```tsx
export const meta: MetaFunction = () => {
  return [
    { title: 'Very cool app | Remix' },
    {
      property: 'og:title',
      content: 'Very cool app',
    },
    {
      name: 'description',
      content: 'This app is the best',
    },
  ];
};
```

produces this HTML:

```html
<title>Very cool app | Remix</title> <meta property="og:title" content="Very cool app" />;
<meta name="description" content="This app is the best" />
```

By default, meta descriptors will render a [`<meta>` tag][meta-element] in most cases. The two exceptions are:

- `{ title }` renders a `<title>` tag
- `{ "script:ld+json" }` renders a `<script type="application/ld+json">` tag, and its value should be a serializable object that is stringified and injected into the tag.

```tsx
export const meta: MetaFunction = () => {
  return [
    {
      'script:ld+json': {
        '@context': 'https://schema.org',
        '@type': 'Organization',
        name: 'Remix',
        url: 'https://remix.run',
      },
    },
  ];
};
```

A meta descriptor can also render a [`<link>` tag][link-element] by setting the `tagName` property to `"link"`. This is useful for `<link>` tags associated with SEO like `canonical` URLs. For asset links like stylesheets and favicons, you should use the [`links` export][links] instead.

```tsx
export const meta: MetaFunction = () => {
  return [
    {
      tagName: 'link',
      rel: 'canonical',
      href: 'https://remix.run',
    },
  ];
};
```

## `meta` Function Parameters

### `location`

This is the current router `Location` object. This is useful for generating tags for routes at specific paths or query parameters.

```tsx
export const meta: MetaFunction = ({ location }) => {
  const searchQuery = new URLSearchParams(location.search).get('q');
  return [{ title: `Search results for "${searchQuery}"` }];
};
```

### `matches`

This is an array of the current route matches. You have access to many things, particularly the meta from the parent matches and data.

The interface for `matches` is similar to the return value of [`useMatches`][use-matches], but each match will include the output of its `meta` function. This is useful for [merging metadata across the route hierarchy][merging-metadata-across-the-route-hierarchy].

### `data`

This is the data from your route's [`loader`][loader].

```tsx
export async function loader({ params }: LoaderFunctionArgs) {
  return json({
    task: await getTask(params.projectId, params.taskId),
  });
}

export const meta: MetaFunction<typeof loader> = ({ data }) => {
  return [{ title: data.task.name }];
};
```

### `params`

The route's URL params. See [Dynamic Segments in the Routing Guide][url-params].

### `error`

Thrown errors that trigger error boundaries will be passed to the `meta` function. This is useful for generating metadata for error pages.

```tsx
export const meta: MetaFunction = ({ error }) => {
  return [{ title: error ? 'oops!' : 'Actual title' }];
};
```

## Accessing Data from Parent Route Loaders

In addition to the current route's data, often you'll want to access data from a route higher up in the route hierarchy. You can look it up by its route ID in [`matches`][matches].

```tsx filename=app/routes/project.$pid.tasks.$tid.tsx
import type { loader as projectDetailsLoader } from './project.$pid';

export async function loader({ params }: LoaderFunctionArgs) {
  return json({ task: await getTask(params.tid) });
}

export const meta: MetaFunction<
  typeof loader,
  { 'routes/project.$pid': typeof projectDetailsLoader }
> = ({ data, matches }) => {
  const project = matches.find((match) => match.id === 'routes/project.$pid').data.project;
  const task = data.task;
  return [{ title: `${project.name}: ${task.name}` }];
};
```

## Gotchas with `meta` and Nested Routes

Because multiple nested routes render at the same time, there is some merging that needs to happen to determine the meta tags that ultimately render. Remix gives you complete control over this merge because there is no obvious default.

Remix will take the last matching route with a meta export and use that. This allows you to override things like `title`, remove things like `og:image` that the parent route added, or keep everything from the parent and add new meta for the child route.

This can get quite tricky when you're new.

Consider a route like `/projects/123`, there are likely three matching routes: `app/root.tsx`, `app/routes/projects.tsx`, and `app/routes/projects.$id.tsx`. All three may export meta descriptors.

```tsx bad filename=app/root.tsx
export const meta: MetaFunction = () => {
  return [
    {
      name: 'viewport',
      content: 'width=device-width,initial-scale=1',
    },
    { title: 'New Remix App' },
  ];
};
```

```tsx bad filename=app/routes/projects.tsx
export const meta: MetaFunction = () => {
  return [{ title: 'Projects' }];
};
```

```tsx bad filename=app/routes/projects.$id.tsx
export const meta: MetaFunction<typeof loader> = ({ data }) => {
  return [{ title: data.project.name }];
};
```

With this code, we will lose the `viewport` meta tag at `/projects` and `/projects/123` because only the last meta is used and the code doesn't merge with the parent.

### Global `meta`

Nearly every app will have global meta like the `viewport` and `charSet`. We recommend using normal [`<meta>` tags][meta-element] inside the [root route][root-route] instead of the `meta` export, so you simply don't have to deal with merging:

```tsx filename=app/root.tsx lines=[12-16]
import { Links, Meta, Outlet, Scripts } from '@remix-run/react';

export default function App() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
      </head>
      <body>
        <Outlet />
        <Scripts />
      </body>
    </html>
  );
}
```

### Avoid `meta` in Parent Routes

You can also avoid the merge problem by simply not exporting `meta` that you want to override from parent routes. Instead of defining `meta` on the parent route, use the [index route][index-route]. This way you can avoid complex merge logic for things like the title. Otherwise, you will need to find the parent title descriptor and replace it with the child's title. It's much easier to simply not need to override by using index routes.

### Merging with Parent `meta`

Usually you only need to add `meta` to what the parent has already defined. You can merge parent `meta` with the spread operator and the [`matches`][matches] argument:

```tsx
export const meta: MetaFunction = ({ matches }) => {
  const parentMeta = matches.flatMap((match) => match.meta ?? []);
  return [...parentMeta, { title: 'Projects' }];
};
```

Note that this _will not_ override something like `title`. This is only additive. If the inherited route meta includes a `title` tag, you can override with [`Array.prototype.filter`][array-filter]:

```tsx
export const meta: MetaFunction = ({ matches }) => {
  const parentMeta = matches
    .flatMap((match) => match.meta ?? [])
    .filter((meta) => !('title' in meta));
  return [...parentMeta, { title: 'Projects' }];
};
```

### `meta` Merging helper

If you can't avoid the merge problem with global meta or index routes, we've created a helper that you can put in your app that can override and append to parent meta easily.

- [View Gist for `merge-meta.ts`][merge-meta]

[meta-element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta
[link-element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link
[links]: ./links
[use-matches]: ../hooks/use-matches
[merging-metadata-across-the-route-hierarchy]: #merging-with-parent-meta
[loader]: ./loader
[url-params]: ../file-conventions/routes#dynamic-segments
[matches]: #matches
[root-route]: ../file-conventions/root
[index-route]: ../discussion/routes#index-routes
[array-filter]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
[merge-meta]: https://gist.github.com/ryanflorence/ec1849c6d690cfbffcb408ecd633e069

---

## File: ./route/should-revalidate.md

---

## title: shouldRevalidate

# `shouldRevalidate`

This function lets apps optimize which routes data should be reloaded after actions and for client-side navigations.

```tsx
import type { ShouldRevalidateFunction } from '@remix-run/react';

export const shouldRevalidate: ShouldRevalidateFunction = ({
  actionResult,
  currentParams,
  currentUrl,
  defaultShouldRevalidate,
  formAction,
  formData,
  formEncType,
  formMethod,
  nextParams,
  nextUrl,
}) => {
  return true;
};
```

<docs-warning>This feature is an <i>additional</i> optimization. In general, Remix's design already optimizes which loaders need to be called and when. When you use this feature you risk your UI getting out of sync with your server. Use with caution!</docs-warning>

During client-side transitions, Remix will optimize reloading of routes that are already rendering, like not reloading layout routes that aren't changing. In other cases, like form submissions or search param changes, Remix doesn't know which routes need to be reloaded, so it reloads them all to be safe. This ensures your UI always stays in sync with the state on your server.

This function lets apps further optimize by returning `false` when Remix is about to reload a route. If you define this function on a route module, Remix will defer to your function on every navigation and every revalidation after an action is called. Again, this makes it possible for your UI to get out of sync with your server if you do it wrong, so be careful.

`fetcher.load` calls also revalidate, but because they load a specific URL, they don't have to worry about route param or URL search param revalidations. `fetcher.load`'s only revalidate by default after action submissions and explicit revalidation requests via [`useRevalidator`][userevalidator].

## `actionResult`

When a submission causes the revalidation this will be the result of the action‚Äîeither action data or an error if the action failed. It's common to include some information in the action result to instruct `shouldRevalidate` to revalidate or not.

```tsx
export async function action() {
  await saveSomeStuff();
  return { ok: true };
}

export function shouldRevalidate({ actionResult, defaultShouldRevalidate }) {
  if (actionResult?.ok) {
    return false;
  }
  return defaultShouldRevalidate;
}
```

## `defaultShouldRevalidate`

By default, Remix doesn't call every loader all the time. There are reliable optimizations it can make by default. For example, only loaders with changing params are called. Consider navigating from the following URL to the one below it:

- `/projects/123/tasks/abc`
- `/projects/123/tasks/def`

Remix will only call the loader for `tasks/def` because the param for `projects/123` didn't change.

It's safest to always return `defaultShouldRevalidate` after you've done your specific optimizations that return `false`, otherwise your UI might get out of sync with your data on the server.

```tsx
export function shouldRevalidate({ defaultShouldRevalidate }) {
  if (whateverConditionsYouCareAbout) {
    return false;
  }

  return defaultShouldRevalidate;
}
```

This is more dangerous, but YOLO:

```tsx
export function shouldRevalidate() {
  return whateverConditionsYouCareAbout;
}
```

## `currentParams`

These are the [URL params][url-params] from the URL that can be compared to the `nextParams` to decide if you need to reload or not. Perhaps you're using only a partial piece of the param for data loading, you don't need to revalidate if a superfluous part of the param changed.

For instance, consider an event slug with the id and a human-friendly title:

- `/events/blink-182-united-center-saint-paul--ae3f9`
- `/events/blink-182-little-caesars-arena-detroit--e87ad`

```tsx filename=app/routes/events.$slug.tsx
export async function loader({ params }: LoaderFunctionArgs) {
  const id = params.slug.split('--')[1];
  return loadEvent(id);
}

export function shouldRevalidate({ currentParams, nextParams, defaultShouldRevalidate }) {
  const currentId = currentParams.slug.split('--')[1];
  const nextId = nextParams.slug.split('--')[1];
  if (currentId === nextId) {
    return false;
  }

  return defaultShouldRevalidate;
}
```

## `currentUrl`

This is the url the navigation started from.

## `nextParams`

In the case of navigation, these are the [URL params][url-params] from the next location the user is requesting. Some revalidations are not navigation, so it will simply be the same as `currentParams`.

## `nextUrl`

In the case of navigation, this the URL the user is requesting. Some revalidations are not navigation, so it will simply be the same as `currentUrl`.

## `formMethod`

The method (probably `"GET"` or `"POST"`) used from the form submission that triggered the revalidation.

## `formAction`

The form action (`<Form action="/somewhere">`) that triggered the revalidation.

## `formData`

The data submitted with the form that triggered the revalidation.

## Use Cases

### Never reloading the root

It's common for root loaders to return data that never changes, like environment variables to be sent to the client app. In these cases you never need the root loader to be called again. For this case, you can simply `return false`.

```tsx lines=[10]
export const loader = async () => {
  return json({
    ENV: {
      CLOUDINARY_ACCT: process.env.CLOUDINARY_ACCT,
      STRIPE_PUBLIC_KEY: process.env.STRIPE_PUBLIC_KEY,
    },
  });
};

export const shouldRevalidate = () => false;
```

With this in place, Remix will no longer make a request to your root loader for any reason, not after form submissions, not after search param changes, etc.

### Ignoring search params

Another common case is when you've got nested routes and a child component has a feature that uses the search params in the URL, like a search page or some tabs with state you want to keep in the search params.

Consider these routes:

```
‚îú‚îÄ‚îÄ $projectId.tsx
‚îî‚îÄ‚îÄ $projectId.activity.tsx
```

And let's say the UI looks something like this:

```
+------------------------------+
|    Project: Design Revamp    |
+------------------------------+
|  Tasks | Collabs | >ACTIVITY |
+------------------------------+
|  Search: _____________       |
|                              |
|  - Ryan added an image       |
|                              |
|  - Michael commented         |
|                              |
+------------------------------+
```

The `$projectId.activity.tsx` loader can use the search params to filter the list, so visiting a URL like `/projects/design-revamp/activity?search=image` could filter the list of results. Maybe it looks something like this:

```tsx filename=app/routes/$projectId.activity.tsx lines=[11]
export async function loader({ params, request }: LoaderFunctionArgs) {
  const url = new URL(request.url);
  return json(
    await exampleDb.activity.findAll({
      where: {
        projectId: params.projectId,
        name: {
          contains: url.searchParams.get('search'),
        },
      },
    }),
  );
}
```

This is great for the activity route, but Remix doesn't know if the parent loader, `$projectId.tsx` _also_ cares about the search params. That's why Remix does the safest thing and reloads all the routes on the page when the search params change.

In this UI, that's wasted bandwidth for the user, your server, and your database because `$projectId.tsx` doesn't use the search params. Consider that our loader for `$projectId.tsx` looks something like this:

```tsx filename=app/routes/$projectId.tsx
export async function loader({ params }: LoaderFunctionArgs) {
  const data = await fakedb.findProject(params.projectId);
  return json(data);
}
```

There are a lot of ways to do this, and the rest of the code in the app matters, but ideally you don't think about the UI you're trying to optimize (the search params changing) but instead look at the values your loader cares about. In our case, it only cares about the projectId, so we can check two things:

- did the params stay the same?
- was it a `GET` and not a mutation?

If the params didn't change, and we didn't do a `POST`, then we know our loader will return the same data it did last time, so we can opt out of the revalidation when the child route changes the search params.

```tsx filename=app/routes/$projectId.tsx
export function shouldRevalidate({
  currentParams,
  nextParams,
  formMethod,
  defaultShouldRevalidate,
}) {
  if (formMethod === 'GET' && currentParams.projectId === nextParams.projectId) {
    return false;
  }

  return defaultShouldRevalidate;
}
```

[url-params]: ../file-conventions/routes#dynamic-segments
[userevalidator]: ../hooks/use-revalidator

---

## File: ./start/changelog.md

---

## title: Changelog

# Changelog

See the detailed changelog for each release on [GitHub][changelog].

[changelog]: https://github.com/remix-run/remix/blob/main/CHANGELOG.md

---

## File: ./start/community.md

---

title: Community
description: Community resources for learning Remix and related technologies
order: 4

---

# Community

We work hard to keep the Remix community a friendly place where people want to hang out, help, and be helped. We're all here just trying to build great websites and make the web better.

To that end, please keep in mind [our code of conduct][our-code-of-conduct].

- [Remix Discord][remix-discord-server] - A great place to have conversations, ask and answer questions, all about Remix.

- [GitHub Discussions][git-hub-discussions-forum] - This is the best place to propose changes to Remix. The team uses it to gauge interest and understand use cases.

- [Remix Twitter][twitter] - Tips, updates, and news about Remix from the team.

- [Examples][the-examples-repository] - Dozens of Remix examples from the team and community.

- [Remix Conf][remix-conf] - A yearly conference all about Remix with talks primarily from the community.

- [Remix Mailing List][official-remix-team-mailing-list] - Not-so-regular email from the Remix team letting you know what the team is up to.

- [Meetups][the-remix-meetup-page] - There are Remix Meetups all over the world with thousands of members. Some online, some in person, and some a hybrid of the two.

- [Remix Guide][remix-guide] - A wonderful community site that gathers together everything that's going on in the Remix ecosystem: online courses, blog posts, app templates, events and more.

- [Moulton][moulton] - Community Remix newsletter

- [Releases on GitHub][releases-on-git-hub] - Not a bad idea to subscribe to Remix releases, so you know what's coming.

[our-code-of-conduct]: https://github.com/remix-run/remix/blob/main/CODE_OF_CONDUCT.md
[remix-discord-server]: https://rmx.as/discord
[git-hub-discussions-forum]: https://github.com/remix-run/remix/discussions
[the-examples-repository]: https://github.com/remix-run/examples
[official-remix-team-mailing-list]: https://remix.run/newsletter
[moulton]: https://www.readmoulton.com
[releases-on-git-hub]: https://github.com/remix-run/remix/releases
[official]: ../tutorials/blog
[tutorials]: ../tutorials/jokes
[remix-conf]: /conf
[the-remix-meetup-page]: https://rmx.as/meetup
[remix-guide]: https://remix.guide
[twitter]: https://twitter.com/remix_run

---

## File: ./start/future-flags.md

---

title: Future Flags
order: 5

---

# Future Flags and Deprecations

This guide walks you through the process of adopting future flags in your Remix app. By following this strategy, you will be able to upgrade to the next major version of Remix with minimal changes. To read more about future flags see [Development Strategy][development-strategy].

We highly recommend you make a commit after each step and ship it instead of doing everything all at once. Most flags can be adopted in any order, with exceptions noted below.

## Update to latest v2.x

First update to the latest minor version of v2.x to have the latest future flags. You will likely see a number of deprecation warnings as you upgrade, which we'll cover below.

üëâ **Update to latest v2**

```shellscript nonumber
npm install @remix-run/{dev,react,node,etc.}@2
```

## Remove `installGlobals`

**Background**

Previously Remix required a `fetch` polyfill to be installed. This was accomplished by calling `installGlobals()`.

The next major version requires a minimum of Node 20 to take advantage of the built-in `fetch` support.

Note: if you are using miniflare/cloudflare worker with your remix project, ensure your [compatibility flag][compatibility-flag] is set to `2023-03-01` or later as well.

üëâ **Update to Node 20+**

It is recommended that you upgrade to the latest even-numbered version of Node LTS.

üëâ **Remove `installGlobals`**

```diff filename=vite.config.ts
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

-installGlobals();

export default defineConfig({
  plugins: [remix()],
});
```

## Adopt the Vite Plugin

**Background**

Remix no longer uses its own, closed compiler (now referred to as the "Classic Compiler"), and instead uses [Vite][vite]. Vite is a powerful, performant and extensible development environment for JavaScript projects. [View the Vite docs][vite-docs] for more information on performance, troubleshooting, etc.

While this is not a future flag, new features and some feature flags are only available in the Vite plugin, and the Classic Compiler will be removed in the next version of Remix.

üëâ **Install Vite**

```shellscript nonumber
npm install -D vite
```

**Update your Code**

üëâ **Replace `remix.config.js` with `vite.config.ts` at the root of your Remix app**

```ts filename=vite.config.ts
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [remix()],
});
```

The subset of [supported Remix config options][supported-remix-config-options] should be passed directly to the plugin:

```ts filename=vite.config.ts lines=[3-5]
export default defineConfig({
  plugins: [
    remix({
      ignoredRouteFiles: ['**/*.css'],
    }),
  ],
});
```

üëâ **Add `unstable_optimizeDeps` (optional)**

Many users found that automatically [optimizing dependencies][dependency-optimization] helped them more easily adopt the Vite plugin. For this reason we added the `unstable_optimizeDeps` flag to the Vite plugin.

This flag will remain in an "unstable" state until React Router v7 so it is not critical that you adopt this in your Remix v2 app prior to upgrading to React Router v7.

```ts filename=vite.config.ts lines=[4-6]
export default defineConfig({
  plugins: [
    remix({
      future: {
        unstable_optimizeDeps: true,
      },
    }),
  ],
});
```

üëâ **Remove `<LiveReload/>`, keep `<Scripts />`**

```diff
  import {
-   LiveReload,
    Outlet,
    Scripts,
  }

  export default function App() {
    return (
      <html>
        <head>
        </head>
        <body>
          <Outlet />
-         <LiveReload />
          <Scripts />
        </body>
      </html>
    )
  }
```

üëâ **Update `tsconfig.json`**

Update the `types` field in `tsconfig.json` and make sure `skipLibCheck`, `module`, and `moduleResolution` are all set correctly.

```json filename=tsconfig.json lines=[3-6]
{
  "compilerOptions": {
    "types": ["@remix-run/node", "vite/client"],
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "Bundler"
  }
}
```

üëâ **Update/remove `remix.env.d.ts`**

Remove the following type declarations in `remix.env.d.ts`

```diff filename=remix.env.d.ts
- /// <reference types="@remix-run/dev" />
- /// <reference types="@remix-run/node" />
```

If `remix.env.d.ts` is now empty, delete it

```shellscript nonumber
rm remix.env.d.ts
```

**Configure path aliases**

Vite does not provide any path aliases by default. If you were relying on this feature, such as defining `~` as an alias for the `app` directory, you can install the [vite-tsconfig-paths][vite-tsconfig-paths] plugin to automatically resolve path aliases from your `tsconfig.json` in Vite, matching the behavior of the Remix compiler:

üëâ **Install `vite-tsconfig-paths`**

```shellscript nonumber
npm install -D vite-tsconfig-paths
```

üëâ **Add `vite-tsconfig-paths` to your Vite config**

```ts filename=vite.config.ts lines=[3,6]
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';
import tsconfigPaths from 'vite-tsconfig-paths';

export default defineConfig({
  plugins: [remix(), tsconfigPaths()],
});
```

**Remove `@remix-run/css-bundle`**

Vite has built-in support for CSS side effect imports, PostCSS and CSS Modules, among other CSS bundling features. The Remix Vite plugin automatically attaches bundled CSS to the relevant routes.

The <nobr>[`@remix-run/css-bundle`][css-bundling]</nobr> package is redundant when using Vite since its `cssBundleHref` export will always be `undefined`.

üëâ **Uninstall `@remix-run/css-bundle`**

```shellscript nonumber
npm uninstall @remix-run/css-bundle
```

üëâ **Remove references to `cssBundleHref`**

```diff filename=app/root.tsx
- import { cssBundleHref } from "@remix-run/css-bundle";
  import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno

  export const links: LinksFunction = () => [
-   ...(cssBundleHref
-     ? [{ rel: "stylesheet", href: cssBundleHref }]
-     : []),
    // ...
  ];
```

**Fix up CSS imports referenced in `links`**

If you are [referencing CSS in a `links` function][regular-css], you'll need to update the corresponding CSS imports to use [Vite's explicit `?url` import syntax.][vite-url-imports]

üëâ **Add `?url` to CSS imports used in `links`**

```diff
-import styles from "~/styles/dashboard.css";
+import styles from "~/styles/dashboard.css?url";

export const links = () => {
  return [
    { rel: "stylesheet", href: styles }
  ];
}
```

**Migrate Tailwind CSS or Vanilla Extract**

If you are using Tailwind CSS or Vanilla Extract, see the [full migration guide][migrate-css-frameworks].

**Migrate from Remix App Server**

üëâ **Update your `dev`, `build` and `start` scripts**

```json filename=package.json lines=[3-5]
{
  "scripts": {
    "dev": "remix vite:dev",
    "build": "remix vite:build",
    "start": "remix-serve ./build/server/index.js"
  }
}
```

üëâ **Configure your Vite dev server port (optional)**

```js filename=vite.config.ts lines=[2-4]
export default defineConfig({
  server: {
    port: 3000,
  },
  plugins: [remix()],
});
```

**Migrate a custom server**

If you are migrating a customer server or Cloudflare Functions, see the [full migration guide][migrate-a-custom-server].

**Migrate MDX routes**

If you're using [MDX][mdx], you should use the official [MDX Rollup plugin][mdx-rollup-plugin]. See the [full migration guide][migrate-mdx] for a step-by-step walkthrough.

## v3_fetcherPersist

**Background**

The fetcher lifecycle is now based on when it returns to an idle state rather than when its owner component unmounts: [View the RFC][fetcherpersist-rfc] for more information.

üëâ **Enable the Flag**

```ts filename=vite.config.ts
remix({
  future: {
    v3_fetcherPersist: true,
  },
});
```

**Update your Code**

It's unlikely to affect your app. You may want to check any usage of `useFetchers` as they may persist longer than they did before. Depending on what you're doing, you may render something longer than before.

## v3_relativeSplatPath

**Background**

Changes the relative path matching and linking for multi-segment splats paths like `dashboard/*` (vs. just `*`). [View the CHANGELOG][relativesplatpath-changelog] for more information.

üëâ **Enable the Flag**

```ts filename=vite.config.ts
remix({
  future: {
    v3_relativeSplatPath: true,
  },
});
```

**Update your Code**

If you have any routes with a path + a splat like `dashboard.$.tsx` or `route("dashboard/*")` that have relative links like `<Link to="relative">` or `<Link to="../relative">` beneath it, you will need to update your code.

üëâ **Split the route into two**

For any splat routes split it into a layout route and a child route with the splat:

```diff

‚îî‚îÄ‚îÄ routes
    ‚îú‚îÄ‚îÄ _index.tsx
+   ‚îú‚îÄ‚îÄ dashboard.tsx
    ‚îî‚îÄ‚îÄ dashboard.$.tsx

// or
routes(defineRoutes) {
  return defineRoutes((route) => {
    route("/", "home/route.tsx", { index: true });
-    route("dashboard/*", "dashboard/route.tsx")
+    route("dashboard", "dashboard/layout.tsx", () => {
+      route("*", "dashboard/route.tsx");
    });
  });
},
```

üëâ **Update relative links**

Update any `<Link>` elements with relative links within that route tree to include the extra `..` relative segment to continue linking to the same place:

```diff
// dashboard.$.tsx or dashboard/route.tsx
function Dashboard() {
  return (
    <div>
      <h2>Dashboard</h2>
      <nav>
-        <Link to="">Dashboard Home</Link>
-        <Link to="team">Team</Link>
-        <Link to="projects">Projects</Link>
+        <Link to="../">Dashboard Home</Link>
+        <Link to="../team">Team</Link>
+        <Link to="../projects">Projects</Link>
      </nav>
    </div>
  );
}
```

## v3_throwAbortReason

**Background**

When a server-side request is aborted, such as when a user navigates away from a page before the loader finishes, Remix will throw the `request.signal.reason` instead of an error such as `new Error("query() call aborted...")`.

üëâ **Enable the Flag**

```ts filename=vite.config.ts
remix({
  future: {
    v3_throwAbortReason: true,
  },
});
```

**Update your Code**

You likely won't need to adjust any code, unless you had custom logic inside of `handleError` that was matching the previous error message to differentiate it from other errors.

## v3_lazyRouteDiscovery

**Background**

With this flag, Remix no longer sends the full route manifest up to the client on initial load. Instead, Remix only sends the server-rendered routes up in the manifest and then fetches the remaining routes as the user navigated around the application. Additional details are available in the [docs][lazy-route-discovery] and the [blog post][lazy-route-discovery-blog-post]

üëâ **Enable the Flag**

```ts filename=vite.config.ts
remix({
  future: {
    v3_lazyRouteDiscovery: true,
  },
});
```

**Update your Code**

You shouldn't need to make any changes to your application code for this feature to work.

You may find some usage for the new [`<Link discover>`][discover-prop] API if you wish to disable eager route discovery on certain links.

## v3_singleFetch

<docs-warning>

This flag requires the [Vite plugin][vite-plugin].

</docs-warning>

**Background**

With this flag, Remix uses a single fetch for data requests during client-side navigations. This simplifies data loading by treating data requests the same as document requests, eliminating the need to handle headers and caching differently. For advanced use cases, you can still opt into fine-grained revalidations. View the ["Single Fetch" docs][single-fetch] for more information.

üëâ **Enable the Flag (and the types)**

```ts filename=vite.config.ts lines=[5-10,16]
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';
import tsconfigPaths from 'vite-tsconfig-paths';

declare module '@remix-run/node' {
  // or cloudflare, deno, etc.
  interface Future {
    v3_singleFetch: true;
  }
}

export default defineConfig({
  plugins: [
    remix({
      future: {
        v3_singleFetch: true,
      },
    }),
    tsconfigPaths(),
  ],
});
```

**Update your Code**

You should be able to mostly use your code as-is with the flag enabled, but the following changes should be made over time and will be required prior to the next major version.

üëâ **Remove `json()`/`defer()` in favor of raw objects**

Single Fetch supports JSON objects and Promises out of the box, so you can return the raw data from your `loader`/`action` functions:

```diff
-import { json } from "@remix-run/node";

export async function loader({}: LoaderFunctionArgs) {
  let tasks = await fetchTasks();
- return json(tasks);
+ return tasks;
}
```

```diff
-import { defer } from "@remix-run/node";

export async function loader({}: LoaderFunctionArgs) {
  let lazyStuff = fetchLazyStuff();
  let tasks = await fetchTasks();
- return defer({ tasks, lazyStuff });
+ return { tasks, lazyStuff };
}
```

If you were using the second parameter of `json`/`defer` to set a custom status or headers on your response, you can continue doing so via the new `data` API (please note that you will need a `headers` export to apply those headers to Single Fetch data requests):

```diff
-import { json } from "@remix-run/node";
+import { data } from "@remix-run/node";

// This example assumes you already have a headers function to handle header
// merging for your document requests
export function headers() {
  // ...
}

export async function loader({}: LoaderFunctionArgs) {
  let tasks = await fetchTasks();
-  return json(tasks, {
+  return data(tasks, {
    headers: {
      "Cache-Control": "public, max-age=604800"
    }
  });
}
```

üëâ **Adjust your server abort delay**

If you were using a custom `ABORT_DELAY` in your `entry.server.tsx` file, you should change that to use thew new `streamTimeout` API leveraged by Single Fetch:

```diff filename=entry.server.tsx
-const ABORT_DELAY = 5000;
+// Reject/cancel all pending promises after 5 seconds
+export const streamTimeout = 5000;

// ...

function handleBrowserRequest(/* ... */) {
  return new Promise((resolve, reject) => {
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer
        context={remixContext}
        url={request.url}
-        abortDelay={ABORT_DELAY}
      />,
      {
        onShellReady() {
          /* ... */
        },
        onShellError(error: unknown) {
          /* ... */
        },
        onError(error: unknown) {
          /* ... */
        },
      }
    );

-    setTimeout(abort, ABORT_DELAY);
+   // Automatically timeout the React renderer after 6 seconds, which ensures
+   // React has enough time to flush down the rejected boundary contents
+   setTimeout(abort, streamTimeout + 1000);
  });
}
```

## v3_routeConfig

<docs-warning>

This flag requires the [Vite plugin][vite-plugin].

</docs-warning>

Config-based routing is the new default in React Router v7, configured via the `routes.ts` file in the app directory. Support for `routes.ts` and its related APIs in Remix are designed as a migration path to help minimize the number of changes required when moving your Remix project over to React Router v7. While some new packages have been introduced within the `@remix-run` scope, these new packages only exist to keep the code in `routes.ts` as similar as possible to the equivalent code for React Router v7.

When the `v3_routeConfig` future flag is enabled, Remix's built-in file system routing will be disabled and your project will opted into React Router v7's config-based routing. If you prefer to keep using Remix's file-based routing we cover how to enable it in `routes.ts` below.

**Update your code**

To migrate Remix's file system routing and route config to the equivalent setup in React Router v7, you can follow these steps:

üëâ **Enable the Flag**

```ts filename=vite.config.ts
remix({
  future: {
    v3_routeConfig: true,
  },
});
```

üëâ **Install `@remix-run/route-config`**

This package matches the API of React Router v7's `@react-router/dev/routes`, making the React Router v7 migration as easy as possible.

```shellscript nonumber
npm install -D @remix-run/route-config
```

This provides the core `RouteConfig` type as well as a set of helpers for configuring routes in code.

üëâ **Add an `app/routes.ts` file without any configured routes**

```shellscript nonumber
touch app/routes.ts
```

```ts filename=app/routes.ts
import type { RouteConfig } from '@remix-run/route-config';

export default [] satisfies RouteConfig;
```

This is a good way to check that your new `routes.ts` file is being picked up successfully. Your app should now be rendering a blank page since there aren't any routes defined yet.

üëâ **Install `@remix-run/fs-routes` and use it in `routes.ts`**

```shellscript nonumber
npm install -D @remix-run/fs-routes
```

This package matches the API of React Router v7's `@react-router/fs-routes`, making the React Router v7 migration as easy as possible.

> If you've configured `ignoredRouteFiles` to `["**/*"]`, you should skip this step since you're already opting out of Remix's file system routing.

```ts filename=app/routes.ts
import { flatRoutes } from '@remix-run/fs-routes';

export default flatRoutes();
```

üëâ **If you used the `routes` config option, add `@remix-run/routes-option-adapter` and use it in `routes.ts`**

Remix provides a mechanism for defining routes in code and plugging in alternative file system routing conventions, available via the `routes` option on the Vite plugin.

To make migration easier, an adapter package is available that converts Remix's `routes` option into React Router's `RouteConfig` array.

To get started, first install the adapter:

```shellscript nonumber
npm install -D @remix-run/routes-option-adapter
```

This package matches the API of React Router v7's `@react-router/remix-routes-option-adapter`, making the React Router v7 migration as easy as possible.

Then, update your `routes.ts` file to use the adapter, passing the value of your `routes` option to the `remixRoutesOptionAdapter` function which will return an array of configured routes.

For example, if you were using the `routes` option to use an alternative file system routing implementation like [remix-flat-routes]:

```ts filename=app/routes.ts
import { type RouteConfig } from '@remix-run/route-config';
import { remixRoutesOptionAdapter } from '@remix-run/routes-option-adapter';
import { flatRoutes } from 'remix-flat-routes';

export default remixRoutesOptionAdapter((defineRoutes) =>
  flatRoutes('routes', defineRoutes),
) satisfies RouteConfig;
```

Or, if you were using the `routes` option to define config-based routes:

```ts filename=app/routes.ts
import { flatRoutes } from '@remix-run/fs-routes';
import { type RouteConfig } from '@remix-run/route-config';
import { remixRoutesOptionAdapter } from '@remix-run/routes-option-adapter';

export default remixRoutesOptionAdapter((defineRoutes) => {
  return defineRoutes((route) => {
    route('/', 'home/route.tsx', { index: true });
    route('about', 'about/route.tsx');
    route('', 'concerts/layout.tsx', () => {
      route('trending', 'concerts/trending.tsx');
      route(':city', 'concerts/city.tsx');
    });
  });
}) satisfies RouteConfig;
```

If you're defining config-based routes in this way, you might want to consider migrating to the new route config API since it's more streamlined while still being very similar to the old API. For example, the routes above would look like this:

```ts
import { type RouteConfig, route, layout, index } from '@remix-run/route-config';

export default [
  index('home/route.tsx'),
  route('about', 'about/route.tsx'),
  layout('concerts/layout.tsx', [
    route('trending', 'concerts/trending.tsx'),
    route(':city', 'concerts/city.tsx'),
  ]),
] satisfies RouteConfig;
```

Note that if you need to mix and match different route config approaches, they can be merged together into a single array of routes. The `RouteConfig` type ensures that everything is still valid.

```ts
import { flatRoutes } from '@remix-run/fs-routes';
import type { RouteConfig } from '@remix-run/route-config';
import { route } from '@remix-run/route-config';
import { remixRoutesOptionAdapter } from '@remix-run/routes-option-adapter';

export default [
  ...(await flatRoutes({ rootDirectory: 'fs-routes' })),

  ...(await remixRoutesOptionAdapter(/* ... */)),

  route('/hello', 'routes/hello.tsx'),
] satisfies RouteConfig;
```

## Deprecations

### @remix-run/eslint-config

The `@remix-run/eslint-config` package is deprecated and will not be included in React Router v7. We recommend moving towards a streamlined ESLint config such as the ones included in [the Remix templates][remix-template-eslint-config].

### json

This utility is deprecated and will be removed in React Router v7 in favor of [Single Fetch][v3_singlefetch] naked object returns.

- If you were not relying on `json` to serialize your data (such as stringifying `Date` objects), you can safely remove it.
- If you were returning `headers` or `status` via `json`, you can use the new [data util][data-api] as a drop-in replacement to set those values.
- If you want to serialize your data to JSON, you can use the native [Response.json()][response-json] method.

View the [Single Fetch][v3_singlefetch] docs for more information.

### defer

This utility is deprecated and will be removed in React Router v7 in favor of [Single Fetch][v3_singlefetch] naked object returns.

- If you were returning `headers` or `status` via `defer`, you can use the new [data util][data-api] as a drop-in replacement to set those values.

View the [Single Fetch][v3_singlefetch] docs for more information.

### SerializeFrom

This type is deprecated and will be removed in React Router v7 since [Single Fetch][v3_singlefetch] no longer serializes data to JSON.

If you are relying on `SerializeFrom` to unwrap your `loader`/`action` data, you can use a custom type like this:

```ts
type SerializeFrom<T> = ReturnType<typeof useLoaderData<T>>;
```

In most cases, you should be able to just remove `SerializeFrom` and use the types returned from `useLoaderData`/`useActionData`, or the types of the data in `loader`/`action` functions.

### Multipart Form Data and File Upload utilities

The following utilities are deprecated and will be removed in React Router v7:

- `unstable_parseMultipartFormData`
- `unstable_composeUploadHandlers`
- `unstable_createFileUploadHandler`
- `unstable_createMemoryUploadHandler`

We recommend using [`@mjackson/form-data-parser`][form-data-parser] and [`@mjackson/file-storage`][file-storage] to handle multipart form data and file uploads.

You can also checkout the [React Router "File Uploads" doc][react-router-file-uploads] or ["File uploads with Remix"][file-uploads-with-remix] blog post for guides on using these libraries.

[development-strategy]: ../guides/api-development-strategy
[fetcherpersist-rfc]: https://github.com/remix-run/remix/discussions/7698
[relativesplatpath-changelog]: https://github.com/remix-run/remix/blob/main/CHANGELOG.md#futurev3_relativesplatpath
[single-fetch]: ../guides/single-fetch
[lazy-route-discovery]: ../guides/lazy-route-discovery
[lazy-route-discovery-blog-post]: https://remix.run/blog/fog-of-war
[discover-prop]: ../components/link#discover
[vite]: https://vitejs.dev
[vite-docs]: ../guides/vite
[supported-remix-config-options]: ../file-conventions/vite-config
[migrate-css-frameworks]: ../guides/vite#enable-tailwind-via-postcss
[migrate-a-custom-server]: ../guides/vite#migrating-a-custom-server
[migrate-mdx]: ../guides/vite#add-mdx-plugin
[vite-tsconfig-paths]: https://github.com/aleclarson/vite-tsconfig-paths
[css-bundling]: ../styling/bundling
[regular-css]: ../styling/css
[vite-url-imports]: https://vitejs.dev/guide/assets.html#explicit-url-imports
[mdx]: https://mdxjs.com
[mdx-rollup-plugin]: https://mdxjs.com/packages/rollup
[remix-flat-routes]: https://github.com/kiliman/remix-flat-routes
[dependency-optimization]: ../guides/dependency-optimization
[compatibility-flag]: https://developers.cloudflare.com/workers/configuration/compatibility-dates
[vite-plugin]: #adopt-the-vite-plugin
[v3_singlefetch]: #v3_singlefetch
[data-api]: ../utils/data
[response-json]: https://developer.mozilla.org/en-US/docs/Web/API/Response/json
[remix-template-eslint-config]: https://github.com/remix-run/remix/blob/main/templates/remix/.eslintrc.cjs
[form-data-parser]: https://github.com/mjackson/remix-the-web/tree/main/packages/form-data-parser
[file-storage]: https://github.com/mjackson/remix-the-web/tree/main/packages/file-storage
[file-uploads-with-remix]: https://programmingarehard.com/2024/09/06/remix-file-uploads-updated.html/
[react-router-file-uploads]: https://reactrouter.com/how-to/file-uploads

---

## File: ./start/index.md

---

title: Getting Started
order: 1

---

---

## File: ./start/quickstart.md

---

title: Quick Start (5m)
order: 1

---

# Quick Start

<docs-warning>Just getting started with Remix? The latest version of [Remix is now React Router v7][remix-now-react-router]. If you want to use the latest features, you should use the [React Router docs to get started][react-router-get-started].</docs-warning>

This guide will get you familiar with the basic plumbing required to run a Remix app as quickly as possible. While there are many starter templates with different runtimes, deploy targets, and databases, we're going to create a bare-bones project from scratch.

When you're ready to get serious about your Remix project, you might consider starting with a community template. They include TypeScript setups, databases, testing harnesses, authentication, and more. You can find a list of community templates on the [Remix Resources][templates] page.

## Installation

If you prefer to initialize a batteries-included Remix project, you can use the [`create-remix` CLI][create-remix]:

```shellscript nonumber
npx create-remix@latest
```

However, this guide will explain everything the CLI does to set up your project, and instead of using the CLI you can follow these steps. If you're just getting started with Remix, we recommend following this guide to understand all of the different pieces that make up a Remix app.

```shellscript nonumber
mkdir my-remix-app
cd my-remix-app
npm init -y

# install runtime dependencies
npm i @remix-run/node @remix-run/react @remix-run/serve isbot@4 react react-dom

# install dev dependencies
npm i -D @remix-run/dev vite
```

## Vite Config

```shellscript nonumber
touch vite.config.js
```

Since Remix uses [Vite], you'll need to provide a [Vite config][vite-config] with the Remix Vite plugin. Here's the basic configuration you'll need:

```js filename=vite.config.js
import { vitePlugin as remix } from '@remix-run/dev';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [remix()],
});
```

## The Root Route

```shellscript nonumber
mkdir app
touch app/root.jsx
```

`app/root.jsx` is what we call the "Root Route". It's the root layout of your entire app. Here's the basic set of elements you'll need for any project:

```jsx filename=app/root.jsx
import { Links, Meta, Outlet, Scripts } from '@remix-run/react';

export default function App() {
  return (
    <html>
      <head>
        <link rel="icon" href="data:image/x-icon;base64,AA" />
        <Meta />
        <Links />
      </head>
      <body>
        <h1>Hello world!</h1>
        <Outlet />

        <Scripts />
      </body>
    </html>
  );
}
```

## Build and Run

First build the app for production:

```shellscript nonumber
npx remix vite:build
```

You should now see a `build` folder containing a `server` folder (the server version of your app) and a `client` folder (the browser version) with some build artifacts in them. (This is all [configurable][vite_config].)

üëâ **Run the app with `remix-serve`**

First you will need to specify the type in `package.json` as module so that `remix-serve` can run your app.

```jsonc filename=package.json lines=[2] nocopy
{
  "type": "module",
  // ...
}
```

Now you can run your app with `remix-serve`:

```shellscript nonumber
# note the dash!
npx remix-serve build/server/index.js
```

You should be able to open up [http://localhost:3000][http-localhost-3000] and see the "hello world" page.

Aside from the unholy amount of code in `node_modules`, our Remix app is just three files:

```
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îî‚îÄ‚îÄ root.jsx
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ vite.config.js
```

## Bring Your Own Server

The `build/server` directory created by `remix vite:build` is just a module that you run inside a server like Express, Cloudflare Workers, Netlify, Vercel, Fastly, AWS, Deno, Azure, Fastify, Firebase, ... anywhere.

If you don't care to set up your own server, you can use `remix-serve`. It's a simple express-based server maintained by the Remix team. However, Remix is specifically designed to run in _any_ JavaScript environment so that you own your stack. It is expected many ‚Äîif not most‚Äî production apps will have their own server. You can read more about this in [Runtimes, Adapters, and Stacks][runtimes].

Just for kicks, let's stop using `remix-serve` and use express instead.

üëâ **Install Express, the Remix Express adapter, and [cross-env] for running in production mode**

```shellscript nonumber
npm i express @remix-run/express cross-env

# not going to use this anymore
npm uninstall @remix-run/serve
```

üëâ **Create an Express server**

```shellscript nonumber
touch server.js
```

```js filename=server.js
import { createRequestHandler } from '@remix-run/express';
import express from 'express';

// notice that the result of `remix vite:build` is "just a module"
import * as build from './build/server/index.js';

const app = express();
app.use(express.static('build/client'));

// and your app is "just a request handler"
app.all('*', createRequestHandler({ build }));

app.listen(3000, () => {
  console.log('App listening on http://localhost:3000');
});
```

üëâ **Run your app with express**

```shellscript nonumber
node server.js
```

Now that you own your server, you can debug your app with whatever tooling your server has. For example, you can inspect your app with chrome devtools with the [Node.js inspect flag][inspect]:

```shellscript nonumber
node --inspect server.js
```

## Development Workflow

Instead of stopping, rebuilding, and starting your server all the time, you can run Remix in development using [Vite in middleware mode][vite-middleware]. This enables instant feedback to changes in your app with React Refresh (Hot Module Replacement) and Remix Hot Data Revalidation.

First, as a convenience, add `dev` and `start` commands in `package.json` that will run your server in development and production modes respectively:

üëâ **Add a "scripts" entry to `package.json`**

```jsonc filename=package.json lines=[2-4] nocopy
{
  "scripts": {
    "dev": "node ./server.js",
    "start": "cross-env NODE_ENV=production node ./server.js",
  },
  // ...
}
```

üëâ **Add Vite development middleware to your server**

Vite middleware is not applied if `process.env.NODE_ENV` is set to `"production"`, in which case you'll still be running the regular build output as you did earlier.

```js filename=server.js lines=[4-11,14-18,20-25]
import { createRequestHandler } from '@remix-run/express';
import express from 'express';

const viteDevServer =
  process.env.NODE_ENV === 'production'
    ? null
    : await import('vite').then((vite) =>
        vite.createServer({
          server: { middlewareMode: true },
        }),
      );

const app = express();
app.use(viteDevServer ? viteDevServer.middlewares : express.static('build/client'));

const build = viteDevServer
  ? () => viteDevServer.ssrLoadModule('virtual:remix/server-build')
  : await import('./build/server/index.js');

app.all('*', createRequestHandler({ build }));

app.listen(3000, () => {
  console.log('App listening on http://localhost:3000');
});
```

üëâ **Start the dev server**

```shellscript nonumber
npm run dev
```

Now you can work on your app with immediate feedback. Give it a shot, change the text in `root.jsx` and watch!

## Controlling Server and Browser Entries

There are default magic files Remix is using that most apps don't need to mess with, but if you want to customize Remix's entry points to the server and browser you can run `remix reveal` and they'll get dumped into your project.

```shellscript nonumber
npx remix reveal
```

```
Entry file entry.client created at app/entry.client.tsx.
Entry file entry.server created at app/entry.server.tsx.
```

## Summary

Congrats, you can add Remix to your resume! Summing things up, we've learned:

- Remix compiles your app into two things:
  - A request handler that you add to your own JavaScript server
  - A pile of static assets in your public directory for the browser
- You can bring your own server with adapters to deploy anywhere
- You can set up a development workflow with HMR built-in

In general, Remix is a bit "guts out". A few minutes of boilerplate but now you own your stack.

What's next?

- [Tutorial][tutorial]

[create-remix]: ../other-api/create-remix
[runtimes]: ../discussion/runtimes
[inspect]: https://nodejs.org/en/docs/guides/debugging-getting-started/
[tutorial]: ./tutorial
[vite_config]: ../file-conventions/vite-config
[templates]: /resources?category=templates
[http-localhost-3000]: http://localhost:3000
[es-modules]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules
[vite]: https://vitejs.dev
[vite-config]: https://vitejs.dev/config
[vite-middleware]: https://vitejs.dev/guide/ssr#setting-up-the-dev-server
[cross-env]: https://www.npmjs.com/package/cross-env
[remix-now-react-router]: https://remix.run/blog/incremental-path-to-react-19
[react-router-get-started]: https://reactrouter.com/start/framework/installation

---

## File: ./start/tutorial.md

---

title: Tutorial (30m)
order: 2

---

# Remix Tutorial

<docs-warning>Just getting started with Remix? The latest version of [Remix is now React Router v7][remix-now-react-router]. If you want to use the latest framework features, you can follow the same [tutorial from the React Router docs][react-router-tutorial].</docs-warning>

We'll be building a small, but feature-rich app that lets you keep track of your contacts. There's no database or other "production ready" things, so we can stay focused on Remix. We expect it to take about 30m if you're following along, otherwise it's a quick read.

<img class="tutorial" src="/docs-images/contacts/01.webp" />

üëâ **Every time you see this it means you need to do something in the app!**

The rest is just there for your information and deeper understanding. Let's get to it.

## Setup

üëâ **Generate a basic template**

```shellscript nonumber
npx create-remix@latest --template remix-run/remix/templates/remix-tutorial
```

This uses a pretty bare-bones template but includes our css and data model, so we can focus on Remix. The [Quick Start][quickstart] can familiarize you with the basic setup of a Remix project if you'd like to learn more.

üëâ **Start the app**

```shellscript nonumber
# cd into the app directory
cd {wherever you put the app}

# install dependencies if you haven't already
npm install

# start the server
npm run dev
```

You should be able to open up [http://localhost:5173][http-localhost-5173] and see an unstyled screen that looks like this:

<img class="tutorial" src="/docs-images/contacts/03.webp" />

## The Root Route

Note the file at `app/root.tsx`. This is what we call the "Root Route". It's the first component in the UI that renders, so it typically contains the global layout for the page.

<details>

<summary>Expand here to see the root component code</summary>

```tsx filename=app/root.tsx
import { Form, Links, Meta, Scripts, ScrollRestoration } from '@remix-run/react';

export default function App() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
      </head>
      <body>
        <div id="sidebar">
          <h1>Remix Contacts</h1>
          <div>
            <Form id="search-form" role="search">
              <input
                aria-label="Search contacts"
                id="q"
                name="q"
                placeholder="Search"
                type="search"
              />
              <div aria-hidden hidden={true} id="search-spinner" />
            </Form>
            <Form method="post">
              <button type="submit">New</button>
            </Form>
          </div>
          <nav>
            <ul>
              <li>
                <a href={`/contacts/1`}>Your Name</a>
              </li>
              <li>
                <a href={`/contacts/2`}>Your Friend</a>
              </li>
            </ul>
          </nav>
        </div>

        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}
```

</details>

## Adding Stylesheets with `links`

While there are multiple ways to style your Remix app, we're going to use a plain stylesheet that's already been written to keep things focused on Remix.

You can import CSS files directly into JavaScript modules. Vite will fingerprint the asset, save it to your build's client directory, and provide your module with the publicly accessible href.

üëâ **Import the app styles**

```tsx filename=app/root.tsx lines=[1,4,6-8]
import type { LinksFunction } from '@remix-run/node';
// existing imports

import appStylesHref from './app.css?url';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: appStylesHref }];
```

Every route can export a [`links`][links] function. They will be collected and rendered into the `<Links />` component we rendered in `app/root.tsx`.

The app should look something like this now. It sure is nice having a designer who can also write the CSS, isn't it? (Thank you, [Jim][jim] üôè).

<img class="tutorial" loading="lazy" src="/docs-images/contacts/04.webp" />

## The Contact Route UI

If you click on one of the sidebar items you'll get the default 404 page. Let's create a route that matches the url `/contacts/1`.

üëâ **Create the `app/routes` directory and contact route module**

```shellscript nonumber
mkdir app/routes
touch app/routes/contacts.\$contactId.tsx
```

In the Remix [route file convention][routes-file-conventions], `.` will create a `/` in the URL and `$` makes a segment dynamic. We just created a route that will match URLs that look like this:

- `/contacts/123`
- `/contacts/abc`

üëâ **Add the contact component UI**

It's just a bunch of elements, feel free to copy/paste.

```tsx filename=app/routes/contacts.$contactId.tsx
import { Form } from '@remix-run/react';
import type { FunctionComponent } from 'react';

import type { ContactRecord } from '../data';

export default function Contact() {
  const contact = {
    first: 'Your',
    last: 'Name',
    avatar: 'https://placecats.com/200/200',
    twitter: 'your_handle',
    notes: 'Some notes',
    favorite: true,
  };

  return (
    <div id="contact">
      <div>
        <img
          alt={`${contact.first} ${contact.last} avatar`}
          key={contact.avatar}
          src={contact.avatar}
        />
      </div>

      <div>
        <h1>
          {contact.first || contact.last ? (
            <>
              {contact.first} {contact.last}
            </>
          ) : (
            <i>No Name</i>
          )}{' '}
          <Favorite contact={contact} />
        </h1>

        {contact.twitter ? (
          <p>
            <a href={`https://twitter.com/${contact.twitter}`}>{contact.twitter}</a>
          </p>
        ) : null}

        {contact.notes ? <p>{contact.notes}</p> : null}

        <div>
          <Form action="edit">
            <button type="submit">Edit</button>
          </Form>

          <Form
            action="destroy"
            method="post"
            onSubmit={(event) => {
              const response = confirm('Please confirm you want to delete this record.');
              if (!response) {
                event.preventDefault();
              }
            }}
          >
            <button type="submit">Delete</button>
          </Form>
        </div>
      </div>
    </div>
  );
}

const Favorite: FunctionComponent<{
  contact: Pick<ContactRecord, 'favorite'>;
}> = ({ contact }) => {
  const favorite = contact.favorite;

  return (
    <Form method="post">
      <button
        aria-label={favorite ? 'Remove from favorites' : 'Add to favorites'}
        name="favorite"
        value={favorite ? 'false' : 'true'}
      >
        {favorite ? '‚òÖ' : '‚òÜ'}
      </button>
    </Form>
  );
};
```

Now if we click one of the links or visit `/contacts/1` we get ... nothing new?

<img class="tutorial" loading="lazy" alt="contact route with blank main content" src="/docs-images/contacts/05.webp" />

## Nested Routes and Outlets

Since Remix is built on top of React Router, it supports nested routing. In order for child routes to render inside of parent layouts, we need to render an [`Outlet`][outlet-component] in the parent. Let's fix it, open up `app/root.tsx` and render an outlet inside.

üëâ **Render an [`<Outlet />`][outlet-component]**

```tsx filename=app/root.tsx lines=[6,19-21]
// existing imports
import { Form, Links, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react';

// existing imports & code

export default function App() {
  return (
    <html lang="en">
      {/* other elements */}
      <body>
        <div id="sidebar">{/* other elements */}</div>
        <div id="detail">
          <Outlet />
        </div>
        {/* other elements */}
      </body>
    </html>
  );
}
```

Now the child route should be rendering through the outlet.

<img class="tutorial" loading="lazy" alt="contact route with the main content" src="/docs-images/contacts/06.webp" />

## Client Side Routing

You may or may not have noticed, but when we click the links in the sidebar, the browser is doing a full document request for the next URL instead of client side routing.

Client side routing allows our app to update the URL without requesting another document from the server. Instead, the app can immediately render new UI. Let's make it happen with [`<Link>`][link-component].

üëâ **Change the sidebar `<a href>` to `<Link to>`**

```tsx filename=app/root.tsx lines=[4,24,27]
// existing imports
import { Form, Link, Links, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react';

// existing imports & exports

export default function App() {
  return (
    <html lang="en">
      {/* other elements */}
      <body>
        <div id="sidebar">
          {/* other elements */}
          <nav>
            <ul>
              <li>
                <Link to={`/contacts/1`}>Your Name</Link>
              </li>
              <li>
                <Link to={`/contacts/2`}>Your Friend</Link>
              </li>
            </ul>
          </nav>
        </div>
        {/* other elements */}
      </body>
    </html>
  );
}
```

You can open the network tab in the browser devtools to see that it's not requesting documents anymore.

## Loading Data

URL segments, layouts, and data are more often than not coupled (tripled?) together. We can see it in this app already:

| URL Segment         | Component   | Data               |
| ------------------- | ----------- | ------------------ |
| /                   | `<Root>`    | list of contacts   |
| contacts/:contactId | `<Contact>` | individual contact |

Because of this natural coupling, Remix has data conventions to get data into your route components easily.

There are two APIs we'll be using to load data, [`loader`][loader] and [`useLoaderData`][use-loader-data]. First we'll create and export a `loader` function in the root route and then render the data.

üëâ **Export a `loader` function from `app/root.tsx` and render the data**

<docs-info>The following code has a type error in it, we'll fix it in the next section</docs-info>

```tsx filename=app/root.tsx lines=[2,11,15,19-22,25,34-57]
// existing imports
import { json } from '@remix-run/node';
import {
  Form,
  Link,
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
  useLoaderData,
} from '@remix-run/react';

// existing imports
import { getContacts } from './data';

// existing exports

export const loader = async () => {
  const contacts = await getContacts();
  return json({ contacts });
};

export default function App() {
  const { contacts } = useLoaderData();

  return (
    <html lang="en">
      {/* other elements */}
      <body>
        <div id="sidebar">
          {/* other elements */}
          <nav>
            {contacts.length ? (
              <ul>
                {contacts.map((contact) => (
                  <li key={contact.id}>
                    <Link to={`contacts/${contact.id}`}>
                      {contact.first || contact.last ? (
                        <>
                          {contact.first} {contact.last}
                        </>
                      ) : (
                        <i>No Name</i>
                      )}{' '}
                      {contact.favorite ? <span>‚òÖ</span> : null}
                    </Link>
                  </li>
                ))}
              </ul>
            ) : (
              <p>
                <i>No contacts</i>
              </p>
            )}
          </nav>
        </div>
        {/* other elements */}
      </body>
    </html>
  );
}
```

That's it! Remix will now automatically keep that data in sync with your UI. The sidebar should now look like this:

<img class="tutorial" loading="lazy" src="/docs-images/contacts/07.webp" />

## Type Inference

You may have noticed TypeScript complaining about the `contact` type inside the map. We can add a quick annotation to get type inference about our data with `typeof loader`:

```tsx filename=app/root.tsx lines=[4]
// existing imports & exports

export default function App() {
  const { contacts } = useLoaderData<typeof loader>();

  // existing code
}
```

## URL Params in Loaders

üëâ **Click on one of the sidebar links**

We should be seeing our old static contact page again, with one difference: the URL now has a real ID for the record.

<img class="tutorial" loading="lazy" src="/docs-images/contacts/08.webp" />

Remember the `$contactId` part of the file name at `app/routes/contacts.$contactId.tsx`? These dynamic segments will match dynamic (changing) values in that position of the URL. We call these values in the URL "URL Params", or just "params" for short.

These [`params`][params] are passed to the loader with keys that match the dynamic segment. For example, our segment is named `$contactId` so the value will be passed as `params.contactId`.

These params are most often used to find a record by ID. Let's try it out.

üëâ **Add a `loader` function to the contact page and access data with `useLoaderData`**

<docs-info>The following code has type errors in it, we'll fix them in the next section</docs-info>

```tsx filename=app/routes/contacts.$contactId.tsx lines=[1-2,5,7-10,13]
import { json } from '@remix-run/node';
import { Form, useLoaderData } from '@remix-run/react';
// existing imports

import { getContact } from '../data';

export const loader = async ({ params }) => {
  const contact = await getContact(params.contactId);
  return json({ contact });
};

export default function Contact() {
  const { contact } = useLoaderData<typeof loader>();

  // existing code
}

// existing code
```

<img class="tutorial" loading="lazy" src="/docs-images/contacts/10.webp" />

## Validating Params and Throwing Responses

TypeScript is very upset with us, let's make it happy and see what that forces us to consider:

```tsx filename=app/routes/contacts.$contactId.tsx lines=[1,3,7-10]
import type { LoaderFunctionArgs } from '@remix-run/node';
// existing imports
import invariant from 'tiny-invariant';

// existing imports

export const loader = async ({ params }: LoaderFunctionArgs) => {
  invariant(params.contactId, 'Missing contactId param');
  const contact = await getContact(params.contactId);
  return json({ contact });
};

// existing code
```

First problem this highlights is we might have gotten the param's name wrong between the file name and the code (maybe you changed the name of the file!). Invariant is a handy function for throwing an error with a custom message when you anticipated a potential issue with your code.

Next, the `useLoaderData<typeof loader>()` now knows that we got a contact or `null` (maybe there is no contact with that ID). This potential `null` is cumbersome for our component code and the TS errors are flying around still.

We could account for the possibility of the contact being not found in component code, but the webby thing to do is send a proper 404. We can do that in the loader and solve all of our problems at once.

```tsx filename=app/routes/contacts.$contactId.tsx lines=[8-10]
// existing imports

export const loader = async ({ params }: LoaderFunctionArgs) => {
  invariant(params.contactId, 'Missing contactId param');
  const contact = await getContact(params.contactId);
  if (!contact) {
    throw new Response('Not Found', { status: 404 });
  }
  return json({ contact });
};

// existing code
```

Now, if the user isn't found, code execution down this path stops and Remix renders the error path instead. Components in Remix can focus only on the happy path üòÅ

## Data Mutations

We'll create our first contact in a second, but first let's talk about HTML.

Remix emulates HTML Form navigation as the data mutation primitive, which used to be the only way prior to the JavaScript cambrian explosion. Don't be fooled by the simplicity! Forms in Remix give you the UX capabilities of client rendered apps with the simplicity of the "old school" web model.

While unfamiliar to some web developers, HTML `form`s actually cause a navigation in the browser, just like clicking a link. The only difference is in the request: links can only change the URL while `form`s can also change the request method (`GET` vs. `POST`) and the request body (`POST` form data).

Without client side routing, the browser will serialize the `form`'s data automatically and send it to the server as the request body for `POST`, and as [`URLSearchParams`][url-search-params] for `GET`. Remix does the same thing, except instead of sending the request to the server, it uses client side routing and sends it to the route's [`action`][action] function.

We can test this out by clicking the "New" button in our app.

<img class="tutorial" loading="lazy" src="/docs-images/contacts/09.webp" />

Remix sends a 405 because there is no code on the server to handle this form navigation.

## Creating Contacts

We'll create new contacts by exporting an `action` function in our root route. When the user clicks the "new" button, the form will `POST` to the root route action.

üëâ **Export an `action` function from `app/root.tsx`**

```tsx filename=app/root.tsx lines=[3,5-8]
// existing imports

import { createEmptyContact, getContacts } from './data';

export const action = async () => {
  const contact = await createEmptyContact();
  return json({ contact });
};

// existing code
```

That's it! Go ahead and click the "New" button, and you should see a new record pop into the list ü•≥

<img class="tutorial" loading="lazy" src="/docs-images/contacts/11.webp" />

The `createEmptyContact` method just creates an empty contact with no name or data or anything. But it does still create a record, promise!

> üßê Wait a sec ... How did the sidebar update? Where did we call the `action` function? Where's the code to re-fetch the data? Where are `useState`, `onSubmit` and `useEffect`?!

This is where the "old school web" programming model shows up. [`<Form>`][form-component] prevents the browser from sending the request to the server and sends it to your route's `action` function instead with [`fetch`][fetch].

In web semantics, a `POST` usually means some data is changing. By convention, Remix uses this as a hint to automatically revalidate the data on the page after the `action` finishes.

In fact, since it's all just HTML and HTTP, you could disable JavaScript and the whole thing will still work. Instead of Remix serializing the form and making a [`fetch`][fetch] request to your server, the browser will serialize the form and make a document request. From there Remix will render the page server side and send it down. It's the same UI in the end either way.

We'll keep JavaScript around though because we're going to make a better user experience than spinning favicons and static documents.

## Updating Data

Let's add a way to fill the information for our new record.

Just like creating data, you update data with [`<Form>`][form-component]. Let's make a new route at `app/routes/contacts.$contactId_.edit.tsx`.

üëâ **Create the edit component**

```shellscript nonumber
touch app/routes/contacts.\$contactId_.edit.tsx
```

Note the weird `_` in `$contactId_`. By default, routes will automatically nest inside routes with the same prefixed name. Adding a trailing `_` tells the route to **not** nest inside `app/routes/contacts.$contactId.tsx`. Read more in the [Route File Naming][routes-file-conventions] guide.

üëâ **Add the edit page UI**

Nothing we haven't seen before, feel free to copy/paste:

```tsx filename=app/routes/contacts.$contactId_.edit.tsx
import type { LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import { Form, useLoaderData } from '@remix-run/react';
import invariant from 'tiny-invariant';

import { getContact } from '../data';

export const loader = async ({ params }: LoaderFunctionArgs) => {
  invariant(params.contactId, 'Missing contactId param');
  const contact = await getContact(params.contactId);
  if (!contact) {
    throw new Response('Not Found', { status: 404 });
  }
  return json({ contact });
};

export default function EditContact() {
  const { contact } = useLoaderData<typeof loader>();

  return (
    <Form key={contact.id} id="contact-form" method="post">
      <p>
        <span>Name</span>
        <input
          aria-label="First name"
          defaultValue={contact.first}
          name="first"
          placeholder="First"
          type="text"
        />
        <input
          aria-label="Last name"
          defaultValue={contact.last}
          name="last"
          placeholder="Last"
          type="text"
        />
      </p>
      <label>
        <span>Twitter</span>
        <input defaultValue={contact.twitter} name="twitter" placeholder="@jack" type="text" />
      </label>
      <label>
        <span>Avatar URL</span>
        <input
          aria-label="Avatar URL"
          defaultValue={contact.avatar}
          name="avatar"
          placeholder="https://example.com/avatar.jpg"
          type="text"
        />
      </label>
      <label>
        <span>Notes</span>
        <textarea defaultValue={contact.notes} name="notes" rows={6} />
      </label>
      <p>
        <button type="submit">Save</button>
        <button type="button">Cancel</button>
      </p>
    </Form>
  );
}
```

Now click on your new record, then click the "Edit" button. We should see the new route.

<img class="tutorial" loading="lazy" src="/docs-images/contacts/12.webp" />

## Updating Contacts with `FormData`

The edit route we just created already renders a `form`. All we need to do is add the `action` function. Remix will serialize the `form`, `POST` it with [`fetch`][fetch], and automatically revalidate all the data.

üëâ **Add an `action` function to the edit route**

```tsx filename=app/routes/contacts.$contactId_.edit.tsx lines=[2,5,8,10-19]
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
// existing imports

import { getContact, updateContact } from '../data';

export const action = async ({ params, request }: ActionFunctionArgs) => {
  invariant(params.contactId, 'Missing contactId param');
  const formData = await request.formData();
  const updates = Object.fromEntries(formData);
  await updateContact(params.contactId, updates);
  return redirect(`/contacts/${params.contactId}`);
};

// existing code
```

Fill out the form, hit save, and you should see something like this! <small>(Except easier on the eyes and maybe less hairy.)</small>

<img class="tutorial" loading="lazy" src="/docs-images/contacts/13.webp" />

## Mutation Discussion

> üòë It worked, but I have no idea what is going on here...

Let's dig in a bit...

Open up `contacts.$contactId_.edit.tsx` and look at the `form` elements. Notice how they each have a name:

```tsx filename=app/routes/contacts.$contactId_.edit.tsx lines=[4]
<input
  aria-label="First name"
  defaultValue={contact.first}
  name="first"
  placeholder="First"
  type="text"
/>
```

Without JavaScript, when a form is submitted, the browser will create [`FormData`][form-data] and set it as the body of the request when it sends it to the server. As mentioned before, Remix prevents that and emulates the browser by sending the request to your `action` function with [`fetch`][fetch] instead, including the [`FormData`][form-data].

Each field in the `form` is accessible with `formData.get(name)`. For example, given the input field from above, you could access the first and last names like this:

```tsx filename=app/routes/contacts.$contactId_.edit.tsx lines=[6,7] nocopy
export const action = async ({ params, request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  const firstName = formData.get('first');
  const lastName = formData.get('last');
  // ...
};
```

Since we have a handful of form fields, we used [`Object.fromEntries`][object-from-entries] to collect them all into an object, which is exactly what our `updateContact` function wants.

```tsx filename=app/routes/contacts.$contactId_.edit.tsx nocopy
const updates = Object.fromEntries(formData);
updates.first; // "Some"
updates.last; // "Name"
```

Aside from the `action` function, none of these APIs we're discussing are provided by Remix: [`request`][request], [`request.formData`][request-form-data], [`Object.fromEntries`][object-from-entries] are all provided by the web platform.

After we finished the `action`, note the [`redirect`][redirect] at the end:

```tsx filename=app/routes/contacts.$contactId_.edit.tsx lines=[9]
export const action = async ({ params, request }: ActionFunctionArgs) => {
  invariant(params.contactId, 'Missing contactId param');
  const formData = await request.formData();
  const updates = Object.fromEntries(formData);
  await updateContact(params.contactId, updates);
  return redirect(`/contacts/${params.contactId}`);
};
```

`action` and `loader` functions can both [return a `Response`][returning-response-instances] (makes sense, since they received a [`Request`][request]!). The [`redirect`][redirect] helper just makes it easier to return a [`Response`][response] that tells the app to change locations.

Without client side routing, if a server redirected after a `POST` request, the new page would fetch the latest data and render. As we learned before, Remix emulates this model and automatically revalidates the data on the page after the `action` call. That's why the sidebar automatically updates when we save the form. The extra revalidation code doesn't exist without client side routing, so it doesn't need to exist with client side routing in Remix either!

One last thing. Without JavaScript, the [`redirect`][redirect] would be a normal redirect. However, with JavaScript it's a client-side redirect, so the user doesn't lose client state like scroll positions or component state.

## Redirecting new records to the edit page

Now that we know how to redirect, let's update the action that creates new contacts to redirect to the edit page:

üëâ **Redirect to the new record's edit page**

```tsx filename=app/root.tsx lines=[2,7]
// existing imports
import { json, redirect } from '@remix-run/node';
// existing imports

export const action = async () => {
  const contact = await createEmptyContact();
  return redirect(`/contacts/${contact.id}/edit`);
};

// existing code
```

Now when we click "New", we should end up on the edit page:

<img class="tutorial" loading="lazy" src="/docs-images/contacts/14.webp" />

## Active Link Styling

Now that we have a bunch of records, it's not clear which one we're looking at in the sidebar. We can use [`NavLink`][nav-link] to fix this.

üëâ **Replace `<Link>` with `<NavLink>` in the sidebar**

```tsx filename=app/root.tsx lines=[6,27-36,38]
// existing imports
import {
  Form,
  Links,
  Meta,
  NavLink,
  Outlet,
  Scripts,
  ScrollRestoration,
  useLoaderData,
} from '@remix-run/react';

// existing imports and exports

export default function App() {
  const { contacts } = useLoaderData<typeof loader>();

  return (
    <html lang="en">
      {/* existing elements */}
      <body>
        <div id="sidebar">
          {/* existing elements */}
          <ul>
            {contacts.map((contact) => (
              <li key={contact.id}>
                <NavLink
                  className={({ isActive, isPending }) =>
                    isActive ? 'active' : isPending ? 'pending' : ''
                  }
                  to={`contacts/${contact.id}`}
                >
                  {/* existing elements */}
                </NavLink>
              </li>
            ))}
          </ul>
          {/* existing elements */}
        </div>
        {/* existing elements */}
      </body>
    </html>
  );
}
```

Note that we are passing a function to `className`. When the user is at the URL that matches `<NavLink to>`, then `isActive` will be true. When it's _about_ to be active (the data is still loading) then `isPending` will be true. This allows us to easily indicate where the user is and also provide immediate feedback when links are clicked but data needs to be loaded.

<img class="tutorial" loading="lazy" src="/docs-images/contacts/15.webp"/>

## Global Pending UI

As the user navigates the app, Remix will _leave the old page up_ as data is loading for the next page. You may have noticed the app feels a little unresponsive as you click between the list. Let's provide the user with some feedback so the app doesn't feel unresponsive.

Remix is managing all the state behind the scenes and reveals the pieces you need to build dynamic web apps. In this case, we'll use the [`useNavigation`][use-navigation] hook.

üëâ **Use `useNavigation` to add global pending UI**

```tsx filename=app/root.tsx lines=[11,18,26-28]
// existing imports
import {
  Form,
  Links,
  Meta,
  NavLink,
  Outlet,
  Scripts,
  ScrollRestoration,
  useLoaderData,
  useNavigation,
} from '@remix-run/react';

// existing imports & exports

export default function App() {
  const { contacts } = useLoaderData<typeof loader>();
  const navigation = useNavigation();

  return (
    <html lang="en">
      {/* existing elements */}
      <body>
        {/* existing elements */}
        <div className={navigation.state === 'loading' ? 'loading' : ''} id="detail">
          <Outlet />
        </div>
        {/* existing elements */}
      </body>
    </html>
  );
}
```

[`useNavigation`][use-navigation] returns the current navigation state: it can be one of `"idle"`, `"loading"` or `"submitting"`.

In our case, we add a `"loading"` class to the main part of the app if we're not idle. The CSS then adds a nice fade after a short delay (to avoid flickering the UI for fast loads). You could do anything you want though, like show a spinner or loading bar across the top.

<img class="tutorial" loading="lazy" src="/docs-images/contacts/16.webp" />

## Deleting Records

If we review code in the contact route, we can find the delete button looks like this:

```tsx filename=app/routes/contact.$contactId.tsx lines=[2]
<Form
  action="destroy"
  method="post"
  onSubmit={(event) => {
    const response = confirm('Please confirm you want to delete this record.');
    if (!response) {
      event.preventDefault();
    }
  }}
>
  <button type="submit">Delete</button>
</Form>
```

Note the `action` points to `"destroy"`. Like `<Link to>`, `<Form action>` can take a _relative_ value. Since the form is rendered in `contacts.$contactId.tsx`, then a relative action with `destroy` will submit the form to `contacts.$contactId.destroy` when clicked.

At this point you should know everything you need to know to make the delete button work. Maybe give it a shot before moving on? You'll need:

1. A new route
2. An `action` at that route
3. `deleteContact` from `app/data.ts`
4. `redirect` to somewhere after

üëâ **Create the "destroy" route module**

```shellscript nonumber
touch app/routes/contacts.\$contactId_.destroy.tsx
```

üëâ **Add the destroy action**

```tsx filename=app/routes/contacts.$contactId_.destroy.tsx
import type { ActionFunctionArgs } from '@remix-run/node';
import { redirect } from '@remix-run/node';
import invariant from 'tiny-invariant';

import { deleteContact } from '../data';

export const action = async ({ params }: ActionFunctionArgs) => {
  invariant(params.contactId, 'Missing contactId param');
  await deleteContact(params.contactId);
  return redirect('/');
};
```

Alright, navigate to a record and click the "Delete" button. It works!

> üòÖ I'm still confused why this all works

When the user clicks the submit button:

1. `<Form>` prevents the default browser behavior of sending a new document `POST` request to the server, but instead emulates the browser by creating a `POST` request with client side routing and [`fetch`][fetch]
2. The `<Form action="destroy">` matches the new route at `contacts.$contactId_.destroy.tsx` and sends it the request
3. After the `action` redirects, Remix calls all the `loader`s for the data on the page to get the latest values (this is "revalidation"). `useLoaderData` returns new values and causes the components to update!

Add a `Form`, add an `action`, Remix does the rest.

## Index Routes

When we load up the app, you'll notice a big blank page on the right side of our list.

<img class="tutorial" loading="lazy" src="/docs-images/contacts/17.webp" />

When a route has children, and you're at the parent route's path, the `<Outlet>` has nothing to render because no children match. You can think of index routes as the default child route to fill in that space.

üëâ **Create an index route for the root route**

```shellscript nonumber
touch app/routes/_index.tsx
```

üëâ **Fill in the index component's elements**

Feel free to copy/paste, nothing special here.

```tsx filename=app/routes/_index.tsx
export default function Index() {
  return (
    <p id="index-page">
      This is a demo for Remix.
      <br />
      Check out <a href="https://remix.run">the docs at remix.run</a>.
    </p>
  );
}
```

The route name `_index` is special. It tells Remix to match and render this route when the user is at the parent route's exact path, so there are no other child routes to render in the `<Outlet />`.

<img class="tutorial" loading="lazy" src="/docs-images/contacts/18.webp" />

Voil√†! No more blank space. It's common to put dashboards, stats, feeds, etc. at index routes. They can participate in data loading as well.

## Cancel Button

On the edit page we've got a cancel button that doesn't do anything yet. We'd like it to do the same thing as the browser's back button.

We'll need a click handler on the button as well as [`useNavigate`][use-navigate].

üëâ **Add the cancel button click handler with `useNavigate`**

```tsx filename=app/routes/contacts.$contactId_.edit.tsx lines=[5,11,18]
// existing imports
import { Form, useLoaderData, useNavigate } from '@remix-run/react';
// existing imports & exports

export default function EditContact() {
  const { contact } = useLoaderData<typeof loader>();
  const navigate = useNavigate();

  return (
    <Form key={contact.id} id="contact-form" method="post">
      {/* existing elements */}
      <p>
        <button type="submit">Save</button>
        <button onClick={() => navigate(-1)} type="button">
          Cancel
        </button>
      </p>
    </Form>
  );
}
```

Now when the user clicks "Cancel", they'll be sent back one entry in the browser's history.

> üßê Why is there no `event.preventDefault()` on the button?

A `<button type="button">`, while seemingly redundant, is the HTML way of preventing a button from submitting its form.

Two more features to go. We're on the home stretch!

## `URLSearchParams` and `GET` Submissions

All of our interactive UI so far have been either links that change the URL or `form`s that post data to `action` functions. The search field is interesting because it's a mix of both: it's a `form`, but it only changes the URL, it doesn't change data.

Let's see what happens when we submit the search form:

üëâ **Type a name into the search field and hit the enter key**

Note the browser's URL now contains your query in the URL as [`URLSearchParams`][url-search-params]:

```
http://localhost:5173/?q=ryan
```

Since it's not `<Form method="post">`, Remix emulates the browser by serializing the [`FormData`][form-data] into the [`URLSearchParams`][url-search-params] instead of the request body.

`loader` functions have access to the search params from the `request`. Let's use it to filter the list:

üëâ **Filter the list if there are `URLSearchParams`**

```tsx filename=app/root.tsx lines=[3,8-13]
import type { LinksFunction, LoaderFunctionArgs } from '@remix-run/node';

// existing imports & exports

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const q = url.searchParams.get('q');
  const contacts = await getContacts(q);
  return json({ contacts });
};

// existing code
```

<img class="tutorial" loading="lazy" src="/docs-images/contacts/19.webp" />

Because this is a `GET`, not a `POST`, Remix _does not_ call the `action` function. Submitting a `GET` `form` is the same as clicking a link: only the URL changes.

This also means it's a normal page navigation. You can click the back button to get back to where you were.

## Synchronizing URLs to Form State

There are a couple of UX issues here that we can take care of quickly.

1. If you click back after a search, the form field still has the value you entered even though the list is no longer filtered.
2. If you refresh the page after searching, the form field no longer has the value in it, even though the list is filtered

In other words, the URL and our input's state are out of sync.

Let's solve (2) first and start the input with the value from the URL.

üëâ **Return `q` from your `loader`, set it as the input's default value**

```tsx filename=app/root.tsx lines=[9,13,26]
// existing imports & exports

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const q = url.searchParams.get('q');
  const contacts = await getContacts(q);
  return json({ contacts, q });
};

export default function App() {
  const { contacts, q } = useLoaderData<typeof loader>();
  const navigation = useNavigation();

  return (
    <html lang="en">
      {/* existing elements */}
      <body>
        <div id="sidebar">
          {/* existing elements */}
          <div>
            <Form id="search-form" role="search">
              <input
                aria-label="Search contacts"
                defaultValue={q || ''}
                id="q"
                name="q"
                placeholder="Search"
                type="search"
              />
              {/* existing elements */}
            </Form>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </div>
        {/* existing elements */}
      </body>
    </html>
  );
}
```

The input field will show the query if you refresh the page after a search now.

Now for problem (1), clicking the back button and updating the input. We can bring in `useEffect` from React to manipulate the input's value in the DOM directly.

üëâ **Synchronize input value with the `URLSearchParams`**

```tsx filename=app/root.tsx lines=[2,10-15]
// existing imports
import { useEffect } from 'react';

// existing imports & exports

export default function App() {
  const { contacts, q } = useLoaderData<typeof loader>();
  const navigation = useNavigation();

  useEffect(() => {
    const searchField = document.getElementById('q');
    if (searchField instanceof HTMLInputElement) {
      searchField.value = q || '';
    }
  }, [q]);

  // existing code
}
```

> ü§î Shouldn't you use a controlled component and React State for this?

You could certainly do this as a controlled component. You will have more synchronization points, but it's up to you.

<details>

<summary>Expand this to see what it would look like</summary>

```tsx filename=app/root.tsx lines=[2,9-10,12-16,30-33,36-37]
// existing imports
import { useEffect, useState } from 'react';

// existing imports & exports

export default function App() {
  const { contacts, q } = useLoaderData<typeof loader>();
  const navigation = useNavigation();
  // the query now needs to be kept in state
  const [query, setQuery] = useState(q || '');

  // we still have a `useEffect` to synchronize the query
  // to the component state on back/forward button clicks
  useEffect(() => {
    setQuery(q || '');
  }, [q]);

  return (
    <html lang="en">
      {/* existing elements */}
      <body>
        <div id="sidebar">
          {/* existing elements */}
          <div>
            <Form id="search-form" role="search">
              <input
                aria-label="Search contacts"
                id="q"
                name="q"
                // synchronize user's input to component state
                onChange={(event) => setQuery(event.currentTarget.value)}
                placeholder="Search"
                type="search"
                // switched to `value` from `defaultValue`
                value={query}
              />
              {/* existing elements */}
            </Form>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </div>
        {/* existing elements */}
      </body>
    </html>
  );
}
```

</details>

Alright, you should now be able to click the back/forward/refresh buttons and the input's value should be in sync with the URL and results.

## Submitting `Form`'s `onChange`

We've got a product decision to make here. Sometimes you want the user to submit the `form` to filter some results, other times you want to filter as the user types. We've already implemented the first, so let's see what it's like for the second.

We've seen `useNavigate` already, we'll use its cousin, [`useSubmit`][use-submit], for this.

```tsx filename=app/root.tsx lines=[12,19,32-34]
// existing imports
import {
  Form,
  Links,
  Meta,
  NavLink,
  Outlet,
  Scripts,
  ScrollRestoration,
  useLoaderData,
  useNavigation,
  useSubmit,
} from '@remix-run/react';
// existing imports & exports

export default function App() {
  const { contacts, q } = useLoaderData<typeof loader>();
  const navigation = useNavigation();
  const submit = useSubmit();

  // existing code

  return (
    <html lang="en">
      {/* existing elements */}
      <body>
        <div id="sidebar">
          {/* existing elements */}
          <div>
            <Form id="search-form" onChange={(event) => submit(event.currentTarget)} role="search">
              {/* existing elements */}
            </Form>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </div>
        {/* existing elements */}
      </body>
    </html>
  );
}
```

As you type, the `form` is automatically submitted now!

Note the argument to [`submit`][use-submit]. The `submit` function will serialize and submit any form you pass to it. We're passing in `event.currentTarget`. The `currentTarget` is the DOM node the event is attached to (the `form`).

## Adding Search Spinner

In a production app, it's likely this search will be looking for records in a database that is too large to send all at once and filter client side. That's why this demo has some faked network latency.

Without any loading indicator, the search feels kinda sluggish. Even if we could make our database faster, we'll always have the user's network latency in the way and out of our control.

For a better user experience, let's add some immediate UI feedback for the search. We'll use [`useNavigation`][use-navigation] again.

üëâ **Add a variable to know if we're searching**

```tsx filename=app/root.tsx lines=[7-11]
// existing imports & exports

export default function App() {
  const { contacts, q } = useLoaderData<typeof loader>();
  const navigation = useNavigation();
  const submit = useSubmit();
  const searching = navigation.location && new URLSearchParams(navigation.location.search).has('q');

  // existing code
}
```

When nothing is happening, `navigation.location` will be `undefined`, but when the user navigates it will be populated with the next location while data loads. Then we check if they're searching with `location.search`.

üëâ **Add classes to search form elements using the new `searching` state**

```tsx filename=app/root.tsx lines=[22,31]
// existing imports & exports

export default function App() {
  // existing code

  return (
    <html lang="en">
      {/* existing elements */}
      <body>
        <div id="sidebar">
          {/* existing elements */}
          <div>
            <Form id="search-form" onChange={(event) => submit(event.currentTarget)} role="search">
              <input
                aria-label="Search contacts"
                className={searching ? 'loading' : ''}
                defaultValue={q || ''}
                id="q"
                name="q"
                placeholder="Search"
                type="search"
              />
              <div aria-hidden hidden={!searching} id="search-spinner" />
            </Form>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </div>
        {/* existing elements */}
      </body>
    </html>
  );
}
```

Bonus points, avoid fading out the main screen when searching:

```tsx filename=app/root.tsx lines=[13]
// existing imports & exports

export default function App() {
  // existing code

  return (
    <html lang="en">
      {/* existing elements */}
      <body>
        {/* existing elements */}
        <div className={navigation.state === 'loading' && !searching ? 'loading' : ''} id="detail">
          <Outlet />
        </div>
        {/* existing elements */}
      </body>
    </html>
  );
}
```

You should now have a nice spinner on the left side of the search input.

<img class="tutorial" loading="lazy" src="/docs-images/contacts/20.webp" />

## Managing the History Stack

Since the form is submitted for every keystroke, typing the characters "alex" and then deleting them with backspace results in a huge history stack üòÇ. We definitely don't want this:

<img class="tutorial" loading="lazy" src="/docs-images/contacts/21.webp" />

We can avoid this by _replacing_ the current entry in the history stack with the next page, instead of pushing into it.

üëâ **Use `replace` in `submit`**

```tsx filename=app/root.tsx lines=[16-19]
// existing imports & exports

export default function App() {
  // existing code

  return (
    <html lang="en">
      {/* existing elements */}
      <body>
        <div id="sidebar">
          {/* existing elements */}
          <div>
            <Form
              id="search-form"
              onChange={(event) => {
                const isFirstSearch = q === null;
                submit(event.currentTarget, {
                  replace: !isFirstSearch,
                });
              }}
              role="search"
            >
              {/* existing elements */}
            </Form>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </div>
        {/* existing elements */}
      </body>
    </html>
  );
}
```

After a quick check if this is the first search or not, we decide to replace. Now the first search will add a new entry, but every keystroke after that will replace the current entry. Instead of clicking back 7 times to remove the search, users only have to click back once.

## `Form`s Without Navigation

So far all of our forms have changed the URL. While these user flows are common, it's equally common to want to submit a form _without_ causing a navigation.

For these cases, we have [`useFetcher`][use-fetcher]. It allows us to communicate with `action`s and `loader`s without causing a navigation.

The ‚òÖ button on the contact page makes sense for this. We aren't creating or deleting a new record, and we don't want to change pages. We simply want to change the data on the page we're looking at.

üëâ **Change the `<Favorite>` form to a fetcher form**

```tsx filename=app/routes/contacts.$contactId.tsx lines=[4,14,18,30]
// existing imports
import { Form, useFetcher, useLoaderData } from '@remix-run/react';
// existing imports & exports

// existing code

const Favorite: FunctionComponent<{
  contact: Pick<ContactRecord, 'favorite'>;
}> = ({ contact }) => {
  const fetcher = useFetcher();
  const favorite = contact.favorite;

  return (
    <fetcher.Form method="post">
      <button
        aria-label={favorite ? 'Remove from favorites' : 'Add to favorites'}
        name="favorite"
        value={favorite ? 'false' : 'true'}
      >
        {favorite ? '‚òÖ' : '‚òÜ'}
      </button>
    </fetcher.Form>
  );
};
```

This form will no longer cause a navigation, but simply fetch to the `action`. Speaking of which ... this won't work until we create the `action`.

üëâ **Create the `action`**

```tsx filename=app/routes/contacts.$contactId.tsx lines=[2,7,10-19]
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node';
// existing imports

import { getContact, updateContact } from '../data';
// existing imports

export const action = async ({ params, request }: ActionFunctionArgs) => {
  invariant(params.contactId, 'Missing contactId param');
  const formData = await request.formData();
  return updateContact(params.contactId, {
    favorite: formData.get('favorite') === 'true',
  });
};

// existing code
```

Alright, we're ready to click the star next to the user's name!

<img class="tutorial" loading="lazy" src="/docs-images/contacts/22.webp" />

Check that out, both stars automatically update. Our new `<fetcher.Form method="post">` works almost exactly like the `<Form>` we've been using: it calls the action and then all data is revalidated automatically ‚Äî even your errors will be caught the same way.

There is one key difference though, it's not a navigation, so the URL doesn't change and the history stack is unaffected.

## Optimistic UI

You probably noticed the app felt kind of unresponsive when we clicked the favorite button from the last section. Once again, we added some network latency because you're going to have it in the real world.

To give the user some feedback, we could put the star into a loading state with [`fetcher.state`][fetcher-state] (a lot like `navigation.state` from before), but we can do something even better this time. We can use a strategy called "Optimistic UI".

The fetcher knows the [`FormData`][form-data] being submitted to the `action`, so it's available to you on `fetcher.formData`. We'll use that to immediately update the star's state, even though the network hasn't finished. If the update eventually fails, the UI will revert to the real data.

üëâ **Read the optimistic value from `fetcher.formData`**

```tsx filename=app/routes/contacts.$contactId.tsx lines=[7-9]
// existing code

const Favorite: FunctionComponent<{
  contact: Pick<ContactRecord, 'favorite'>;
}> = ({ contact }) => {
  const fetcher = useFetcher();
  const favorite = fetcher.formData
    ? fetcher.formData.get('favorite') === 'true'
    : contact.favorite;

  return (
    <fetcher.Form method="post">
      <button
        aria-label={favorite ? 'Remove from favorites' : 'Add to favorites'}
        name="favorite"
        value={favorite ? 'false' : 'true'}
      >
        {favorite ? '‚òÖ' : '‚òÜ'}
      </button>
    </fetcher.Form>
  );
};
```

Now the star _immediately_ changes to the new state when you click it.

---

That's it! Thanks for giving Remix a shot. We hope this tutorial gives you a solid start to build great user experiences. There's a lot more you can do, so make sure to check out all the APIs üòÄ

[jim]: https://blog.jim-nielsen.com
[outlet-component]: ../components/outlet
[link-component]: ../components/link
[loader]: ../route/loader
[use-loader-data]: ../hooks/use-loader-data
[action]: ../route/action
[params]: ../route/loader#params
[form-component]: ../components/form
[request]: https://developer.mozilla.org/en-US/docs/Web/API/Request
[form-data]: https://developer.mozilla.org/en-US/docs/Web/API/FormData
[object-from-entries]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries
[request-form-data]: https://developer.mozilla.org/en-US/docs/Web/API/Request/formData
[response]: https://developer.mozilla.org/en-US/docs/Web/API/Response
[redirect]: ../utils/redirect
[returning-response-instances]: ../route/loader#returning-response-instances
[use-navigation]: ../hooks/use-navigation
[use-navigate]: ../hooks/use-navigate
[url-search-params]: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams
[use-submit]: ../hooks/use-submit
[nav-link]: ../components/nav-link
[use-fetcher]: ../hooks/use-fetcher
[fetcher-state]: ../hooks/use-fetcher#fetcherstate
[assets-build-directory]: ../file-conventions/remix-config#assetsbuilddirectory
[links]: ../route/links
[routes-file-conventions]: ../file-conventions/routes
[quickstart]: ./quickstart
[http-localhost-5173]: http://localhost:5173
[fetch]: https://developer.mozilla.org/en-US/docs/Web/API/fetch
[remix-now-react-router]: https://remix.run/blog/incremental-path-to-react-19
[react-router-tutorial]: https://reactrouter.com/tutorials/address-book

---

## File: ./start/v2.md

---

title: Upgrading to v2
order: 3

---

# Upgrading to v2

<docs-warning>This documentation provides guidance on migrating from v1 to v2 while using the [Classic Remix compiler][classic-remix-compiler]. For additional guidance on migrating to Vite, refer to the [Remix Vite documentation][remix-vite].</docs-warning>

All v2 APIs and behaviors are available in v1 with [Future Flags][future-flags]. They can be enabled one at a time to avoid development disruption of your project. After you have enabled all flags, upgrading to v2 should be a non-breaking upgrade.

If you're having trouble see the [Troubleshooting][troubleshooting] section.

For a quick walkthrough of some common upgrade issues checkout [üé• 2 minutes to v2][2-min-to-v2].

## `remix dev`

For configuration options, see the [`remix dev` docs][dev-docs].

### `remix-serve`

If you are using the Remix App Server (`remix-serve`), enable `v2_dev`:

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  future: {
    v2_dev: true,
  },
};
```

That's it!

### Custom app server

If you are using your own app server (`server.js`),
then check out our [templates][templates] for examples of how to integrate with `v2_dev`
or follow these steps:

1. Enable `v2_dev`:

   ```js filename=remix.config.js
   /** @type {import('@remix-run/dev').AppConfig} */
   module.exports = {
     future: {
       v2_dev: true,
     },
   };
   ```

2. Update `scripts` in `package.json`:

   - Replace any `remix watch` with `remix dev`
   - Remove redundant `NODE_ENV=development`
   - Use `-c` / `--command` to run your app server

   For example:

   ```diff filename=package.json
    {
      "scripts": {
   -    "dev:remix": "cross-env NODE_ENV=development remix watch",
   -    "dev:server": "cross-env NODE_ENV=development node ./server.js"
   +    "dev": "remix dev -c 'node ./server.js'",
      }
    }
   ```

3. Send a "ready" message to the Remix compiler once your app is running

   ```ts filename=server.js lines=[1-2,11]
   import { broadcastDevReady } from '@remix-run/node';
   // import { logDevReady } from "@remix-run/cloudflare" // use `logDevReady` if using CloudFlare

   const BUILD_DIR = path.join(process.cwd(), 'build');

   // ... code setting up your server goes here ...

   const port = 3000;
   app.listen(port, async () => {
     console.log(`üëâ http://localhost:${port}`);
     broadcastDevReady(await import(BUILD_DIR));
   });
   ```

4. (Optional) `--manual`

   If you were relying on `require` cache purging, you can keep doing so by using the `--manual` flag:

   ```shellscript nonumber
   remix dev --manual -c 'node ./server.js'
   ```

   Check out the [manual mode guide][manual-mode] for more details.

### After upgrading from v1 to v2

After you've enabled the `future.v2_dev` flag in v1 and gotten that working, you're ready to upgrade to v2.
If you just had `v2_dev` set to `true`, you can remove it and things should work.

If you are using `v2_dev` config, you'll need to move it to the `dev` config field:

```diff filename=remix.config.js
  /** @type {import('@remix-run/dev').AppConfig} */
  module.exports = {
-   future: {
-     v2_dev: {
-       port: 4004
-     }
-   }
+   dev: {
+     port: 4004
+   }
  }
```

## File System Route Convention

#### Upgrading without changing files

You can keep using the old convention with `@remix-run/v1-route-convention` even after upgrading to v2 if you don't want to make the change right now (or ever, it's just a convention, and you can use whatever file organization you prefer).

```shellscript nonumber
npm i -D @remix-run/v1-route-convention
```

```js filename=remix.config.js
const { createRoutesFromFolders } = require('@remix-run/v1-route-convention');

/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  future: {
    // makes the warning go away in v1.15+
    v2_routeConvention: true,
  },

  routes(defineRoutes) {
    // uses the v1 convention, works in v1.15+ and v2
    return createRoutesFromFolders(defineRoutes);
  },
};
```

#### Upgrading to the new convention

- Route nesting is now created by dots (`.`) in file names instead of folder nesting
- `suffixed_` underscores in segments opt-out of nesting with a potentially matching parent route instead of dots (`.`).
- `_prefixed` underscores in segments create layout routes without a path instead of a `__double` underscore prefix.
- `_index.tsx` files create index routes instead of `index.tsx`

A routes folder that looks like this in v1:

```text bad
app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ __auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logout.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signup.tsx
‚îÇ   ‚îú‚îÄ‚îÄ __public/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ about-us.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ contact.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ calendar/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ $day.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ projects/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ $projectId/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ collaborators.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ settings.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tasks.$taskId.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ $projectId.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ new.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ calendar.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ projects.tsx
‚îÇ   ‚îú‚îÄ‚îÄ __auth.tsx
‚îÇ   ‚îú‚îÄ‚îÄ __public.tsx
‚îÇ   ‚îî‚îÄ‚îÄ dashboard.projects.$projectId.print.tsx
‚îî‚îÄ‚îÄ root.tsx
```

Becomes this with `v2_routeConvention`:

```text good
app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ _auth.login.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _auth.logout.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _auth.signup.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _auth.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _public._index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _public.about-us.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _public.contact.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _public.tsx
‚îÇ   ‚îú‚îÄ‚îÄ dashboard._index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.calendar._index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.calendar.$day.tsx
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.calendar.tsx
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.projects.$projectId._index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.projects.$projectId.collaborators.tsx
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.projects.$projectId.edit.tsx
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.projects.$projectId.settings.tsx
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.projects.$projectId.tasks.$taskId.tsx
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.projects.$projectId.tsx
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.projects.new.tsx
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.projects.tsx
‚îÇ   ‚îî‚îÄ‚îÄ dashboard_.projects.$projectId.print.tsx
‚îî‚îÄ‚îÄ root.tsx
```

Note that parent routes are now grouped together instead of having dozens of routes between them (like the auth routes). Routes with the same path but not the same nesting (like `dashboard` and `dashboard_`) also group together.

With the new convention, any route can be a directory with a `route.tsx` file inside to define the route module. This enables co-location of modules with the route they're used in:

For example, we can move `_public.tsx` to `_public/route.tsx` and then co-locate modules the route uses:

```text
app/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ _auth.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _public/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ footer.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ header.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _public._index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ _public.about-us.tsx
‚îÇ   ‚îî‚îÄ‚îÄ etc.
‚îî‚îÄ‚îÄ root.tsx
```

For more background on this change, see the [original "flat routes" proposal][flat-routes].

## Route `headers`

In Remix v2, the behavior for route `headers` functions has changed slightly. You can opt-into this new behavior ahead of time via the `future.v2_headers` flag in `remix.config.js`.

In v1, Remix would only use the result of the leaf "rendered" route `headers` function. It was your responsibility to add a `headers` function to every potential leaf and merge in `parentHeaders` accordingly. This can get tedious quickly and is also easy to forget to add a `headers` function when you add a new route, even if you want it to just share the same headers from its parent.

In v2, Remix now uses the deepest `headers` function that it finds in the rendered routes. This more easily allows you to share headers across routes from a common ancestor. Then as needed you can add `headers` functions to deeper routes if they require specific behavior.

## Route `meta`

In Remix v2, the signature for route `meta` functions and how Remix handles meta tags under the hood have changed.

Instead of returning an object from `meta`, you will now return an array of descriptors and manage the merge yourself. This brings the `meta` API closer to `links`, and it allows for more flexibility and control over how meta tags are rendered.

In addition, `<Meta />` will no longer render meta for every route in the hierarchy. Only data returned from `meta` in the leaf route will be rendered. You can still choose to include meta from the parent route by accessing [`matches` in the function's arguments][meta-v2-matches].

For more background on this change, see the [original v2 `meta` proposal][meta-v2-rfc].

#### Using v1 `meta` conventions in v2

You can update your `meta` exports with the `@remix-run/v1-meta` package to continue using v1 conventions.

Using the `metaV1` function, you can pass in the `meta` function's arguments and the same object it currently returns. This function will use the same merging logic to merge the leaf route's meta with its **direct parent route** meta before converting it to an array of meta descriptors usable in v2.

```tsx bad filename=app/routes/v1-route.tsx
export function meta() {
  return {
    title: '...',
    description: '...',
    'og:title': '...',
  };
}
```

```tsx filename=app/routes/v2-route.tsx good
import { metaV1 } from '@remix-run/v1-meta';

export function meta(args) {
  return metaV1(args, {
    title: '...',
    description: '...',
    'og:title': '...',
  });
}
```

It's important to note that this function will _not_ merge meta across the entire hierarchy by default. This is because you may have some routes that return an array of objects directly without the `metaV1` function and this could result in unpredictable behavior. If you want to merge meta across the entire hierarchy, use the `metaV1` function for all of your route's meta exports.

#### The `parentsData` argument

In v2, the `meta` function no longer receives the `parentsData` argument. This is because `meta` now has access to all of your route matches via the [`matches` argument][meta-v2-matches], which includes loader data for each match.

To replicate the API of `parentsData`, the `@remix-run/v1-meta` package provides a `getMatchesData` function. It returns an object where the data for each match is keyed by the route's ID.

```tsx bad filename=app/routes/v1-route.tsx
export function meta(args) {
  const parentData = args.parentsData['routes/parent'];
}
```

Becomes:

```tsx filename=app/routes/v2-route.tsx good
import { getMatchesData } from '@remix-run/v1-meta';

export function meta(args) {
  const matchesData = getMatchesData(args);
  const parentData = matchesData['routes/parent'];
}
```

#### Updating to the new `meta`

```tsx bad filename=app/routes/v1-route.tsx
export function meta() {
  return {
    title: '...',
    description: '...',
    'og:title': '...',
  };
}
```

```tsx filename=app/routes/v2-route.tsx good
export function meta() {
  return [
    { title: '...' },
    { name: 'description', content: '...' },
    { property: 'og:title', content: '...' },

    // you can now add SEO related <links>
    { tagName: 'link', rel: 'canonical', href: '...' },

    // and <script type=ld+json>
    {
      'script:ld+json': {
        some: 'value',
      },
    },
  ];
}
```

#### The `matches` argument

Note that in v1 the objects returned from nested routes were all merged, you will need to manage the merge yourself now with `matches`:

```tsx filename=app/routes/v2-route.tsx good
export function meta({ matches }) {
  const rootMeta = matches[0].meta;
  const title = rootMeta.find((m) => m.title);

  return [
    title,
    { name: 'description', content: '...' },
    { property: 'og:title', content: '...' },

    // you can now add SEO related <links>
    { tagName: 'link', rel: 'canonical', href: '...' },

    // and <script type=ld+json>
    {
      'script:ld+json': {
        '@context': 'https://schema.org',
        '@type': 'Organization',
        name: 'Remix',
      },
    },
  ];
}
```

The [meta][meta] docs have more tips on merging route meta.

## `CatchBoundary` and `ErrorBoundary`

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  future: {
    v2_errorBoundary: true,
  },
};
```

In v1, a thrown `Response` rendered the closest `CatchBoundary` while all other unhandled exceptions rendered the `ErrorBoundary`. In v2 there is no `CatchBoundary` and all unhandled exceptions will render the `ErrorBoundary`, response or otherwise.

Additionally, the error is no longer passed to `ErrorBoundary` as props but is accessed with the `useRouteError` hook.

```tsx bad filename=app/routes/v1-route.tsx
import { useCatch } from '@remix-run/react';

export function CatchBoundary() {
  const caught = useCatch();

  return (
    <div>
      <h1>Oops</h1>
      <p>Status: {caught.status}</p>
      <p>{caught.data.message}</p>
    </div>
  );
}

export function ErrorBoundary({ error }) {
  console.error(error);
  return (
    <div>
      <h1>Uh oh ...</h1>
      <p>Something went wrong</p>
      <pre>{error.message || 'Unknown error'}</pre>
    </div>
  );
}
```

Becomes:

```tsx filename=app/routes/v2-route.tsx good
import { useRouteError, isRouteErrorResponse } from '@remix-run/react';

export function ErrorBoundary() {
  const error = useRouteError();

  // when true, this is what used to go to `CatchBoundary`
  if (isRouteErrorResponse(error)) {
    return (
      <div>
        <h1>Oops</h1>
        <p>Status: {error.status}</p>
        <p>{error.data.message}</p>
      </div>
    );
  }

  // Don't forget to typecheck with your own logic.
  // Any value can be thrown, not just errors!
  let errorMessage = 'Unknown error';
  if (isDefinitelyAnError(error)) {
    errorMessage = error.message;
  }

  return (
    <div>
      <h1>Uh oh ...</h1>
      <p>Something went wrong.</p>
      <pre>{errorMessage}</pre>
    </div>
  );
}
```

## `formMethod`

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  future: {
    v2_normalizeFormMethod: true,
  },
};
```

Multiple APIs return the `formMethod` of a submission. In v1 they returned a lowercase version of the method but in v2 they return the UPPERCASE version. This is to bring it in line with HTTP and `fetch` specifications.

```tsx
function Something() {
  const navigation = useNavigation();

  // v1
  navigation.formMethod === 'post';

  // v2
  navigation.formMethod === 'POST';
}

export function shouldRevalidate({ formMethod }) {
  // v1
  formMethod === 'post';

  // v2
  formMethod === 'POST';
}
```

## `useTransition`

This hook is now called `useNavigation` to avoid confusion with the recent React hook by the same name. It also no longer has the `type` field and flattens the `submission` object into the `navigation` object itself.

```tsx bad filename=app/routes/v1-route.tsx
import { useTransition } from '@remix-run/react';

function SomeComponent() {
  const transition = useTransition();
  transition.submission.formData;
  transition.submission.formMethod;
  transition.submission.formAction;
  transition.type;
}
```

```tsx filename=app/routes/v2-route.tsx good
import { useNavigation } from '@remix-run/react';

function SomeComponent() {
  const navigation = useNavigation();

  // transition.submission keys are flattened onto `navigation[key]`
  navigation.formData;
  navigation.formMethod;
  navigation.formAction;

  // this key is removed
  navigation.type;
}
```

You can derive the previous `transition.type` with the following examples. Keep in mind, there's probably a simpler way to get the same behavior, usually checking `navigation.state`, `navigation.formData` or the data returned from an action with `useActionData` can get the UX you're looking for. Feel free to ask us in Discord, and we'll help you out :D

```tsx
function Component() {
  const navigation = useNavigation();

  // transition.type === "actionSubmission"
  const isActionSubmission = navigation.state === 'submitting';

  // transition.type === "actionReload"
  const isActionReload =
    navigation.state === 'loading' &&
    navigation.formMethod != null &&
    navigation.formMethod != 'GET' &&
    // We had a submission navigation and are loading the submitted location
    navigation.formAction === navigation.location.pathname;

  // transition.type === "actionRedirect"
  const isActionRedirect =
    navigation.state === 'loading' &&
    navigation.formMethod != null &&
    navigation.formMethod != 'GET' &&
    // We had a submission navigation and are now navigating to different location
    navigation.formAction !== navigation.location.pathname;

  // transition.type === "loaderSubmission"
  const isLoaderSubmission =
    navigation.state === 'loading' &&
    navigation.state.formMethod === 'GET' &&
    // We had a loader submission and are navigating to the submitted location
    navigation.formAction === navigation.location.pathname;

  // transition.type === "loaderSubmissionRedirect"
  const isLoaderSubmissionRedirect =
    navigation.state === 'loading' &&
    navigation.state.formMethod === 'GET' &&
    // We had a loader submission and are navigating to a new location
    navigation.formAction !== navigation.location.pathname;
}
```

**A note on GET submissions**

In Remix v1, GET submissions such as `<Form method="get">` or `submit({}, { method: 'get' })` went from `idle -> submitting -> idle` in `transition.state`. This is not quite semantically correct since even though you're "submitting" a form, you're performing a GET navigation and only executing loaders (not actions). Functionally, it's no different from a `<Link>` or `navigate()` except that the user may be specifying the search param values via inputs.

In v2, GET submissions are more accurately reflected as loading navigations and thus go `idle -> loading -> idle` to align `navigation.state` with the behavior of normal links. If your GET submission came from a `<Form>` or `submit()`, then `useNavigation.form*` will be populated, so you can differentiate if needed.

## `useFetcher`

Like `useNavigation`, `useFetcher` has flattened the `submission` and removed the `type` field.

```tsx bad filename=app/routes/v1-route.tsx
import { useFetcher } from '@remix-run/react';

function SomeComponent() {
  const fetcher = useFetcher();
  fetcher.submission.formData;
  fetcher.submission.formMethod;
  fetcher.submission.formAction;
  fetcher.type;
}
```

```tsx filename=app/routes/v2-route.tsx good
import { useFetcher } from '@remix-run/react';

function SomeComponent() {
  const fetcher = useFetcher();

  // these keys are flattened
  fetcher.formData;
  fetcher.formMethod;
  fetcher.formAction;

  // this key is removed
  fetcher.type;
}
```

You can derive the previous `fetcher.type` with the following examples. Keep in mind, there's probably a simpler way to get the same behavior, usually checking `fetcher.state`, `fetcher.formData` or the data returned from an action on `fetcher.data` can get the UX you're looking for. Feel free to ask us in Discord, and we'll help you out :D

```tsx
function Component() {
  const fetcher = useFetcher();

  // fetcher.type === "init"
  const isInit = fetcher.state === 'idle' && fetcher.data == null;

  // fetcher.type === "done"
  const isDone = fetcher.state === 'idle' && fetcher.data != null;

  // fetcher.type === "actionSubmission"
  const isActionSubmission = fetcher.state === 'submitting';

  // fetcher.type === "actionReload"
  const isActionReload =
    fetcher.state === 'loading' &&
    fetcher.formMethod != null &&
    fetcher.formMethod != 'GET' &&
    // If we returned data, we must be reloading
    fetcher.data != null;

  // fetcher.type === "actionRedirect"
  const isActionRedirect =
    fetcher.state === 'loading' &&
    fetcher.formMethod != null &&
    fetcher.formMethod != 'GET' &&
    // If we have no data we must have redirected
    fetcher.data == null;

  // fetcher.type === "loaderSubmission"
  const isLoaderSubmission = fetcher.state === 'loading' && fetcher.formMethod === 'GET';

  // fetcher.type === "normalLoad"
  const isNormalLoad = fetcher.state === 'loading' && fetcher.formMethod == null;
}
```

**A note on GET submissions**

In Remix v1, GET submissions such as `<fetcher.Form method="get">` or `fetcher.submit({}, { method: 'get' })` went from `idle -> submitting -> idle` in `fetcher.state`. This is not quite semantically correct since even though you're "submitting" a form, you're performing a GET request and only executing a loader (not an action). Functionally, it's no different from a `fetcher.load()` except that the user may be specifying the search param values via inputs.

In v2, GET submissions are more accurately reflected as loading requests and thus go `idle -> loading -> idle` to align `fetcher.state` with the behavior of normal fetcher loads. If your GET submission came from a `<fetcher.Form>` or `fetcher.submit()`, then `fetcher.form*` will be populated, so you can differentiate if needed.

## Links `imagesizes` and `imagesrcset`

Route `links` properties should all be the React camelCase values instead of HTML lowercase values. These two values snuck in as lowercase in v1. In v2 only the camelCase versions are valid:

```tsx bad filename=app/routes/v1-route.tsx
export const links: LinksFunction = () => {
  return [
    {
      rel: 'preload',
      as: 'image',
      imagesrcset: '...',
      imagesizes: '...',
    },
  ];
};
```

```tsx filename=app/routes/v2-route.tsx good
export const links: V2_LinksFunction = () => {
  return [
    {
      rel: 'preload',
      as: 'image',
      imageSrcSet: '...',
      imageSizes: '...',
    },
  ];
};
```

## `browserBuildDirectory`

In your `remix.config.js`, rename `browserBuildDirectory` to `assetsBuildDirectory`.

```js bad filename=remix.config.js lines=[3]
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  browserBuildDirectory: './public/build',
};
```

```js filename=remix.config.js good lines=[3]
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  assetsBuildDirectory: './public/build',
};
```

## `devServerBroadcastDelay`

Remove `devServerBroadcastDelay` from your `remix.config.js` as the race conditions that necessitated this option have
been eliminated in v2 or with `v2_dev`.

```diff filename=remix.config.js
  /** @type {import('@remix-run/dev').AppConfig} */
  module.exports = {
-   devServerBroadcastDelay: 300,
  };
```

## `devServerPort`

In your `remix.config.js`, rename `devServerPort` to `future.v2_dev.port`.

```js bad filename=remix.config.js lines=[3]
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  devServerPort: 8002,
};
```

```js filename=remix.config.js good lines=[3-7]
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  // While on v1.x, this is via a future flag
  future: {
    v2_dev: {
      port: 8002,
    },
  },
};
```

Once you upgrade from v1 to v2, this flattens to a [root-level `dev` config][dev-after-upgrading].

## `serverBuildDirectory`

In your `remix.config.js`, rename `serverBuildDirectory` to `serverBuildPath` and specify a module path, not a directory.

```js bad filename=remix.config.js lines=[3]
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  serverBuildDirectory: './build',
};
```

```js filename=remix.config.js good lines=[3]
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  serverBuildPath: './build/index.js',
};
```

Remix used to create more than a single module for the server, but it now creates a single file.

## `serverBuildTarget`

Instead of specifying a build target, use the [`remix.config.js`][remix_config] options to generate the server build your server target expects. This change allows Remix to deploy to more JavaScript runtimes, servers, and hosts without Remix source code needing to know about them.

The following configurations should replace your current `serverBuildTarget`:

#### `arc`

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  publicPath: '/_static/build/',
  serverBuildPath: 'server/index.js',
  serverMainFields: ['main', 'module'], // default value, can be removed
  serverMinify: false, // default value, can be removed
  serverModuleFormat: 'cjs', // default value in 1.x, add before upgrading
  serverPlatform: 'node', // default value, can be removed
};
```

#### `cloudflare-pages`

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  publicPath: '/build/', // default value, can be removed
  serverBuildPath: 'functions/[[path]].js',
  serverConditions: ['worker'],
  serverDependenciesToBundle: 'all',
  serverMainFields: ['browser', 'module', 'main'],
  serverMinify: true,
  serverModuleFormat: 'esm', // default value in 2.x, can be removed once upgraded
  serverPlatform: 'neutral',
};
```

#### `cloudflare-workers`

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  publicPath: '/build/', // default value, can be removed
  serverBuildPath: 'build/index.js', // default value, can be removed
  serverConditions: ['worker'],
  serverDependenciesToBundle: 'all',
  serverMainFields: ['browser', 'module', 'main'],
  serverMinify: true,
  serverModuleFormat: 'esm', // default value in 2.x, can be removed once upgraded
  serverPlatform: 'neutral',
};
```

#### `deno`

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  publicPath: '/build/', // default value, can be removed
  serverBuildPath: 'build/index.js', // default value, can be removed
  serverConditions: ['deno', 'worker'],
  serverDependenciesToBundle: 'all',
  serverMainFields: ['module', 'main'],
  serverMinify: false, // default value, can be removed
  serverModuleFormat: 'esm', // default value in 2.x, can be removed once upgraded
  serverPlatform: 'neutral',
};
```

#### `node-cjs`

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  publicPath: '/build/', // default value, can be removed
  serverBuildPath: 'build/index.js', // default value, can be removed
  serverMainFields: ['main', 'module'], // default value, can be removed
  serverMinify: false, // default value, can be removed
  serverModuleFormat: 'cjs', // default value in 1.x, add before upgrading
  serverPlatform: 'node', // default value, can be removed
};
```

## `serverModuleFormat`

The default server module output format has changed from `cjs` to `esm`. You can continue to use CJS in v2, many dependencies in your app might not be compatible with ESM.

In your `remix.config.js`, you should specify either `serverModuleFormat: "cjs"` to retain existing behavior, or `serverModuleFormat: "esm"`, to opt into the new behavior.

## `browserNodeBuiltinsPolyfill`

Polyfills for Node.js built-in modules are no longer provided by default for the browser. In Remix v2 you'll need to explicitly reintroduce any polyfills (or blank polyfills) as required:

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  browserNodeBuiltinsPolyfill: {
    modules: {
      buffer: true,
      fs: 'empty',
    },
    globals: {
      Buffer: true,
    },
  },
};
```

Even though we recommend being explicit about which polyfills are allowed in your browser bundle, especially since some polyfills can be quite large, you can quickly reinstate the full set of polyfills from Remix v1 with the following configuration:

```js filename=remix.config.js
const { builtinModules } = require('node:module');

/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  browserNodeBuiltinsPolyfill: {
    modules: builtinModules,
  },
};
```

## `serverNodeBuiltinsPolyfill`

Polyfills for Node.js built-in modules are no longer be provided by default for non-Node.js server platforms.

If you are targeting a non-Node.js server platform and want to opt into the new default behavior in v1, in `remix.config.js` you should first remove all server polyfills by explicitly providing an empty object for `serverNodeBuiltinsPolyfill.modules`:

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  serverNodeBuiltinsPolyfill: {
    modules: {},
  },
};
```

You can then reintroduce any polyfills (or blank polyfills) as required.

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  serverNodeBuiltinsPolyfill: {
    modules: {
      buffer: true,
      fs: 'empty',
    },
    globals: {
      Buffer: true,
    },
  },
};
```

For reference, the complete set of default polyfills from v1 can be manually specified as follows:

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  serverNodeBuiltinsPolyfill: {
    modules: {
      _stream_duplex: true,
      _stream_passthrough: true,
      _stream_readable: true,
      _stream_transform: true,
      _stream_writable: true,
      assert: true,
      'assert/strict': true,
      buffer: true,
      console: true,
      constants: true,
      crypto: 'empty',
      diagnostics_channel: true,
      domain: true,
      events: true,
      fs: 'empty',
      'fs/promises': 'empty',
      http: true,
      https: true,
      module: true,
      os: true,
      path: true,
      'path/posix': true,
      'path/win32': true,
      perf_hooks: true,
      process: true,
      punycode: true,
      querystring: true,
      stream: true,
      'stream/promises': true,
      'stream/web': true,
      string_decoder: true,
      sys: true,
      timers: true,
      'timers/promises': true,
      tty: true,
      url: true,
      util: true,
      'util/types': true,
      vm: true,
      wasi: true,
      worker_threads: true,
      zlib: true,
    },
  },
};
```

## `installGlobals`

For preparation of using Node's built in fetch implementation, installing the fetch globals is now a responsibility of the app server. If you are using `remix-serve`, nothing is required. If you are using your own app server, you will need to install the globals yourself.

```ts filename=server.ts
import { installGlobals } from '@remix-run/node';

installGlobals();
```

### Removal of exported polyfills

Remix v2 also no longer exports these polyfilled implementations from `@remix-run/node`, and instead you should just use the instances in the global namespace. One place this is likely to surface and require a change is your `app/entry.server.tsx` file, where you'll also need to convert the Node [`PassThrough`][pass_through_class] into a web [`ReadableStream`][readable_stream] via `createReadableStreamFromReadable`:

```diff filename=app/entry.server.tsx
  import { PassThrough } from "node:stream";
  import type { AppLoadContext, EntryContext } from "@remix-run/node"; // or cloudflare/deno
- import { Response } from "@remix-run/node"; // or cloudflare/deno
+ import { createReadableStreamFromReadable } from "@remix-run/node"; // or cloudflare/deno
  import { RemixServer } from "@remix-run/react";
  import { isbot } from "isbot";
  import { renderToPipeableStream } from "react-dom/server";

  const ABORT_DELAY = 5_000;

  export default function handleRequest({ /* ... */ }) { ... }

  function handleBotRequest(...) {
    return new Promise((resolve, reject) => {
      let shellRendered = false;
      const { pipe, abort } = renderToPipeableStream(
        <RemixServer ... />,
        {
          onAllReady() {
            shellRendered = true;
            const body = new PassThrough();

            responseHeaders.set("Content-Type", "text/html");

            resolve(
-             new Response(body, {
+             new Response(createReadableStreamFromReadable(body), {
                headers: responseHeaders,
                status: responseStatusCode,
              })
            );

            pipe(body);
          },
          ...
          onShellError(error: unknown) { ... }
          onError(error: unknown) { ... }
        }
      );

      setTimeout(abort, ABORT_DELAY);
    });
  }

  function handleBrowserRequest(...) {
    return new Promise((resolve, reject) => {
      let shellRendered = false;
      const { pipe, abort } = renderToPipeableStream(
        <RemixServer ... />,
        {
          onShellReady() {
            shellRendered = true;
            const body = new PassThrough();

            responseHeaders.set("Content-Type", "text/html");

            resolve(
-              new Response(body, {
+              new Response(createReadableStreamFromReadable(body), {
                headers: responseHeaders,
                status: responseStatusCode,
              })
            );

            pipe(body);
          },
          onShellError(error: unknown) { ... },
          onError(error: unknown) { ... },
        }
      );

      setTimeout(abort, ABORT_DELAY);
    });
  }
```

## `source-map-support`

Source map support is now a responsibility of the app server. If you are using `remix-serve`, nothing is required. If you are using your own app server, you will need to install [`source-map-support`][source-map-support] yourself.

```shellscript nonumber
npm i source-map-support
```

```ts filename=server.ts
import sourceMapSupport from 'source-map-support';

sourceMapSupport.install();
```

## Netlify adapter

The `@remix-run/netlify` runtime adapter has been deprecated in favor of
[`@netlify/remix-adapter`][official-netlify-adapter] & [`@netlify/remix-edge-adapter`][official-netlify-edge-adapter]
and is now removed as of Remix v2. Please update your code by changing all `@remix-run/netlify` imports to
`@netlify/remix-adapter`.\
Keep in mind that `@netlify/remix-adapter` requires `@netlify/functions@^1.0.0`, which is a breaking change compared
to the current supported `@netlify/functions` versions in `@remix-run/netlify`.

Due to the removal of this adapter, we also removed our [Netlify template][netlify-template] in favor of the
[official Netlify template][official-netlify-template].

## Vercel adapter

The `@remix-run/vercel` runtime adapter has been deprecated in favor of out of the box Vercel functionality and is now
removed as of Remix v2. Please update your code by removing `@remix-run/vercel` & `@vercel/node` from your
`package.json`, removing your `server.js`/`server.ts` file, and removing the `server` & `serverBuildPath` options
from your `remix.config.js`.

Due to the removal of this adapter, we also removed our [Vercel template][vercel-template] in favor of the
[official Vercel template][official-vercel-template].

## Built-in PostCSS/Tailwind support

In v2, these tools are automatically used within the Remix compiler if PostCSS and/or Tailwind configuration files are present in your project.

If you have a custom PostCSS and/or Tailwind setup outside of Remix that you'd like to maintain when migrating to v2, you can disable these features in your `remix.config.js`.

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  postcss: false,
  tailwind: false,
};
```

## Troubleshooting

### ESM / CommonJS Errors

```sh
"SyntaxError: Named export '<something>' not found. The requested module '<something>' is a CommonJS module, which may not support all module.exports as named exports."
```

Please see the [`serverModuleFormat`][server-module-format] section.

[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ../guides/vite
[future-flags]: ./future-flags
[remix_config]: ../file-conventions/remix-config
[pass_through_class]: https://nodejs.org/api/stream.html#class-streampassthrough
[readable_stream]: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
[flat-routes]: https://github.com/remix-run/remix/discussions/4482
[meta]: ../route/meta
[meta-v2-rfc]: https://github.com/remix-run/remix/discussions/4462
[meta-v2-matches]: #the-matches-argument
[templates]: https://github.com/remix-run/remix/tree/main/templates
[dev-docs]: ../other-api/dev
[manual-mode]: ../guides/manual-mode
[source-map-support]: https://npm.im/source-map-support
[official-netlify-adapter]: https://github.com/netlify/remix-compute/tree/main/packages/remix-adapter
[official-netlify-edge-adapter]: https://github.com/netlify/remix-compute/tree/main/packages/remix-edge-adapter
[netlify-template]: https://github.com/remix-run/remix/tree/main/templates/netlify
[official-netlify-template]: https://github.com/netlify/remix-template
[vercel-template]: https://github.com/remix-run/remix/tree/main/templates/vercel
[official-vercel-template]: https://github.com/vercel/vercel/tree/main/examples/remix
[troubleshooting]: #troubleshooting
[server-module-format]: #servermoduleformat
[2-min-to-v2]: https://twitter.com/BrooksLybrand/status/1704265835546578989
[dev-after-upgrading]: #after-upgrading-from-v1-to-v2

---

## File: ./styling/bundling.md

---

## title: CSS Bundling

# CSS Bundling

<docs-warning>This documentation is only relevant when using the [Classic Remix Compiler][classic-remix-compiler]. If you're using [Remix Vite][remix-vite], you should refer to [Vite's CSS documentation][vite-css] instead.</docs-warning>

Some CSS features in Remix bundle styles into a single file that you load manually into the application including:

- [CSS Side Effect Imports][css-side-effect-imports]
- [CSS Modules][css-modules]
- [Vanilla Extract][vanilla-extract]

Note that any [regular stylesheet imports][regular-stylesheet-imports] will remain as separate files.

## Usage

Remix does not insert the CSS bundle into the page automatically so that you have control over the link tags on your page.

To get access to the CSS bundle, first install the `@remix-run/css-bundle` package.

```shellscript nonumber
npm install @remix-run/css-bundle
```

Then, import `cssBundleHref` and add it to a link descriptor‚Äîmost likely in `app/root.tsx` so that it applies to your entire application.

```tsx filename=app/root.tsx
import { cssBundleHref } from '@remix-run/css-bundle';
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

export const links: LinksFunction = () => [
  ...(cssBundleHref ? [{ rel: 'stylesheet', href: cssBundleHref }] : []),
  // ...
];
```

With this link tag inserted into the page, you're now ready to start using the various CSS bundling features built into Remix.

## Limitations

Avoid using `export *` due to an [issue with `esbuild`'s CSS tree shaking][esbuild-css-tree-shaking-issue].

[esbuild-css-tree-shaking-issue]: https://github.com/evanw/esbuild/issues/1370
[css-side-effect-imports]: ./css-imports
[css-modules]: ./css-modules
[vanilla-extract]: ./vanilla-extract
[regular-stylesheet-imports]: ./css
[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ../guides/vite
[vite-css]: https://vitejs.dev/guide/features#css

---

## File: ./styling/css.md

---

## title: Regular CSS

# Regular CSS

Remix helps you scale an app with regular CSS with nested routes and [`links`][links].

CSS Maintenance issues can creep into a web app for a few reasons. It can get difficult to know:

- how and when to load CSS, so it was usually all loaded on every page
- if the class names and selectors you were using were accidentally styling other UI in the app
- if some rules weren't even used anymore as the CSS source code grew over time

Remix alleviates these issues with route-based stylesheets. Nested routes can each add their own stylesheets to the page and Remix will automatically prefetch, load, and unload them with the route. When the scope of concern is limited to just the active routes, the risks of these problems are reduced significantly. The only chances for conflicts are with the parent routes' styles (and even then, you will likely see the conflict since the parent route is also rendering).

<docs-warning>If you're using the [Classic Remix Compiler][classic-remix-compiler] rather than [Remix Vite][remix-vite], you should remove `?url` from the end of your CSS import paths.</docs-warning>

### Route Styles

Each route can add style links to the page, for example:

```tsx filename=app/routes/dashboard.tsx
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

import styles from '@/styles/dashboard.css?url';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: styles }];
```

```tsx filename=app/routes/dashboard.accounts.tsx
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

import styles from '@/styles/accounts.css?url';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: styles }];
```

```tsx filename=app/routes/dashboard.sales.tsx
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

import styles from '@/styles/sales.css?url';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: styles }];
```

Given these routes, this table shows which CSS will apply at specific URLs:

| URL                 | Stylesheets                    |
| ------------------- | ------------------------------ |
| /dashboard          | dashboard.css                  |
| /dashboard/accounts | dashboard.css<br/>accounts.css |
| /dashboard/sales    | dashboard.css<br/>sales.css    |

It's subtle, but this little feature removes a lot of the difficulty when styling your app with plain stylesheets.

### Shared Component Styles

Websites large and small usually have a set of shared components used throughout the rest of the app: buttons, form elements, layouts, etc. When using plain style sheets in Remix there are two approaches we recommend.

#### Shared stylesheet

The first approach is very simple. Put them all in a `shared.css` file included in `app/root.tsx`. That makes it easy for the components themselves to share CSS code (and your editor to provide intellisense for things like [custom properties][custom-properties]), and each component already needs a unique module name in JavaScript anyway, so you can scope the styles to a unique class name or data attribute:

```css filename=app/styles/shared.css
/* scope with class names */
.PrimaryButton {
  /* ... */
}

.TileGrid {
  /* ... */
}

/* or scope with data attributes to avoid concatenating
   className props, but it's really up to you */
[data-primary-button] {
  /* ... */
}

[data-tile-grid] {
  /* ... */
}
```

While this file may become large, it'll be at a single URL that will be shared by all routes in the app.

This also makes it easy for routes to adjust the styles of a component without needing to add an official new variant to the API of that component. You know it won't affect the component anywhere but the `/accounts` routes.

```css filename=app/styles/accounts.css
.PrimaryButton {
  background: blue;
}
```

#### Surfacing Styles

A second approach is to write individual css files per component and then "surface" the styles up to the routes that use them.

Perhaps you have a `<Button>` in `app/components/button/index.tsx` with styles at `app/components/button/styles.css` as well as a `<PrimaryButton>` that extends it.

Note that these are not routes, but they export `links` functions as if they were. We'll use this to surface their styles to the routes that use them.

```css filename=app/components/button/styles.css
[data-button] {
  border: solid 1px;
  background: white;
  color: #454545;
}
```

```tsx filename=app/components/button/index.tsx lines=[1,3,5-7]
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

import styles from './styles.css?url';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: styles }];

export const Button = React.forwardRef(({ children, ...props }, ref) => {
  return <button {...props} ref={ref} data-button />;
});
Button.displayName = 'Button';
```

And then a `<PrimaryButton>` that extends it:

```css filename=app/components/primary-button/styles.css
[data-primary-button] {
  background: blue;
  color: white;
}
```

```tsx filename=app/components/primary-button/index.tsx lines=[3,8,15]
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

import { Button, links as buttonLinks } from '../button';

import styles from './styles.css?url';

export const links: LinksFunction = () => [...buttonLinks(), { rel: 'stylesheet', href: styles }];

export const PrimaryButton = React.forwardRef(({ children, ...props }, ref) => {
  return <Button {...props} ref={ref} data-primary-button />;
});
PrimaryButton.displayName = 'PrimaryButton';
```

Note that the primary button's `links` include the base button's links. This way consumers of `<PrimaryButton>` don't need to know its dependencies (just like JavaScript imports).

Because these buttons are not routes, and therefore not associated with a URL segment, Remix doesn't know when to prefetch, load, or unload the styles. We need to "surface" the links up to the routes that use the components.

Consider that `app/routes/_index.tsx` uses the primary button component:

```tsx filename=app/routes/_index.tsx lines=[3-6,10]
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

import { PrimaryButton, links as primaryButtonLinks } from '@/components/primary-button';
import styles from '@/styles/index.css?url';

export const links: LinksFunction = () => [
  ...primaryButtonLinks(),
  { rel: 'stylesheet', href: styles },
];
```

Now Remix can prefetch, load, and unload the styles for `button.css`, `primary-button.css`, and the route's `index.css`.

An initial reaction to this is that routes have to know more than you want them to. Keep in mind that each component must be imported already, so it's not introducing a new dependency, just some boilerplate to get the assets. For example, consider a product category page like this:

```tsx filename=app/routes/$category.tsx lines=[3-7]
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

import { AddFavoriteButton } from '@/components/add-favorite-button';
import { ProductDetails } from '@/components/product-details';
import { ProductTile } from '@/components/product-tile';
import { TileGrid } from '@/components/tile-grid';
import styles from '@/styles/$category.css?url';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: styles }];

export default function Category() {
  const products = useLoaderData<typeof loader>();
  return (
    <TileGrid>
      {products.map((product) => (
        <ProductTile key={product.id}>
          <ProductDetails product={product} />
          <AddFavoriteButton id={product.id} />
        </ProductTile>
      ))}
    </TileGrid>
  );
}
```

The component imports are already there, we just need to surface the assets:

```tsx filename=app/routes/$category.tsx
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

import { AddFavoriteButton, links as addFavoriteLinks } from '@/components/add-favorite-button';
import { ProductDetails, links as productDetailsLinks } from '@/components/product-details';
import { ProductTile, links as productTileLinks } from '@/components/product-tile';
import { TileGrid, links as tileGridLinks } from '@/components/tile-grid';
import styles from '@/styles/$category.css?url';

export const links: LinksFunction = () => {
  return [
    ...tileGridLinks(),
    ...productTileLinks(),
    ...productDetailsLinks(),
    ...addFavoriteLinks(),
    { rel: 'stylesheet', href: styles },
  ];
};

// ...
```

While that's a bit of boilerplate it enables a lot:

- You control your network tab, and CSS dependencies are clear in the code
- Co-located styles with your components
- The only CSS ever loaded is the CSS that's used on the current page
- When your components aren't used by a route, their CSS is unloaded from the page
- Remix will prefetch the CSS for the next page with [`<Link prefetch>`][link]
- When one component's styles change, browser and CDN caches for the other components won't break because they all have their own URLs.
- When a component's JavaScript changes but its styles don't, the cache is not broken for the styles

#### Asset Preloads

Since these are just `<link>` tags, you can do more than stylesheet links, like adding asset preloads for SVG icon backgrounds of your elements:

```css filename=app/components/copy-to-clipboard.css
[data-copy-to-clipboard] {
  background: url('/icons/clipboard.svg');
}
```

```tsx filename=app/components/copy-to-clipboard.tsx lines=[6-11]
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

import styles from './styles.css?url';

export const links: LinksFunction = () => [
  {
    rel: 'preload',
    href: '/icons/clipboard.svg',
    as: 'image',
    type: 'image/svg+xml',
  },
  { rel: 'stylesheet', href: styles },
];

export const CopyToClipboard = React.forwardRef(({ children, ...props }, ref) => {
  return <Button {...props} ref={ref} data-copy-to-clipboard />;
});
CopyToClipboard.displayName = 'CopyToClipboard';
```

Not only will this make the asset high priority in the network tab, but Remix will turn that `preload` into a `prefetch` when you link to the page with [`<Link prefetch>`][link], so the SVG background is prefetched, in parallel, with the next route's data, modules, stylesheets, and any other preloads.

### Link Media Queries

Using plain stylesheets and `<link>` tags also opens up the ability to decrease the amount of CSS your user's browser has to process when it paints the screen. Link tags support `media`, so you can do the following:

```tsx lines=[10,15,20]
export const links: LinksFunction = () => {
  return [
    {
      rel: 'stylesheet',
      href: mainStyles,
    },
    {
      rel: 'stylesheet',
      href: largeStyles,
      media: '(min-width: 1024px)',
    },
    {
      rel: 'stylesheet',
      href: xlStyles,
      media: '(min-width: 1280px)',
    },
    {
      rel: 'stylesheet',
      href: darkStyles,
      media: '(prefers-color-scheme: dark)',
    },
  ];
};
```

[links]: ../route/links
[custom-properties]: https://developer.mozilla.org/en-US/docs/Web/CSS/--*
[link]: ../components/link
[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ../guides/vite

---

## File: ./styling/css-imports.md

---

## title: CSS Imports

# CSS Side Effect Imports

<docs-warning>This documentation is no longer relevant when using [Remix Vite][remix-vite]. CSS side effect imports work out of the box in Vite.</docs-warning>

Some NPM packages use side effect imports of plain CSS files (e.g. `import "./styles.css"`) to declare the CSS dependencies of JavaScript files. If you want to consume one of these packages, first ensure you've set up [CSS bundling][css-bundling] in your application.

For example, a module may have source code like this:

```tsx
import './menu-button.css';

export function MenuButton() {
  return <button data-menu-button>{/* ... */}</button>;
}
```

Since JavaScript runtimes don't support importing CSS in this way, you'll need to add any relevant packages to the [`serverDependenciesToBundle`][server-dependencies-to-bundle] option in your `remix.config.js` file. This ensures that any CSS imports are compiled out of your code before running it on the server. For example, to use React Spectrum:

```js filename=remix.config.js
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  serverDependenciesToBundle: [/^@adobe\/react-spectrum/, /^@react-spectrum/, /^@spectrum-icons/],
  // ...
};
```

[css-bundling]: ./bundling
[server-dependencies-to-bundle]: ../file-conventions/remix-config#serverdependenciestobundle
[remix-vite]: ../guides/vite

---

## File: ./styling/css-in-js.md

---

## title: CSS in JS

# CSS in JS libraries

You can use CSS-in-JS libraries like Styled Components and Emotion. Some of them require a "double render" in order to extract the styles from the component tree during the server render.

Since each library is integrated differently, check out our [examples repo][examples] to see how to use some of the most popular CSS-in-JS libraries. If you've got a library working well that hasn't been covered, please [contribute an example][examples]!

<docs-warning>
Most CSS-in-JS approaches aren't recommended for use in Remix because they require your app to render completely before you know what the styles are. This is a performance issue and prevents streaming features like defer.
</docs-warning>

[examples]: https://github.com/remix-run/examples

---

## File: ./styling/css-modules.md

---

## title: CSS Modules

# CSS Modules

<docs-warning>This documentation is only relevant when using the [Classic Remix Compiler][classic-remix-compiler]. If you're using [Remix Vite][remix-vite], support for [CSS Modules is built into Vite][vite-css-modules].</docs-warning>

To use the built-in CSS Modules support, first ensure you've set up [CSS bundling][css-bundling] in your application.

You can then opt into [CSS Modules][css-modules] via the `.module.css` file name convention. For example:

```css filename=app/components/button/styles.module.css
.root {
  border: solid 1px;
  background: white;
  color: #454545;
}
```

```tsx filename=app/components/button/index.js lines=[1,9]
import styles from './styles.module.css';

export const Button = React.forwardRef(({ children, ...props }, ref) => {
  return <button {...props} ref={ref} className={styles.root} />;
});
Button.displayName = 'Button';
```

[css-bundling]: ./bundling
[css-modules]: https://github.com/css-modules/css-modules
[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ../guides/vite
[vite-css-modules]: https://vitejs.dev/guide/features#css-modules

---

## File: ./styling/index.md

---

title: Styling
order: 7

---

---

## File: ./styling/postcss.md

---

## title: PostCSS

# PostCSS

<docs-warning>This documentation is only relevant when using the [Classic Remix Compiler][classic-remix-compiler]. If you're using [Remix Vite][remix-vite], support for [PostCSS is built into Vite][vite-postcss].</docs-warning>

[PostCSS][postcss] is a popular tool with a rich plugin ecosystem, commonly used to prefix CSS for older browsers, transpile future CSS syntax, inline images, lint your styles and more. When a PostCSS config is detected, Remix will automatically run PostCSS across all CSS in your project.

For example, to use [Autoprefixer][autoprefixer], first install the PostCSS plugin.

```shellscript nonumber
npm install -D autoprefixer
```

Then add a PostCSS config file in the Remix root referencing the plugin.

```js filename=postcss.config.cjs
module.exports = {
  plugins: {
    autoprefixer: {},
  },
};
```

If you're using [Vanilla Extract][vanilla-extract], since it's already playing the role of CSS preprocessor, you may want to apply a different set of PostCSS plugins relative to other styles. To support this, you can export a function from your PostCSS config file which is given a context object that lets you know when Remix is processing a Vanilla Extract file.

```js filename=postcss.config.cjs
module.exports = (ctx) => {
  return ctx.remix?.vanillaExtract
    ? {
        // PostCSS plugins for Vanilla Extract styles...
      }
    : {
        // PostCSS plugins for other styles...
      };
};
```

<docs-info>Built-in PostCSS support can be disabled by setting the `postcss` option to `false` in `remix.config.js`.</docs-info>

## CSS Preprocessors

You can use CSS preprocessors like LESS and SASS. Doing so requires running an additional build process to convert these files to CSS files. This can be done via the command line tools provided by the preprocessor or any equivalent tool.

Once converted to CSS by the preprocessor, the generated CSS files can be imported into your components via the [Route Module `links` export][route-module-links] function, or included via [side effect imports][css-side-effect-imports] when using [CSS bundling][css-bundling], just like any other CSS file in Remix.

To ease development with CSS preprocessors you can add npm scripts to your `package.json` that generate CSS files from your SASS or LESS files. These scripts can be run in parallel alongside any other npm scripts that you run for developing a Remix application.

An example using SASS.

1. First you'll need to install the tool your preprocess uses to generate CSS files.

   ```shellscript nonumber
   npm add -D sass
   ```

2. Add an npm script to your `package.json`'s `scripts` section that uses the installed tool to generate CSS files.

   ```jsonc filename=package.json
   {
     // ...
     "scripts": {
       // ...
       "sass": "sass --watch app/:app/",
     },
     // ...
   }
   ```

   The above example assumes SASS files will be stored somewhere in the `app` folder.

   The `--watch` flag included above will keep `sass` running as an active process, listening for changes to or for any new SASS files. When changes are made to the source file, `sass` will regenerate the CSS file automatically. Generated CSS files will be stored in the same location as their source files.

3. Run the npm script.

   ```shellscript nonumber
   npm run sass
   ```

   This will start the `sass` process. Any new SASS files, or changes to existing SASS files, will be detected by the running process.

   You might want to use something like `concurrently` to avoid needing two terminal tabs to generate your CSS files and also run `remix dev`.

   ```shellscript nonumber
   npm add -D concurrently
   ```

   ```json filename=package.json
   {
     "scripts": {
       "dev": "concurrently \"npm run sass\" \"remix dev\""
     }
   }
   ```

   Running `npm run dev` will run the specified commands in parallel in a single terminal window.

[postcss]: https://postcss.org
[autoprefixer]: https://github.com/postcss/autoprefixer
[vanilla-extract]: ./vanilla-extract
[route-module-links]: ../route/links
[css-side-effect-imports]: ./css-imports
[css-bundling]: ./bundling
[postcss-preset-env]: https://preset-env.cssdb.org
[esbuild-css-tree-shaking-issue]: https://github.com/evanw/esbuild/issues/1370
[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ../guides/vite
[vite-postcss]: https://vitejs.dev/guide/features#postcss

---

## File: ./styling/tailwind.md

---

## title: Tailwind

# Tailwind

<docs-warning>This documentation is only relevant when using the [Classic Remix Compiler][classic-remix-compiler]. If you're using [Remix Vite][remix-vite], Tailwind can be integrated using [Vite's built-in PostCSS support][vite-postcss].</docs-warning>

Perhaps the most popular way to style a Remix application in the community is to use [Tailwind CSS][tailwind].

Remix supports Tailwind automatically if `tailwind.config.js` is present in the root of your project. You can disable it in [Remix Config][remix_config]

Tailwind has the benefits of inline-style co-location for developer ergonomics and is able to generate a CSS file for Remix to import. The generated CSS file generally caps out to a reasonable size, even for large applications. Load that file into the `app/root.tsx` links and be done with it.

If you don't have any CSS opinions, this is a great approach.

To use Tailwind, first install it as a dev dependency:

```shellscript nonumber
npm install -D tailwindcss
```

Then initialize a config file:

```shellscript nonumber
npx tailwindcss init --ts
```

Now we can tell it which files to generate classes from:

```ts filename=tailwind.config.ts lines=[4]
import type { Config } from 'tailwindcss';

export default {
  content: ['./app/**/{**,.client,.server}/**/*.{js,jsx,ts,tsx}'],
  theme: {
    extend: {},
  },
  plugins: [],
} satisfies Config;
```

Then include the `@tailwind` directives in your CSS. For example, you could create a `tailwind.css` file at the root of your app:

```css filename=app/tailwind.css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

Then add `tailwind.css` to your root route's `links` function:

```tsx filename=app/root.tsx
import type { LinksFunction } from '@remix-run/node'; // or cloudflare/deno

// ...

import styles from './tailwind.css?url';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: styles }];
```

With this setup in place, you can also use [Tailwind's functions and directives][tailwind-functions-and-directives] anywhere in your CSS. Note that Tailwind will warn that no utility classes were detected in your source files if you never used it before.

Tailwind doesn't compile CSS for older browsers by default, so if you'd like to achieve this using a PostCSS-based tool like [Autoprefixer][autoprefixer], you'll need to leverage Remix's [built-in PostCSS support][built-in-post-css-support]. When using both PostCSS and Tailwind, the Tailwind plugin will be automatically included if it's missing, but you can also choose to manually include the Tailwind plugin in your PostCSS config instead if you prefer.

If you're using VS Code, it's recommended you install the [Tailwind IntelliSense extension][tailwind-intelli-sense-extension] for the best developer experience.

## Avoiding Tailwind's `@import` syntax

It's recommended that you avoid Tailwind's `@import` syntax (e.g. `@import 'tailwindcss/base'`) in favor of Tailwind directives (e.g. `@tailwind base`).

Tailwind replaces its import statements with inlined CSS but this can result in the interleaving of styles and import statements. This clashes with the restriction that all import statements must be at the start of the file.

Alternatively, you can use [PostCSS][built-in-post-css-support] with the [postcss-import] plugin to process imports before passing them to esbuild.

[tailwind]: https://tailwindcss.com
[remix_config]: ../file-conventions/remix-config#tailwind
[tailwind-functions-and-directives]: https://tailwindcss.com/docs/functions-and-directives
[autoprefixer]: https://github.com/postcss/autoprefixer
[built-in-post-css-support]: ./postcss
[tailwind-intelli-sense-extension]: https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss
[postcss-import]: https://github.com/postcss/postcss-import
[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ../guides/vite
[vite-postcss]: https://vitejs.dev/guide/features#postcss

---

## File: ./styling/vanilla-extract.md

---

## title: Vanilla Extract

# Vanilla Extract

<docs-warning>This documentation is only relevant when using the [Classic Remix Compiler][classic-remix-compiler]. If you're using [Remix Vite][remix-vite], Vanilla Extract can be integrated using the [Vanilla Extract Vite plugin][vanilla-extract-vite].</docs-warning>

[Vanilla Extract][vanilla-extract] is a zero-runtime CSS-in-TypeScript (or JavaScript) library that lets you use TypeScript as your CSS preprocessor. Styles are written in separate `*.css.ts` (or `*.css.js`) files and all code within them is executed during the build process rather than in your user's browser. If you want to keep your CSS bundle size to a minimum, Vanilla Extract also provides an official library called [Sprinkles][sprinkles] that lets you define a custom set of utility classes and a type-safe function for accessing them at runtime.

To use the built-in Vanilla Extract support, first ensure you've set up [CSS bundling][css-bundling] in your application.

Then, install Vanilla Extract's core styling package as a dev dependency.

```shellscript nonumber
npm install -D @vanilla-extract/css
```

You can then opt into Vanilla Extract via the `.css.ts`/`.css.js` file name convention. For example:

```ts filename=app/components/button/styles.css.ts
import { style } from '@vanilla-extract/css';

export const root = style({
  border: 'solid 1px',
  background: 'white',
  color: '#454545',
});
```

```tsx filename=app/components/button/index.js lines=[1,9]
import * as styles from './styles.css'; // Note that `.ts` is omitted here

export const Button = React.forwardRef(({ children, ...props }, ref) => {
  return <button {...props} ref={ref} className={styles.root} />;
});
Button.displayName = 'Button';
```

[vanilla-extract]: https://vanilla-extract.style
[sprinkles]: https://vanilla-extract.style/documentation/packages/sprinkles
[css-bundling]: ./bundling
[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ../guides/vite
[vanilla-extract-vite]: https://vanilla-extract.style/documentation/integrations/vite

---

## File: ./tutorials/blog.md

---

title: Blog Tutorial (short)
order: 3
hidden: true

---

# Blog Tutorial

We're going to be short on words and quick on code in this quickstart. If you're looking to see what Remix is all about in 15 minutes, this is it.

<docs-info>Work through this tutorial with Kent in <a target="_blank" rel="noopener noreferrer" href="https://rmx.as/egghead-course">this free Egghead.io course</a></docs-info>

This tutorial uses TypeScript. Remix can definitely be used without TypeScript. We feel most productive when writing TypeScript, but if you'd prefer to skip the TypeScript syntax, feel free to write your code in JavaScript.

<docs-info>üíø Hey I'm Derrick the Remix Compact Disc üëã Whenever you're supposed to _do_ something you'll see me</docs-info>

## Prerequisites

Click this button to create a [Gitpod][gitpod] workspace with the project set up and ready to run in VS Code or JetBrains either directly in the browser or on the desktop.

[![Gitpod Ready-to-Code][gitpod-ready-to-code]][gitpod-ready-to-code-image]

If you want to follow this tutorial locally on your own computer, it is important for you to have these things installed:

- [Node.js][node-js] version (>=18.0.0)
- [npm][npm] 7 or greater
- A code editor ([VSCode][vs-code] is a nice one)

## Creating the project

<docs-warning>Make sure you are running at least Node v18 or greater</docs-warning>

üíø Initialize a new Remix project. We'll call ours "blog-tutorial" but you can call it something else if you'd like.

```shellscript nonumber
npx create-remix@latest --template remix-run/indie-stack blog-tutorial
```

```
Install dependencies with npm?
Yes
```

You can read more about the stacks available in [the stacks docs][the-stacks-docs].

We're using [the Indie stack][the-indie-stack], which is a full application ready to deploy to [fly.io][fly-io]. This includes development tools as well as production-ready authentication and persistence. Don't worry if you're unfamiliar with the tools used, we'll walk you through things as we go.

<docs-info>Note, you can definitely start with "Just the basics" instead by running `npx create-remix@latest` without the `--template` flag. The generated project is much more minimal that way. However, some bits of the tutorial will be different for you and you'll have to configure things for deployment manually.</docs-info>

üíø Now, open the project that was generated in your preferred editor and check the instructions in the `README.md` file. Feel free to read over this. We'll get to the deployment bit later in the tutorial.

üíø Let's start the dev server:

```shellscript nonumber
npm run dev
```

üíø Open up [http://localhost:3000][http-localhost-3000], the app should be running.

If you want, take a minute and poke around the UI a bit. Feel free to create an account and create/delete some notes to get an idea of what's available in the UI out of the box.

## Your First Route

We're going to make a new route to render at the "/posts" URL. Before we do that, let's link to it.

üíø Add a link to posts in `app/routes/_index.tsx`

Go ahead and copy/paste this:

```tsx filename=app/routes/_index.tsx
<div className="mx-auto mt-16 max-w-7xl text-center">
  <Link to="/posts" className="text-xl text-blue-600 underline">
    Blog Posts
  </Link>
</div>
```

You can put it anywhere you like. I stuck it right above the icons of all the technologies used in the stack:

<!-- TODO: once the website can deploy properly, update this to use our self-hosted version of this image -->

<!-- ![Screenshot of the app showing the blog post link](/blog-tutorial/blog-post-link.png) -->

![Screenshot of the app showing the blog post link][screenshot-of-the-app-showing-the-blog-post-link]

<docs-info>You may have noticed we're using <a href="https://tailwindcss.com">Tailwind CSS</a> classes.</docs-info>

The Remix Indie stack has [Tailwind CSS][tailwind] support pre-configured. If you'd prefer to not use Tailwind CSS, you're welcome to remove it and use something else. Learn more about your styling options with Remix in [the styling guide][the-styling-guide].

Back in the browser go ahead and click the link. You should see a 404 page since we've not created this route yet. Let's create the route now:

üíø Create a new file at `app/routes/posts._index.tsx`

```shellscript nonumber
touch app/routes/posts._index.tsx
```

<docs-info>Any time you see terminal commands to create files or folders, you can of course do that however you'd like, but using `touch` is just a way for us to make it clear which files you should be creating.</docs-info>

We could have named it just `posts.tsx` but we'll have another route soon, and it'll be nice to put them by each other. An index route will render at the parent's path (just like `index.html` on a web server).

Now if you navigate to the `/posts` route, you'll get an error indicating there's no way to handle the request. That's because we haven't done anything in that route yet! Let's add a component and export it as the default:

üíø Make the posts component

```tsx filename=app/routes/posts._index.tsx
export default function Posts() {
  return (
    <main>
      <h1>Posts</h1>
    </main>
  );
}
```

You might need to refresh the browser to see our new, bare-bones posts route.

## Loading Data

Data loading is built into Remix.

If your web dev background is primarily in the last few years, you're probably used to creating two things here: an API route to provide data and a frontend component that consumes it. In Remix your frontend component is also its own API route, and it already knows how to talk to itself on the server from the browser. That is, you don't have to fetch it.

If your background is a bit farther back than that with MVC web frameworks like Rails, then you can think of your Remix routes as backend views using React for templating, but then they know how to seamlessly hydrate in the browser to add some flair instead of writing detached jQuery code to dress up the user interactions. It's progressive enhancement realized in its fullest. Additionally, your routes are their own controller.

So let's get to it and provide some data to our component.

üíø Make the posts route `loader`

```tsx filename=app/routes/posts._index.tsx lines=[1-2,4-17,20-21]
import { json } from '@remix-run/node';
import { useLoaderData } from '@remix-run/react';

export const loader = async () => {
  return json({
    posts: [
      {
        slug: 'my-first-post',
        title: 'My First Post',
      },
      {
        slug: '90s-mixtape',
        title: 'A Mixtape I Made Just For You',
      },
    ],
  });
};

export default function Posts() {
  const { posts } = useLoaderData<typeof loader>();
  return (
    <main>
      <h1>Posts</h1>
    </main>
  );
}
```

`loader` functions are the backend "API" for their component, and it's already wired up for you through `useLoaderData`. It's a little wild how blurry the line is between the client and the server in a Remix route. If you have your server and browser consoles both open, you'll note that they both logged our post data. That's because Remix rendered on the server to send a full HTML document like a traditional web framework, but it also hydrated in the client and logged there too.

<docs-error>
Whatever you return from your loader will be exposed to the client, even if the component doesn't render it. Treat your loaders with the same care as public API endpoints.
</docs-error>

üíø Render links to our posts

```tsx filename=app/routes/posts._index.tsx lines=[2,10-21] nocopy
import { json } from '@remix-run/node';
import { Link, useLoaderData } from '@remix-run/react';

// ...
export default function Posts() {
  const { posts } = useLoaderData<typeof loader>();
  return (
    <main>
      <h1>Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.slug}>
            <Link to={post.slug} className="text-blue-600 underline">
              {post.title}
            </Link>
          </li>
        ))}
      </ul>
    </main>
  );
}
```

Hey, that's pretty cool. We get a pretty solid degree of type safety even over a network request because it's all defined in the same file. Unless the network blows up while Remix fetches the data, you've got type safety in this component and its API (remember, the component is already its own API route).

## A little refactoring

A solid practice is to create a module that deals with a particular concern. In our case it's going to be reading and writing posts. Let's set that up now and add a `getPosts` export to our module.

üíø Create `app/models/post.server.ts`

```shellscript nonumber
touch app/models/post.server.ts
```

We're mostly going to copy/paste stuff from our route:

```tsx filename=app/models/post.server.ts
type Post = {
  slug: string;
  title: string;
};

export async function getPosts(): Promise<Array<Post>> {
  return [
    {
      slug: 'my-first-post',
      title: 'My First Post',
    },
    {
      slug: '90s-mixtape',
      title: 'A Mixtape I Made Just For You',
    },
  ];
}
```

Note that we're making the `getPosts` function `async` because even though it's not currently doing anything async it will soon!

üíø Update the posts route to use our new posts module:

```tsx filename=app/routes/posts._index.tsx lines=[4,6-8] nocopy
import { json } from '@remix-run/node';
import { Link, useLoaderData } from '@remix-run/react';

import { getPosts } from '@/models/post.server';

export const loader = async () => {
  return json({ posts: await getPosts() });
};

// ...
```

## Pulling from a data source

With the Indie Stack, we've got a SQLite database already set up and configured for us, so let's update our Database Schema to handle SQLite. We're using [Prisma][prisma] to interact with the database, so we'll update that schema and Prisma will take care of updating our database to match the schema for us (as well as generating and running the necessary SQL commands for the migration).

<docs-info>You do not have to use Prisma when using Remix. Remix works great with whatever existing database or data persistence services you're currently using.</docs-info>

If you've never used Prisma before, don't worry, we'll walk you through it.

üíø First, we need to update our Prisma schema:

```prisma filename=prisma/schema.prisma nocopy
// Stick this at the bottom of that file:

model Post {
  slug     String @id
  title    String
  markdown String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

üíø Let's generate a migration file for our schema changes, which will be required if you deploy your application rather than just running in dev mode locally. This will also update our local database and TypeScript definitions to match the schema change. We'll name the migration "create post model".

```shellscript nonumber
npx prisma migrate dev --name "create post model"
```

üíø Let's seed our database with a couple posts. Open `prisma/seed.ts` and add this to the end of the seed functionality (right before the `console.log`):

```ts filename=prisma/seed.ts
const posts = [
  {
    slug: 'my-first-post',
    title: 'My First Post',
    markdown: `
# This is my first post

Isn't it great?
    `.trim(),
  },
  {
    slug: '90s-mixtape',
    title: 'A Mixtape I Made Just For You',
    markdown: `
# 90s Mixtape

- I wish (Skee-Lo)
- This Is How We Do It (Montell Jordan)
- Everlong (Foo Fighters)
- Ms. Jackson (Outkast)
- Interstate Love Song (Stone Temple Pilots)
- Killing Me Softly With His Song (Fugees, Ms. Lauryn Hill)
- Just a Friend (Biz Markie)
- The Man Who Sold The World (Nirvana)
- Semi-Charmed Life (Third Eye Blind)
- ...Baby One More Time (Britney Spears)
- Better Man (Pearl Jam)
- It's All Coming Back to Me Now (C√©line Dion)
- This Kiss (Faith Hill)
- Fly Away (Lenny Kravits)
- Scar Tissue (Red Hot Chili Peppers)
- Santa Monica (Everclear)
- C'mon N' Ride it (Quad City DJ's)
    `.trim(),
  },
];

for (const post of posts) {
  await prisma.post.upsert({
    where: { slug: post.slug },
    update: post,
    create: post,
  });
}
```

<docs-info>Note that we're using `upsert` so you can run the seed script over and over without adding multiple versions of the same post every time.</docs-info>

Great, let's get those posts into the database with the seed script:

```
npx prisma db seed
```

üíø Now update the `app/models/post.server.ts` file to read from the SQLite database:

```ts filename=app/models/post.server.ts
import { prisma } from '@/db.server';

export async function getPosts() {
  return prisma.post.findMany();
}
```

<docs-success>Notice we're able to remove the return type, but everything is still fully typed. The TypeScript feature of Prisma is one of its greatest strengths. Less manual typing, but still type safe!</docs-success>

<docs-info>The `~/db.server` import is importing the file at `app/db.server.ts`. The `~` is a fancy alias to the `app` directory, so you don't have to worry about how many `../../`s to include in your import as you move files around.</docs-info>

You should be able to go to `http://localhost:3000/posts` and the posts should still be there, but now they're coming from SQLite!

## Dynamic Route Params

Now let's make a route to actually view the post. We want these URLs to work:

```
/posts/my-first-post
/posts/90s-mixtape
```

Instead of creating a route for every single one of our posts, we can use a "dynamic segment" in the url. Remix will parse and pass to us, so we can look up the post dynamically.

üíø Create a dynamic route at `app/routes/posts.$slug.tsx`

```shellscript nonumber
touch app/routes/posts.\$slug.tsx
```

```tsx filename=app/routes/posts.$slug.tsx
export default function PostSlug() {
  return (
    <main className="mx-auto max-w-4xl">
      <h1 className="my-6 border-b-2 text-center text-3xl">Some Post</h1>
    </main>
  );
}
```

You can click one of your posts and should see the new page.

üíø Add a loader to access the params

```tsx filename=app/routes/posts.$slug.tsx lines=[1-3,5-9,12,16]
import type { LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import { useLoaderData } from '@remix-run/react';

export const loader = async ({ params }: LoaderFunctionArgs) => {
  return json({ slug: params.slug });
};

export default function PostSlug() {
  const { slug } = useLoaderData<typeof loader>();
  return (
    <main className="mx-auto max-w-4xl">
      <h1 className="my-6 border-b-2 text-center text-3xl">Some Post: {slug}</h1>
    </main>
  );
}
```

The part of the filename attached to the `$` becomes a named key on the `params` object that comes into your loader. This is how we'll look up our blog post.

Now, let's actually get the post contents from the database by its slug.

üíø Add a `getPost` function to our post module

```tsx filename=app/models/post.server.ts lines=[7-9]
import { prisma } from '@/db.server';

export async function getPosts() {
  return prisma.post.findMany();
}

export async function getPost(slug: string) {
  return prisma.post.findUnique({ where: { slug } });
}
```

üíø Use the new `getPost` function in the route

```tsx filename=app/routes/posts.$slug.tsx lines=[5,10-11,15,19]
import type { LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import { useLoaderData } from '@remix-run/react';

import { getPost } from '@/models/post.server';

export const loader = async ({ params }: LoaderFunctionArgs) => {
  const post = await getPost(params.slug);
  return json({ post });
};

export default function PostSlug() {
  const { post } = useLoaderData<typeof loader>();
  return (
    <main className="mx-auto max-w-4xl">
      <h1 className="my-6 border-b-2 text-center text-3xl">{post.title}</h1>
    </main>
  );
}
```

Check that out! We're now pulling our posts from a data source instead of including it all in the browser as JavaScript.

Let's make TypeScript happy with our code:

```tsx filename=app/routes/posts.$slug.tsx lines=[4,11,14]
import type { LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import { useLoaderData } from '@remix-run/react';
import invariant from 'tiny-invariant';

import { getPost } from '@/models/post.server';

export const loader = async ({ params }: LoaderFunctionArgs) => {
  invariant(params.slug, 'params.slug is required');

  const post = await getPost(params.slug);
  invariant(post, `Post not found: ${params.slug}`);

  return json({ post });
};

export default function PostSlug() {
  const { post } = useLoaderData<typeof loader>();
  return (
    <main className="mx-auto max-w-4xl">
      <h1 className="my-6 border-b-2 text-center text-3xl">{post.title}</h1>
    </main>
  );
}
```

Quick note on that `invariant` for the params. Because `params` comes from the URL, we can't be totally sure that `params.slug` will be defined--maybe you change the name of the file to `posts.$postId.ts`! It's a good practice to validate that stuff with `invariant`, and it makes TypeScript happy too.

We also have an invariant for the post. We'll handle the `404` case better later. Keep going!

Now let's get that markdown parsed and rendered to HTML to the page. There are a lot of Markdown parsers, we'll use `marked` for this tutorial because it's really easy to get working.

üíø Parse the markdown into HTML

```shellscript nonumber
npm add marked@^4.3.0
# additionally, if using typescript
npm add @types/marked@^4.3.1 -D
```

Now that `marked` has been installed, we will need to restart our server. So stop the dev server and start it back up again with `npm run dev`.

```tsx filename=app/routes/posts.$slug.tsx lines=[4,17-18,22,28]
import type { LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import { useLoaderData } from '@remix-run/react';
import { marked } from 'marked';
import invariant from 'tiny-invariant';

import { getPost } from '@/models/post.server';

export const loader = async ({ params }: LoaderFunctionArgs) => {
  invariant(params.slug, 'params.slug is required');

  const post = await getPost(params.slug);
  invariant(post, `Post not found: ${params.slug}`);

  const html = marked(post.markdown);
  return json({ html, post });
};

export default function PostSlug() {
  const { html, post } = useLoaderData<typeof loader>();
  return (
    <main className="mx-auto max-w-4xl">
      <h1 className="my-6 border-b-2 text-center text-3xl">{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: html }} />
    </main>
  );
}
```

Holy smokes, you did it. You have a blog. Check it out! Next, we're going to make it easier to create new blog posts üìù

## Nested Routing

Right now, our blog posts just come from seeding the database. Not a real solution, so we need a way to create a new blog post in the database. We're going to be using actions for that.

Let's make a new "admin" section of the app.

üíø First, let's add a link to the admin section on the posts index route:

```tsx filename=app/routes/posts._index.tsx
// ...
<Link to="admin" className="text-red-600 underline">
  Admin
</Link>
// ...
```

Put that anywhere in the component. I stuck it right under the `<h1>`.

<docs-info>Did you notice that the `to` prop is just "admin" and it linked to `/posts/admin`? With Remix, you get relative links.</docs-info>

üíø Create an admin route at `app/routes/posts.admin.tsx`:

```shellscript nonumber
touch app/routes/posts.admin.tsx
```

```tsx filename=app/routes/posts.admin.tsx
import { json } from '@remix-run/node';
import { Link, useLoaderData } from '@remix-run/react';

import { getPosts } from '@/models/post.server';

export const loader = async () => {
  return json({ posts: await getPosts() });
};

export default function PostAdmin() {
  const { posts } = useLoaderData<typeof loader>();
  return (
    <div className="mx-auto max-w-4xl">
      <h1 className="my-6 mb-2 border-b-2 text-center text-3xl">Blog Admin</h1>
      <div className="grid grid-cols-4 gap-6">
        <nav className="col-span-4 md:col-span-1">
          <ul>
            {posts.map((post) => (
              <li key={post.slug}>
                <Link to={post.slug} className="text-blue-600 underline">
                  {post.title}
                </Link>
              </li>
            ))}
          </ul>
        </nav>
        <main className="col-span-4 md:col-span-3">...</main>
      </div>
    </div>
  );
}
```

You should recognize several of the things we're doing in there from what we've done so far. With that, you should have a decent looking page with the posts on the left and a placeholder on the right.
Now, if you click on the Admin link, it'll take you to [http://localhost:3000/posts/admin][http-localhost-3000-posts-admin].

### Index Routes

Let's fill in that placeholder with an index route for admin. Hang with us, we're introducing "nested routes" here where your route file nesting becomes UI component nesting.

üíø Create an index route for `posts.admin.tsx`'s child routes

```shellscript nonumber
touch app/routes/posts.admin._index.tsx
```

```tsx filename=app/routes/posts.admin._index.tsx
import { Link } from '@remix-run/react';

export default function AdminIndex() {
  return (
    <p>
      <Link to="new" className="text-blue-600 underline">
        Create a New Post
      </Link>
    </p>
  );
}
```

If you refresh you're not going to see it yet. Every route that starts with `app/routes/posts.admin.` can now render _inside_ of `app/routes/posts.admin.tsx` when their URL matches. You get to control which part of the `posts.admin.tsx` layout the child routes render.

üíø Add an outlet to the admin page

```tsx filename=app/routes/posts.admin.tsx lines=[4,37]
import { json } from '@remix-run/node';
import { Link, Outlet, useLoaderData } from '@remix-run/react';

import { getPosts } from '@/models/post.server';

export const loader = async () => {
  return json({ posts: await getPosts() });
};

export default function PostAdmin() {
  const { posts } = useLoaderData<typeof loader>();
  return (
    <div className="mx-auto max-w-4xl">
      <h1 className="my-6 mb-2 border-b-2 text-center text-3xl">Blog Admin</h1>
      <div className="grid grid-cols-4 gap-6">
        <nav className="col-span-4 md:col-span-1">
          <ul>
            {posts.map((post) => (
              <li key={post.slug}>
                <Link to={post.slug} className="text-blue-600 underline">
                  {post.title}
                </Link>
              </li>
            ))}
          </ul>
        </nav>
        <main className="col-span-4 md:col-span-3">
          <Outlet />
        </main>
      </div>
    </div>
  );
}
```

Hang with us for a minute, index routes can be confusing at first. Just know that when the URL matches the parent route's path, the index will render inside the `Outlet`.

Maybe this will help, let's add the `/posts/admin/new` route and see what happens when we click the link.

üíø Create the `app/routes/posts.admin.new.tsx` file

```shellscript nonumber
touch app/routes/posts.admin.new.tsx
```

```tsx filename=app/routes/posts.admin.new.tsx
export default function NewPost() {
  return <h2>New Post</h2>;
}
```

Now click the link from the index route and watch the `<Outlet/>` automatically swap out the index route for the "new" route!

## Actions

We're going to get serious now. Let's build a form to create a new post in our new "new" route.

üíø Add a form to the new route

```tsx filename=app/routes/posts.admin.new.tsx
import { Form } from '@remix-run/react';

const inputClassName = 'w-full rounded border border-gray-500 px-2 py-1 text-lg';

export default function NewPost() {
  return (
    <Form method="post">
      <p>
        <label>
          Post Title: <input type="text" name="title" className={inputClassName} />
        </label>
      </p>
      <p>
        <label>
          Post Slug: <input type="text" name="slug" className={inputClassName} />
        </label>
      </p>
      <p>
        <label htmlFor="markdown">Markdown: </label>
        <br />
        <textarea
          id="markdown"
          rows={20}
          name="markdown"
          className={`${inputClassName} font-mono`}
        />
      </p>
      <p className="text-right">
        <button
          type="submit"
          className="rounded bg-blue-500 py-2 px-4 text-white hover:bg-blue-600 focus:bg-blue-400 disabled:bg-blue-300"
        >
          Create Post
        </button>
      </p>
    </Form>
  );
}
```

If you love HTML like us, you should be getting pretty excited. If you've been doing a lot of `<form onSubmit>` and `<button onClick>` you're about to have your mind blown by HTML.

All you really need for a feature like this is a form to get data from the user and a backend action to handle it. And in Remix, that's all you have to do too.

Let's create the essential code that knows how to save a post first in our `post.ts` module.

üíø Add `createPost` anywhere inside of `app/models/post.server.ts`

```tsx filename=app/models/post.server.ts nocopy
// ...
export async function createPost(post) {
  return prisma.post.create({ data: post });
}
```

üíø Call `createPost` from the new post route's action

```tsx filename=app/routes/posts.admin.new.tsx lines=[1-2,5,7-19] nocopy
import type { ActionFunctionArgs } from '@remix-run/node';
import { redirect } from '@remix-run/node';
import { Form } from '@remix-run/react';

import { createPost } from '@/models/post.server';

export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();

  const title = formData.get('title');
  const slug = formData.get('slug');
  const markdown = formData.get('markdown');

  await createPost({ title, slug, markdown });

  return redirect('/posts/admin');
};

// ...
```

That's it. Remix (and the browser) will take care of the rest. Click the submit button and watch the sidebar that lists our posts update automatically.

In HTML an input's `name` attribute is sent over the network and available by the same name on the request's `formData`. Oh, and don't forget, the `request` and `formData` objects are both straight out of the web specification. So if you want to learn more about either of them, head over to MDN!

- [`Request`][mdn-request]
- [`Request.formData`][mdn-request-form-data].

TypeScript is mad again, let's add some types.

üíø Add the types to `app/models/post.server.ts`

```tsx filename=app/models/post.server.ts lines=[2,7]
// ...
import type { Post } from '@prisma/client';

// ...

export async function createPost(post: Pick<Post, 'slug' | 'title' | 'markdown'>) {
  return prisma.post.create({ data: post });
}
```

Whether you're using TypeScript or not, we've got a problem when the user doesn't provide values on some of these fields (and TS is still mad about that call to `createPost`).

Let's add some validation before we create the post.

üíø Validate if the form data contains what we need, and return the errors if not

```tsx filename=app/routes/posts.admin.new.tsx lines=[2,16-26]
import type { ActionFunctionArgs } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
import { Form } from '@remix-run/react';

import { createPost } from '@/models/post.server';

export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();

  const title = formData.get('title');
  const slug = formData.get('slug');
  const markdown = formData.get('markdown');

  const errors = {
    title: title ? null : 'Title is required',
    slug: slug ? null : 'Slug is required',
    markdown: markdown ? null : 'Markdown is required',
  };
  const hasErrors = Object.values(errors).some((errorMessage) => errorMessage);
  if (hasErrors) {
    return json(errors);
  }

  await createPost({ title, slug, markdown });

  return redirect('/posts/admin');
};

// ...
```

Notice we don't return a redirect this time, we actually return the errors. These errors are available to the component via `useActionData`. It's just like `useLoaderData` but the data comes from the action after a form POST.

üíø Add validation messages to the UI

```tsx filename=app/routes/posts.admin.new.tsx lines=[3,11,18-20,27-29,36-40]
import type { ActionFunctionArgs } from '@remix-run/node';
import { redirect, json } from '@remix-run/node';
import { Form, useActionData } from '@remix-run/react';

// ...

const inputClassName = 'w-full rounded border border-gray-500 px-2 py-1 text-lg';

export default function NewPost() {
  const errors = useActionData<typeof action>();

  return (
    <Form method="post">
      <p>
        <label>
          Post Title: {errors?.title ? <em className="text-red-600">{errors.title}</em> : null}
          <input type="text" name="title" className={inputClassName} />
        </label>
      </p>
      <p>
        <label>
          Post Slug: {errors?.slug ? <em className="text-red-600">{errors.slug}</em> : null}
          <input type="text" name="slug" className={inputClassName} />
        </label>
      </p>
      <p>
        <label htmlFor="markdown">
          Markdown: {errors?.markdown ? <em className="text-red-600">{errors.markdown}</em> : null}
        </label>
        <br />
        <textarea
          id="markdown"
          rows={20}
          name="markdown"
          className={`${inputClassName} font-mono`}
        />
      </p>
      <p className="text-right">
        <button
          type="submit"
          className="rounded bg-blue-500 py-2 px-4 text-white hover:bg-blue-600 focus:bg-blue-400 disabled:bg-blue-300"
        >
          Create Post
        </button>
      </p>
    </Form>
  );
}
```

TypeScript is still mad, because someone could call our API with non-string values, so let's add some invariants to make it happy.

```tsx filename=app/routes/posts.admin.new.tsx nocopy
//...
import invariant from 'tiny-invariant';
// ..

export const action = async ({ request }: ActionFunctionArgs) => {
  // ...
  invariant(typeof title === 'string', 'title must be a string');
  invariant(typeof slug === 'string', 'slug must be a string');
  invariant(typeof markdown === 'string', 'markdown must be a string');

  await createPost({ title, slug, markdown });

  return redirect('/posts/admin');
};
```

## Progressive Enhancement

For some real fun, [disable JavaScript][disable-java-script] in your dev tools and try it out. Because Remix is built on the fundamentals of HTTP and HTML, this whole thing works without JavaScript in the browser ü§Ø But that's not the point. What's cool about it is that this means our UI is resilient to network issues. But we really _like_ having JavaScript in the browser and there are a lot of cool things we can do when we've got it, so make sure to re-enable JavaScript before continuing, because we're going to need it to _progressively enhance_ the user experience next.

Let's slow this down and add some "pending UI" to our form.

üíø Slow down our action with a fake delay

```tsx filename=app/routes/posts.admin.new.tsx lines=[5-6]
// ...
export const action = async ({ request }: ActionFunctionArgs) => {
  // TODO: remove me
  await new Promise((res) => setTimeout(res, 1000));

  // ...
};
//...
```

üíø Add some pending UI with `useNavigation`

```tsx filename=app/routes/posts.admin.new.tsx lines=[6,14-17,26,28]
import type { ActionFunctionArgs } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
import { Form, useActionData, useNavigation } from '@remix-run/react';

// ..

export default function NewPost() {
  const errors = useActionData<typeof action>();

  const navigation = useNavigation();
  const isCreating = Boolean(navigation.state === 'submitting');

  return (
    <Form method="post">
      {/* ... */}
      <p className="text-right">
        <button
          type="submit"
          className="rounded bg-blue-500 py-2 px-4 text-white hover:bg-blue-600 focus:bg-blue-400 disabled:bg-blue-300"
          disabled={isCreating}
        >
          {isCreating ? 'Creating...' : 'Create Post'}
        </button>
      </p>
    </Form>
  );
}
```

Tada! You just implemented JavaScript-enabled progressive enhancement! ü•≥ With what we've done, the experience is better than what the browser can do by itself. Lots of apps use JavaScript to _enable_ the experience (and a select few actually do require JavaScript to work), but we've got a working experience as a baseline and just used JavaScript to _enhance_ it.

## Homework

That's it for today! Here are some bits of homework to implement if you want to go deeper:

**Update/Delete posts:** make a `posts.admin.$slug.tsx` page for your posts. This should open an edit page for the post that allows you to update the post or even delete it. The links are already there in the sidebar, but they return 404! Create a new route that reads the posts, and puts them into the fields. All the code you need is already in `app/routes/posts.$slug.tsx` and `app/routes/posts.admin.new.tsx`. You just gotta put it together.

**Optimistic UI:** You know how when you favorite a tweet, the heart goes red instantly and if the tweet is deleted it reverts back to empty? That's Optimistic UI: assume the request will succeed, and render what the user will see if it does. So your homework is to make it so when you hit "Create" it renders the post in the left nav and renders the "Create a New Post" link (or if you add update/delete do it for those too). You'll find this ends up being easier than you think even if it takes you a second to arrive there (and if you've implemented this pattern in the past, you'll find Remix makes this much easier). Learn more from [the Pending UI guide][the-pending-ui-guide].

**Authenticated users only:** Another cool bit of homework you could do is make it so only authenticated users can create posts. You've already got authentication all set up for you thanks to the Indie Stack. Tip: if you want to make it, so you're the only one who can make posts, simply check the user's email in your loaders and actions and if it's not yours redirect them [somewhere][somewhere] üòà

**Customize the app:** If you're happy with Tailwind CSS, keep it around, otherwise, check [the styling guide][the-styling-guide] to learn of other options. Remove the `Notes` model and routes, etc. Whatever you want to make this thing yours.

**Deploy the app:** Check the README of your project. It has instructions you can follow to get your app deployed to Fly.io. Then you can actually start blogging!

We hope you love Remix! üíø üëã

[gitpod]: https://gitpod.io
[gitpod-ready-to-code-image]: https://gitpod.io/#https://github.com/remix-run/indie-stack
[gitpod-ready-to-code]: https://img.shields.io/badge/Gitpod-Ready--to--Code-blue?logo=gitpod
[node-js]: https://nodejs.org
[npm]: https://www.npmjs.com
[vs-code]: https://code.visualstudio.com
[the-stacks-docs]: ../guides/templates#stacks
[the-indie-stack]: https://github.com/remix-run/indie-stack
[fly-io]: https://fly.io
[http-localhost-3000]: http://localhost:3000
[screenshot-of-the-app-showing-the-blog-post-link]: https://user-images.githubusercontent.com/1500684/160208939-34fe20ed-3146-4f4b-a68a-d82284339c47.png
[tailwind]: https://tailwindcss.com
[the-styling-guide]: ../styling/tailwind
[prisma]: https://prisma.io
[http-localhost-3000-posts-admin]: http://localhost:3000/posts/admin
[mdn-request]: https://developer.mozilla.org/en-US/docs/Web/API/Request
[mdn-request-form-data]: https://developer.mozilla.org/en-US/docs/Web/API/Request/formData
[disable-java-script]: https://developer.chrome.com/docs/devtools/javascript/disable
[the-pending-ui-guide]: ../discussion/pending-ui
[somewhere]: https://www.youtube.com/watch?v=dQw4w9WgXcQ

---

## File: ./tutorials/index.md

---

title: Tutorials
hidden: true

---

---

## File: ./tutorials/jokes.md

---

title: App Tutorial (long)
order: 4
hidden: true

---

# Jokes App Tutorial

<docs-warning>This tutorial currently assumes you are using the[Classic Remix Compiler][classic-remix-compiler] rather than [Remix Vite][remix-vite].</docs-warning>

You want to learn Remix? You're in the right place. Let's build [Remix Jokes][remix-jokes]!

<docs-info><a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/watch?v=hsIWJpuxNj0">Work through this tutorial with Kent in this live stream</a></docs-info>

<a href="https://remix-jokes.lol"><img src="https://remix-jokes.lol/social.png" style="aspect-ratio: 300 / 157; width: 100%"/></a>

This tutorial is the comprehensive way to getting an overview of the primary APIs available in Remix. By the end, you'll have a full application you can show your mom, significant other, or dog, and I'm sure they'll be just as excited about Remix as you are (though I make no guarantees).

We're going to be laser focused on Remix. This means that we're going to skip over a few things that are a distraction from the core ideas we want you to learn about Remix. For example, we'll show you how to get a CSS stylesheet on the page, but we're not going to make you write the styles by yourself. So we'll just give you stuff you can copy/paste for that kind of thing. However, if you'd prefer to write it all out yourself, you totally can (it'll just take you much longer). So we'll put it in little `<details>` elements you have to click to expand to not spoil anything if you'd prefer to code it out yourself.

<details>

<summary>Click me</summary>

There are several areas in the tutorial where we stick code behind one of these `<details>` elements. This is so you can choose how much copy/paste you want to do without us spoiling it for you. We don't recommend struggling with concepts unrelated to Remix though, like guessing what class names to use. Feel free to reference these sections to check your work once you get the main point of the tutorial. Or if you want to run through things quickly then you can just copy/paste stuff as you go as well. We won't judge you!

</details>

We'll be linking to various docs (Remix docs as well as web docs on [MDN][mdn]) throughout the tutorial (if you don't already use MDN, you'll find yourself using it a _lot_ with Remix, and getting better at the web while you're at it). If you're ever stuck, make sure you check into any docs links you may have skipped. Part of the goal of this tutorial is to get you acclimated to the Remix and web API documentation, so if something's explained in the docs, then you'll be linked to those instead of rehashing it all out in here.

This tutorial will be using TypeScript. Feel free to follow along and skip/remove the TypeScript bits. We find that Remix is made even better when you're using TypeScript, especially since we'll also be using [Prisma][prisma] to access our data models from the SQLite database.

<docs-info>üíø Hello, I'm Rachel the Remix Disc. I'll show up whenever you have to actually _do_ something.</docs-info>

<docs-warning>Feel free to explore as you go, but if you deviate from the tutorial too much (like trying to deploy before getting to that step for example), you may find it doesn't work like you expected because you missed something important.</docs-warning>

<docs-error>We won't add JavaScript to the browser until toward the end of the tutorial. This is to show you how well your application will work when JavaScript takes a long time to load (or fails to load at all). So until we actually add JavaScript to the page, you won't be able to use things like `useState` until we get to that step.</docs-error>

## Outline

Here are the topics we'll be covering in this tutorial:

- Generating a new Remix project
- Conventional files
- Routes (including the nested variety ‚ú®)
- Styling
- Database interactions (via `sqlite` and `prisma`)
- Mutations
- Validation
- Authentication
- Error handling: Both unexpected (the dev made a whoopsies) and expected (the end-user made a whoopsies) errors
- SEO with Meta Tags
- JavaScript...
- Resource Routes
- Deployment

You'll find links to the sections of the tutorial in the navbar (top of the page for mobile and to the right for desktop).

## Prerequisites

You can follow along with this tutorial on [CodeSandbox][code-sandbox] (a fantastic in-browser editor) or locally on your own computer. If you use the CodeSandbox approach then all you need is a good internet connection and a modern browser. If you run things locally then you're going to need some things installed:

- [Node.js][node-js] version (>=18.0.0)
- [npm][npm] 7 or greater
- A code editor ([VSCode][vs-code] is a nice one)

If you'd like to follow along with the deployment step at the end, you'll also want an account on [Fly.io][fly-io].

We'll also be executing commands in your system command line/terminal interface. So you'll want to be familiar with that.

Some experience with React and TypeScript/JavaScript is assumed. If you'd like to review your knowledge, check out these resources:

- [JavaScript to know for React][java-script-to-know-for-react]
- [The Beginner's Guide to React][the-beginner-s-guide-to-react]

And having a good understanding of [the HTTP API][the-http-api] is also helpful, but not totally required.

With that, I think we're ready to get started!

## Generating a new Remix project

<docs-info>

If you're planning on using CodeSandbox, you can use [the Basic example][the-basic-example] to get started.

</docs-info>

üíø Open your terminal and run this command:

```shellscript nonumber
npx create-remix@latest
```

<docs-info>

This may ask you whether you want to install `create-remix@latest`. Enter `y`. It will only be installed the first time to run the setup script.

</docs-info>

Once the setup script has run, it'll ask you a few questions. We'll call our app "remix-jokes", select to initialize a Git repository and have it run the installation for us:

```
Where should we create your new project?
remix-jokes

Initialize a new git repository?
Yes

Install dependencies with npm?
Yes
```

Remix can be deployed in a large and growing list of JavaScript environments. The "Remix App Server" is a full-featured [Node.js][node-js] server based on [Express][express]. It's the simplest option, and it satisfies most people's needs, so that's what we're going with for this tutorial. Feel free to experiment in the future!

Once the `npm install` has completed, we'll change into the `remix-jokes` directory:

üíø Run this command

```shellscript nonumber
cd remix-jokes
```

Now you're in the `remix-jokes` directory. All other commands you run from here on out will be in that directory.

üíø Great, now open that up in your favorite editor and let's explore the project structure a bit.

## Explore the project structure

Here's the tree structure. Hopefully what you've got looks a bit like this:

```
remix-jokes
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ app
‚îÇ   ‚îú‚îÄ‚îÄ entry.client.tsx
‚îÇ   ‚îú‚îÄ‚îÄ entry.server.tsx
‚îÇ   ‚îú‚îÄ‚îÄ root.tsx
‚îÇ   ‚îî‚îÄ‚îÄ routes
‚îÇ       ‚îî‚îÄ‚îÄ _index.tsx
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ public
‚îÇ   ‚îî‚îÄ‚îÄ favicon.ico
‚îú‚îÄ‚îÄ remix.config.js
‚îú‚îÄ‚îÄ remix.env.d.ts
‚îî‚îÄ‚îÄ tsconfig.json
```

Let's talk briefly about a few of these files:

- `app/` - This is where all your Remix app code goes
- `app/entry.client.tsx` - This is the first bit of your JavaScript that will run when the app loads in the browser. We use this file to [hydrate][hydrate] our React components.
- `app/entry.server.tsx` - This is the first bit of your JavaScript that will run when a request hits your server. Remix handles loading all the necessary data, and you're responsible for sending back the response. We'll use this file to render our React app to a string/stream and send that as our response to the client.
- `app/root.tsx` - This is where we put the root component for our application. You render the `<html>` element here.
- `app/routes/` - This is where all your "route modules" will go. Remix uses the files in this directory to create the URL routes for your app based on the name of the files.
- `public/` - This is where your static assets go (images/fonts/etc.)
- `remix.config.js` - Remix has a handful of configuration options you can set in this file.

üíø Let's go ahead and run the build:

```shellscript nonumber
npm run build
```

That should output something like this:

```
Building Remix app in production mode...
Built in 132ms
```

Now you should also have a `.cache/` directory (something used internally by Remix), a `build/` directory, and a `public/build` directory. The `build/` directory is our server-side code. The `public/build/` holds all our client-side code. These three directories are listed in your `.gitignore` file, so you don't commit the generated files to source control.

üíø Let's run the built app now:

```shellscript nonumber
npm start
```

This will start the server and output this:

```
Remix App Server started at http://localhost:3000
```

Open up that URL and you should be presented with a minimal page pointing to some docs.

üíø Now stop the server and delete this directory:

- `app/routes`

We're going to trim this down the bare bones and introduce things incrementally.

üíø Replace the contents of `app/root.tsx` with this:

```tsx filename=app/root.tsx
import { LiveReload } from '@remix-run/react';

export default function App() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Remix: So great, it's funny!</title>
      </head>
      <body>
        Hello world
        <LiveReload />
      </body>
    </html>
  );
}
```

<docs-info>

The `<LiveReload />` component is useful during development to auto-refresh our browser whenever we make a change. Because our build server is so fast, the reload will often happen before you even notice ‚ö°

</docs-info>

Your `app/` directory should now look like this:

```
app
‚îú‚îÄ‚îÄ entry.client.tsx
‚îú‚îÄ‚îÄ entry.server.tsx
‚îî‚îÄ‚îÄ root.tsx
```

üíø With that set up, go ahead and start the dev server up with this command:

```shellscript nonumber
npm run dev
```

Open [http://localhost:3000][http-localhost-3000] and the app should greet the world:

![Bare bones hello world app][bare-bones-hello-world-app]

Great, now we're ready to start adding stuff back.

## Routes

The first thing we want to do is get our routing structure set up. Here are all the routes our app is going to have:

```
/
/jokes
/jokes/:jokeId
/jokes/new
/login
```

You can programmatically create routes via the [`remix.config.js`][remix-config-js], but the more common way to create the routes is through the file system. This is called "file-based routing."

Each file we put in the `app/routes` directory is called a Route Module and by following [the route filename convention][the-route-filename-convention], we can create the routing URL structure we're looking for. Remix uses [React Router][react_router] under the hood to handle this routing.

üíø Let's start with the index route (`/`). To do that, create a file at `app/routes/_index.tsx` and `export default` a component from that route module. For now, you can have it just say "Hello Index Route" or something.

<details>

<summary>app/routes/_index.tsx</summary>

```tsx filename=app/routes/_index.tsx
export default function IndexRoute() {
  return <div>Hello Index Route</div>;
}
```

</details>

React Router supports "nested routing" which means we have parent-child relationships in our routes. The `app/routes/_index.tsx` is a child of the `app/root.tsx` route. In nested routing, parents are responsible for laying out their children.

üíø Update the `app/root.tsx` to position children. You'll do this with the `<Outlet />` component from `@remix-run/react`:

<details>

<summary>app/root.tsx</summary>

```tsx filename=app/root.tsx lines=[1,15]
import { LiveReload, Outlet } from '@remix-run/react';

export default function App() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Remix: So great, it's funny!</title>
      </head>
      <body>
        <Outlet />
        <LiveReload />
      </body>
    </html>
  );
}
```

</details>

<docs-info>Remember to have the dev server running with `npm run dev`</docs-info>

That will watch your filesystem for changes, rebuild the site, and thanks to the `<LiveReload />` component your browser will refresh.

üíø Go ahead and open up the site again, and you should be presented with the greeting from the index route.

![A greeting from the index route][a-greeting-from-the-index-route]

Great! Next let's handle the `/jokes` route.

üíø Create a new route at `app/routes/jokes.tsx` (keep in mind that this will be a parent route, so you'll want to use `<Outlet />` again).

<details>

<summary>app/routes/jokes.tsx</summary>

```tsx filename=app/routes/jokes.tsx
import { Outlet } from '@remix-run/react';

export default function JokesRoute() {
  return (
    <div>
      <h1>Jü§™KES</h1>
      <main>
        <Outlet />
      </main>
    </div>
  );
}
```

</details>

You should be presented with that component when you go to [`/jokes`][jokes]. Now, in that `<Outlet />` we want to render out some random jokes in the "index route".

üíø Create a route at `app/routes/jokes._index.tsx`

<details>

<summary>app/routes/jokes._index.tsx</summary>

```tsx filename=app/routes/jokes._index.tsx
export default function JokesIndexRoute() {
  return (
    <div>
      <p>Here's a random joke:</p>
      <p>I was wondering why the frisbee was getting bigger, then it hit me.</p>
    </div>
  );
}
```

</details>

Now if you refresh [`/jokes`][jokes], you'll get the content in the `app/routes/jokes.tsx` as well as the `app/routes/jokes._index.tsx`. Here's what mine looks like:

![A random joke on the jokes page: "I was wondering why the frisbee was getting bigger, then it hit me"][a-random-joke-on-the-jokes-page-i-was-wondering-why-the-frisbee-was-getting-bigger-then-it-hit-me]

And notice that each of those route modules is only concerned with their part of the URL. Neat right!? Nested routing is pretty nice, and we're only just getting started. Let's keep going.

üíø Next, let's handle the `/jokes/new` route. I'll bet you can figure out how to do that üòÑ. Remember we're going to allow people to create jokes on this page, so you'll want to render a `form` with `name` and `content` fields.

<details>

<summary>app/routes/jokes.new.tsx</summary>

```tsx filename=app/routes/jokes.new.tsx
export default function NewJokeRoute() {
  return (
    <div>
      <p>Add your own hilarious joke</p>
      <form method="post">
        <div>
          <label>
            Name: <input type="text" name="name" />
          </label>
        </div>
        <div>
          <label>
            Content: <textarea name="content" />
          </label>
        </div>
        <div>
          <button type="submit" className="button">
            Add
          </button>
        </div>
      </form>
    </div>
  );
}
```

</details>

Great, so now going to [`/jokes/new`][jokes-new] should display your form:

![A new joke form][a-new-joke-form]

### Parameterized Routes

Soon we'll add a database that stores our jokes by an ID, so let's add one more route that's a little more unique, a parameterized route:

`/jokes/$jokeId`

Here the parameter `$jokeId` can be anything, and we can look up that part of the URL in the database to display the right joke. To make a parameterized route, we use the `$` character in the filename. ([Read more about the convention here][the-route-filename-convention]).

üíø Create a new route at `app/routes/jokes.$jokeId.tsx`. Don't worry too much about what it displays for now (we don't have a database set up yet!):

<details>

<summary>app/routes/jokes.$jokeId.tsx</summary>

```tsx filename=app/routes/jokes.$jokeId.tsx
export default function JokeRoute() {
  return (
    <div>
      <p>Here's your hilarious joke:</p>
      <p>Why don't you find hippopotamuses hiding in trees? They're really good at it.</p>
    </div>
  );
}
```

</details>

Great, so now going to [`/jokes/anything-you-want`][jokes-anything-you-want] should display what you just created (in addition to the parent routes):

![A new joke form][a-new-joke-form-2]

Great! We've got our primary routes all set up!

## Styling

From the beginning of styling on the web, to get CSS on the page, we've used `<link rel="stylesheet" href="/path-to-file.css" />`. This is how you style your Remix applications as well, but Remix makes it much easier than just throwing `link` tags all over the place. Remix brings the power of its Nested Routing support to CSS and allows you to associate `link` tags to routes. When the route is active, the `link` tag is on the page and the CSS applies. When the route is not active (the user navigates away), the `link` tag is removed and the CSS no longer applies.

You do this by exporting a [`links`][links] function in your route module. Let's get the homepage styled. You can put your CSS files anywhere you like within the `app` directory. We'll put ours in `app/styles/`.

We'll start off by just styling the home page (the index route `/`).

üíø Create `app/styles/index.css` and stick this CSS in it:

```css
body {
  color: hsl(0, 0%, 100%);
  background-image: radial-gradient(
    circle,
    rgba(152, 11, 238, 1) 0%,
    rgba(118, 15, 181, 1) 35%,
    rgba(58, 13, 85, 1) 100%
  );
}
```

üíø Now update `app/routes/_index.tsx` to import that css file. Then add a `links` export (as described in [the documentation][links]) to add that link to the page.

<details>

<summary>app/routes/_index.tsx</summary>

```tsx filename=app/routes/_index.tsx lines=[1,3,5-7]
import type { LinksFunction } from '@remix-run/node';

import stylesUrl from '@/styles/index.css';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

export default function IndexRoute() {
  return <div>Hello Index Route</div>;
}
```

</details>

Now if you go to [`/`][http-localhost-3000] you may be a bit disappointed. Our beautiful styles aren't applied! Well, you may recall that in the `app/root.tsx` we're the ones rendering _everything_ about our app. From the `<html>` to the `</html>`. That means if something doesn't show up in there, it's not going to show up at all!

So we need some way to get the `link` exports from all active routes and add `<link />` tags for all of them. Luckily, Remix makes this easy for us by providing a convenience [`<Links />`][links-component] component.

üíø Go ahead and add the Remix `<Links />` component to `app/root.tsx` within the `<head>`.

<details>

<summary>app/root.tsx</summary>

```tsx filename=app/root.tsx lines=[2,17]
import { Links, LiveReload, Outlet } from '@remix-run/react';

export default function App() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Remix: So great, it's funny!</title>
        <Links />
      </head>
      <body>
        <Outlet />
        <LiveReload />
      </body>
    </html>
  );
}
```

</details>

Great, now check [`/`][http-localhost-3000] again, and it should be nice and styled for you:

![The homepage with a purple gradient background and white text with the words "Hello Index Route"][the-homepage-with-a-purple-gradient-background-and-white-text-with-the-words-hello-index-route]

Hooray! But I want to call out something important and exciting. You know how the CSS we wrote styles the `body` element? What would you expect to happen on the [`/jokes`][jokes] route? Go ahead and check it out.

![The jokes page with no background gradient][the-jokes-page-with-no-background-gradient]

ü§Ø What is this? Why aren't the CSS rules applied? Did the `body` get removed or something?! Nope. If you open the Elements tab of the dev tools you'll notice that the link tag isn't there at all!

<docs-info>

This means that you don't have to worry about unexpected CSS clashes when you're writing your CSS. You can write whatever you like and so long as you check each route your file is linked on you'll know that you haven't impacted other pages! üî•

This also means your CSS files can be cached long-term and your CSS is naturally code-split. Performance FTW ‚ö°

</docs-info>

That's pretty much all there is to it for styling with the tutorial. The rest is just writing the CSS which you're welcome to do if you want, or simply copy the styles from below.

<details>

<summary>üíø Copy this to `app/styles/global.css`</summary>

```css filename=app/styles/global.css
@font-face {
  font-family: 'baloo';
  src: url('/fonts/baloo/baloo.woff') format('woff');
  font-weight: normal;
  font-style: normal;
}

:root {
  --hs-links: 48 100%;
  --color-foreground: hsl(0, 0%, 100%);
  --color-background: hsl(278, 73%, 19%);
  --color-links: hsl(var(--hs-links) 50%);
  --color-links-hover: hsl(var(--hs-links) 45%);
  --color-border: hsl(277, 85%, 38%);
  --color-invalid: hsl(356, 100%, 71%);
  --gradient-background: radial-gradient(
    circle,
    rgba(152, 11, 238, 1) 0%,
    rgba(118, 15, 181, 1) 35%,
    rgba(58, 13, 85, 1) 100%
  );
  --font-body:
    -apple-system, 'Segoe UI', Helvetica Neue, Helvetica, Roboto, Arial, sans-serif, system-ui,
    'Apple Color Emoji', 'Segoe UI Emoji';
  --font-display: baloo, var(--font-body);
}

html {
  box-sizing: border-box;
}

*,
*::before,
*::after {
  box-sizing: inherit;
}

:-moz-focusring {
  outline: auto;
}

:focus {
  outline: var(--color-links) solid 2px;
  outline-offset: 2px;
}

html,
body {
  padding: 0;
  margin: 0;
  color: var(--color-foreground);
  background-color: var(--color-background);
}

[data-light] {
  --color-invalid: hsl(356, 70%, 39%);
  color: var(--color-background);
  background-color: var(--color-foreground);
}

body {
  font-family: var(--font-body);
  line-height: 1.5;
  background-repeat: no-repeat;
  min-height: 100vh;
  min-height: calc(100vh - env(safe-area-inset-bottom));
}

a {
  color: var(--color-links);
  text-decoration: none;
}

a:hover {
  color: var(--color-links-hover);
  text-decoration: underline;
}

hr {
  display: block;
  height: 1px;
  border: 0;
  background-color: var(--color-border);
  margin-top: 2rem;
  margin-bottom: 2rem;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: var(--font-display);
  margin: 0;
}

h1 {
  font-size: 2.25rem;
  line-height: 2.5rem;
}

h2 {
  font-size: 1.5rem;
  line-height: 2rem;
}

h3 {
  font-size: 1.25rem;
  line-height: 1.75rem;
}

h4 {
  font-size: 1.125rem;
  line-height: 1.75rem;
}

h5,
h6 {
  font-size: 0.875rem;
  line-height: 1.25rem;
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.container {
  --gutter: 16px;
  width: 1024px;
  max-width: calc(100% - var(--gutter) * 2);
  margin-right: auto;
  margin-left: auto;
}

/* buttons */

.button {
  --shadow-color: hsl(var(--hs-links) 30%);
  --shadow-size: 3px;
  -webkit-appearance: none;
  -moz-appearance: none;
  cursor: pointer;
  appearance: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background-color: var(--color-links);
  color: var(--color-background);
  font-family: var(--font-display);
  font-weight: bold;
  line-height: 1;
  font-size: 1.125rem;
  margin: 0;
  padding: 0.625em 1em;
  border: 0;
  border-radius: 4px;
  box-shadow: 0 var(--shadow-size) 0 0 var(--shadow-color);
  outline-offset: 2px;
  transform: translateY(0);
  transition:
    background-color 50ms ease-out,
    box-shadow 50ms ease-out,
    transform 100ms cubic-bezier(0.3, 0.6, 0.8, 1.25);
}

.button:hover {
  --raise: 1px;
  color: var(--color-background);
  text-decoration: none;
  box-shadow: 0 calc(var(--shadow-size) + var(--raise)) 0 0 var(--shadow-color);
  transform: translateY(calc(var(--raise) * -1));
}

.button:active {
  --press: 1px;
  box-shadow: 0 calc(var(--shadow-size) - var(--press)) 0 0 var(--shadow-color);
  transform: translateY(var(--press));
  background-color: var(--color-links-hover);
}

.button[disabled],
.button[aria-disabled='true'] {
  transform: translateY(0);
  pointer-events: none;
  opacity: 0.7;
}

.button:focus:not(:focus-visible) {
  outline: none;
}

/* forms */

form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  width: 100%;
}

fieldset {
  margin: 0;
  padding: 0;
  border: 0;
}

legend {
  display: block;
  max-width: 100%;
  margin-bottom: 0.5rem;
  color: inherit;
  white-space: normal;
}

[type='text'],
[type='password'],
[type='date'],
[type='datetime'],
[type='datetime-local'],
[type='month'],
[type='week'],
[type='email'],
[type='number'],
[type='search'],
[type='tel'],
[type='time'],
[type='url'],
[type='color'],
textarea {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  display: block;
  display: flex;
  align-items: center;
  width: 100%;
  height: 2.5rem;
  margin: 0;
  padding: 0.5rem 0.75rem;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  background-color: hsl(0 0% 100% / 10%);
  background-blend-mode: luminosity;
  box-shadow: none;
  font-family: var(--font-body);
  font-size: 1rem;
  font-weight: normal;
  line-height: 1.5;
  color: var(--color-foreground);
  transition:
    box-shadow 200ms,
    border-color 50ms ease-out,
    background-color 50ms ease-out,
    color 50ms ease-out;
}

[data-light] [type='text'],
[data-light] [type='password'],
[data-light] [type='date'],
[data-light] [type='datetime'],
[data-light] [type='datetime-local'],
[data-light] [type='month'],
[data-light] [type='week'],
[data-light] [type='email'],
[data-light] [type='number'],
[data-light] [type='search'],
[data-light] [type='tel'],
[data-light] [type='time'],
[data-light] [type='url'],
[data-light] [type='color'],
[data-light] textarea {
  color: var(--color-background);
  background-color: hsl(0 0% 0% / 10%);
}

[type='text'][aria-invalid='true'],
[type='password'][aria-invalid='true'],
[type='date'][aria-invalid='true'],
[type='datetime'][aria-invalid='true'],
[type='datetime-local'][aria-invalid='true'],
[type='month'][aria-invalid='true'],
[type='week'][aria-invalid='true'],
[type='email'][aria-invalid='true'],
[type='number'][aria-invalid='true'],
[type='search'][aria-invalid='true'],
[type='tel'][aria-invalid='true'],
[type='time'][aria-invalid='true'],
[type='url'][aria-invalid='true'],
[type='color'][aria-invalid='true'],
textarea[aria-invalid='true'] {
  border-color: var(--color-invalid);
}

textarea {
  display: block;
  min-height: 50px;
  max-width: 100%;
}

textarea[rows] {
  height: auto;
}

input:disabled,
input[readonly],
textarea:disabled,
textarea[readonly] {
  opacity: 0.7;
  cursor: not-allowed;
}

[type='file'],
[type='checkbox'],
[type='radio'] {
  margin: 0;
}

[type='file'] {
  width: 100%;
}

label {
  margin: 0;
}

[type='checkbox'] + label,
[type='radio'] + label {
  margin-left: 0.5rem;
}

label > [type='checkbox'],
label > [type='radio'] {
  margin-right: 0.5rem;
}

::placeholder {
  color: hsl(0 0% 100% / 65%);
}

.form-validation-error {
  margin: 0;
  margin-top: 0.25em;
  color: var(--color-invalid);
  font-size: 0.8rem;
}

.error-container {
  background-color: hsla(356, 77%, 59%, 0.747);
  border-radius: 0.25rem;
  padding: 0.5rem 1rem;
}
```

</details>

<details>

<summary>üíø Copy this to `app/styles/global-large.css`</summary>

```css filename=app/styles/global-large.css
h1 {
  font-size: 3.75rem;
  line-height: 1;
}

h2 {
  font-size: 1.875rem;
  line-height: 2.25rem;
}

h3 {
  font-size: 1.5rem;
  line-height: 2rem;
}

h4 {
  font-size: 1.25rem;
  line-height: 1.75rem;
}

h5 {
  font-size: 1.125rem;
  line-height: 1.75rem;
}
```

</details>

<details>

<summary>üíø Copy this to `app/styles/global-medium.css`</summary>

```css filename=app/styles/global-medium.css
h1 {
  font-size: 3rem;
  line-height: 1;
}

h2 {
  font-size: 2.25rem;
  line-height: 2.5rem;
}

h3 {
  font-size: 1.25rem;
  line-height: 1.75rem;
}

h4 {
  font-size: 1.125rem;
  line-height: 1.75rem;
}

h5,
h6 {
  font-size: 1rem;
  line-height: 1.5rem;
}

.container {
  --gutter: 40px;
}
```

</details>

<details>

<summary>üíø Copy this to `app/styles/index.css`</summary>

```css filename=app/styles/index.css
/*
 * when the user visits this page, this style will apply, when they leave, it
 * will get unloaded, so don't worry so much about conflicting styles between
 * pages!
 */

body {
  background-image: var(--gradient-background);
}

.container {
  min-height: inherit;
}

.container,
.content {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.content {
  padding-top: 3rem;
  padding-bottom: 3rem;
}

h1 {
  margin: 0;
  text-shadow: 0 3px 0 rgba(0, 0, 0, 0.75);
  text-align: center;
  line-height: 0.5;
}

h1 span {
  display: block;
  font-size: 4.5rem;
  line-height: 1;
  text-transform: uppercase;
  text-shadow:
    0 0.2em 0.5em rgba(0, 0, 0, 0.5),
    0 5px 0 rgba(0, 0, 0, 0.75);
}

nav ul {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  gap: 1rem;
  font-family: var(--font-display);
  font-size: 1.125rem;
  line-height: 1;
}

nav ul a:hover {
  text-decoration-style: wavy;
  text-decoration-thickness: 1px;
}

@media print, (min-width: 640px) {
  h1 span {
    font-size: 6rem;
  }

  nav ul {
    font-size: 1.25rem;
    gap: 1.5rem;
  }
}

@media screen and (min-width: 1024px) {
  h1 span {
    font-size: 8rem;
  }
}
```

</details>

<details>

<summary>üíø Copy this to `app/styles/jokes.css`</summary>

```css filename=app/styles/jokes.css
.jokes-layout {
  display: flex;
  flex-direction: column;
  min-height: inherit;
}

.jokes-header {
  padding-top: 1rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--color-border);
}

.jokes-header .container {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.jokes-header .home-link {
  font-family: var(--font-display);
  font-size: 3rem;
}

.jokes-header .home-link a {
  color: var(--color-foreground);
}

.jokes-header .home-link a:hover {
  text-decoration: none;
}

.jokes-header .logo-medium {
  display: none;
}

.jokes-header a:hover {
  text-decoration-style: wavy;
  text-decoration-thickness: 1px;
}

.jokes-header .user-info {
  display: flex;
  gap: 1rem;
  align-items: center;
  white-space: nowrap;
}

.jokes-main {
  padding-top: 2rem;
  padding-bottom: 2rem;
  flex: 1 1 100%;
}

.jokes-main .container {
  display: flex;
  gap: 1rem;
}

.jokes-list {
  max-width: 12rem;
}

.jokes-outlet {
  flex: 1;
}

.jokes-footer {
  padding-top: 2rem;
  padding-bottom: 1rem;
  border-top: 1px solid var(--color-border);
}

@media print, (min-width: 640px) {
  .jokes-header .logo {
    display: none;
  }

  .jokes-header .logo-medium {
    display: block;
  }

  .jokes-main {
    padding-top: 3rem;
    padding-bottom: 3rem;
  }
}

@media (max-width: 639px) {
  .jokes-main .container {
    flex-direction: column;
  }
}
```

</details>

üíø Also, download <a href="/jokes-tutorial/baloo/baloo.woff" data-noprefetch target="_blank">the font</a> and <a href="/jokes-tutorial/baloo/License.txt" data-noprefetch target="_blank">its license</a> and put them in `public/fonts/baloo`.

üíø While you're downloading assets, you may as well download <a href="/jokes-tutorial/social.png" data-noprefetch target="_blank">the social image</a> and put that at `public/social.png`. You'll need that later.

üíø Add the `links` export to `app/root.tsx` and `app/routes/jokes.tsx` to bring in some CSS to make the page look nice (note: each will have its own CSS file(s)). You can look at the CSS and add some structure to your JSX elements to make things look appealing. I'm going to add some links too.

<docs-info>The `app/root.tsx` will be the one that links to the `global` CSS files. Why do you think the name "global" makes sense for the root route's styles?</docs-info>

The `global-large.css` and `global-medium.css` files are for media query-based CSS.

<docs-info>Did you know that `<link />` tags can use media queries? [Check out the MDN page for `<link />`][check-out-the-mdn-page-for-link].</docs-info>

<details>

<summary>app/root.tsx</summary>

```tsx filename=app/root.tsx lines=[1,8-10,12-24]
import type { LinksFunction } from '@remix-run/node';
import { Links, LiveReload, Outlet } from '@remix-run/react';

import globalLargeStylesUrl from '@/styles/global-large.css';
import globalMediumStylesUrl from '@/styles/global-medium.css';
import globalStylesUrl from '@/styles/global.css';

export const links: LinksFunction = () => [
  { rel: 'stylesheet', href: globalStylesUrl },
  {
    rel: 'stylesheet',
    href: globalMediumStylesUrl,
    media: 'print, (min-width: 640px)',
  },
  {
    rel: 'stylesheet',
    href: globalLargeStylesUrl,
    media: 'screen and (min-width: 1024px)',
  },
];

export default function App() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Remix: So great, it's funny!</title>
        <Links />
      </head>
      <body>
        <Outlet />
        <LiveReload />
      </body>
    </html>
  );
}
```

</details>

<details>

<summary>app/routes/jokes.tsx</summary>

```tsx filename=app/routes/jokes.tsx lines=[1,4,6-8]
import type { LinksFunction } from '@remix-run/node';
import { Link, Outlet } from '@remix-run/react';

import stylesUrl from '@/styles/jokes.css';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

export default function JokesRoute() {
  return (
    <div className="jokes-layout">
      <header className="jokes-header">
        <div className="container">
          <h1 className="home-link">
            <Link to="/" title="Remix Jokes" aria-label="Remix Jokes">
              <span className="logo">ü§™</span>
              <span className="logo-medium">Jü§™KES</span>
            </Link>
          </h1>
        </div>
      </header>
      <main className="jokes-main">
        <div className="container">
          <div className="jokes-list">
            <Link to=".">Get a random joke</Link>
            <p>Here are a few more jokes to check out:</p>
            <ul>
              <li>
                <Link to="some-joke-id">Hippo</Link>
              </li>
            </ul>
            <Link to="new" className="button">
              Add your own
            </Link>
          </div>
          <div className="jokes-outlet">
            <Outlet />
          </div>
        </div>
      </main>
    </div>
  );
}
```

</details>

üíø Let's also add a link to the jokes from the homepage and follow some class names in the CSS to make the homepage look nice.

<details>

<summary>app/routes/_index.tsx</summary>

```tsx filename=app/routes/_index.tsx lines=[2,11-26]
import type { LinksFunction } from '@remix-run/node';
import { Link } from '@remix-run/react';

import stylesUrl from '@/styles/index.css';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

export default function IndexRoute() {
  return (
    <div className="container">
      <div className="content">
        <h1>
          Remix <span>Jokes!</span>
        </h1>
        <nav>
          <ul>
            <li>
              <Link to="jokes">Read Jokes</Link>
            </li>
          </ul>
        </nav>
      </div>
    </div>
  );
}
```

</details>

As we work through the rest of the tutorial, you may want to check the class names in those CSS files, so you can take full advantage of that CSS.

One quick note about CSS. A lot of you folks may be used to using runtime libraries for CSS (like [Styled-Components][styled-components]). While you can use those with Remix, we'd like to encourage you to look into more traditional approaches to CSS. Many of the problems that led to the creation of these styling solutions aren't really problems in Remix, so you can often go with a simpler styling approach.

That said, many Remix users are very happy with [Tailwind CSS][tailwind], and we recommend this approach. Basically, if it can give you a URL (or a CSS file which you can import to get a URL), then it's generally a good approach because Remix can then leverage the browser platform for caching and loading/unloading.

## Database

Most real-world applications require some form of data persistence. In our case, we want to save our jokes to a database so people can laugh at our hilarity and even submit their own (coming soon in the authentication section!).

You can use any persistence solution you like with Remix; [Firebase][firebase], [Supabase][supabase], [Airtable][airtable], [Hasura][hasura], [Google Spreadsheets][google-spreadsheets], [Cloudflare Workers KV][cloudflare-workers-kv], [Fauna][fauna], a custom [PostgreSQL][postgre-sql], or even your backend team's REST/GraphQL APIs. Seriously. Whatever you want.

### Set up Prisma

<docs-info>The Prisma team has built [a VSCode extension][a-vs-code-extension] you might find quite helpful when working on the Prisma schema.</docs-info>

In this tutorial we're going to use our own [SQLite][sq-lite] database. Essentially, it's a database that lives in a file on your computer, is surprisingly capable, and best of all it's supported by [Prisma][prisma], our favorite database ORM! It's a great place to start if you're not sure what database to use.

There are two packages that we need to get started:

- `prisma` for interacting with our database and schema during development.
- `@prisma/client` for making queries to our database during runtime.

üíø Install the Prisma packages:

```shellscript nonumber
npm install --save-dev prisma
npm install @prisma/client
```

üíø Now we can initialize Prisma with SQLite:

```shellscript nonumber
npx prisma init --datasource-provider sqlite
```

That gives us this output:

```
‚úî Your Prisma schema was created at prisma/schema.prisma
  You can now open it in your favorite editor.

warn You already have a .gitignore file. Don't forget to add `.env` in it to not commit any private information.

Next steps:
1. Set the DATABASE_URL in the .env file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started
2. Run prisma db pull to turn your database schema into a Prisma schema.
3. Run prisma generate to generate the Prisma Client. You can then start querying your database.

More information in our documentation:
https://pris.ly/d/getting-started
```

Now that we've got Prisma initialized, we can start modeling our app data. Because this isn't a Prisma tutorial, I'll just hand you that, and you can read more about the Prisma schema from [their docs][their-docs]:

```prisma filename=prisma/schema.prisma lines=[13-19]
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Joke {
  id         String   @id @default(uuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  name       String
  content    String
}
```

üíø With that in place, run this:

```shellscript nonumber
npx prisma db push
```

This command will give you this output:

```
Environment variables loaded from .env
Prisma schema loaded from prisma/schema.prisma
Datasource "db": SQLite database "dev.db" at "file:./dev.db"

SQLite database dev.db created at file:./dev.db

üöÄ  Your database is now in sync with your Prisma schema. Done in 39ms

‚úî Generated Prisma Client (4.12.0 | library) to ./node_modules/@prisma/client in 26ms
```

This command did a few things. For one, it created our database file in `prisma/dev.db`. Then it pushed all the necessary changes to our database to match the schema we provided. Finally, it generated Prisma's TypeScript types, so we'll get stellar autocomplete and type checking as we use its API for interacting with our database.

üíø Let's add that `prisma/dev.db` to our `.gitignore` so we don't accidentally commit it to our repository. As mentioned in the Prisma output, we don't want to commit our secrets, so your `.env` file is already added to the `.gitignore` out of the box!

```text filename=.gitignore lines=[8]
node_modules

/.cache
/build
/public/build
.env

/prisma/dev.db
```

<docs-warning>If your database gets messed up, you can always delete the `prisma/dev.db` file and run `npx prisma db push` again.</docs-warning>

Next, we're going to write a little file that will "seed" our database with test data. Again, this isn't really remix-specific stuff, so I'll just give this to you (don't worry, we'll get back to remix soon):

üíø Copy this into a new file called `prisma/seed.ts`

```ts filename=prisma/seed.ts
import { PrismaClient } from '@prisma/client';
const db = new PrismaClient();

async function seed() {
  await Promise.all(
    getJokes().map((joke) => {
      return db.joke.create({ data: joke });
    }),
  );
}

seed();

function getJokes() {
  // shout-out to https://icanhazdadjoke.com/

  return [
    {
      name: 'Road worker',
      content: `I never wanted to believe that my Dad was stealing from his job as a road worker. But when I got home, all the signs were there.`,
    },
    {
      name: 'Frisbee',
      content: `I was wondering why the frisbee was getting bigger, then it hit me.`,
    },
    {
      name: 'Trees',
      content: `Why do trees seem suspicious on sunny days? Dunno, they're just a bit shady.`,
    },
    {
      name: 'Skeletons',
      content: `Why don't skeletons ride roller coasters? They don't have the stomach for it.`,
    },
    {
      name: 'Hippos',
      content: `Why don't you find hippopotamuses hiding in trees? They're really good at it.`,
    },
    {
      name: 'Dinner',
      content: `What did one plate say to the other plate? Dinner is on me!`,
    },
    {
      name: 'Elevator',
      content: `My first time using an elevator was an uplifting experience. The second time let me down.`,
    },
  ];
}
```

Feel free to add your own jokes if you like.

Now we just need to run this file. We wrote it in TypeScript to get type safety (this is much more useful as our app and data models grow in complexity). So we'll need a way to run it.

üíø Install `ts-node` and `tsconfig-paths` as dev dependencies:

```shellscript nonumber
npm install --save-dev ts-node tsconfig-paths
```

üíø And now we can run our `seed.ts` file with that:

```shellscript nonumber
npx ts-node --require tsconfig-paths/register prisma/seed.ts
```

Now our database has those jokes in it. No joke!

But I don't want to have to remember to run that script any time I reset the database. Luckily, we don't have to!

üíø Add this to your `package.json`:

```json filename=package.json nocopy
{
  "prisma": {
    "seed": "ts-node --require tsconfig-paths/register prisma/seed.ts"
  }
}
```

Now, whenever we reset the database, Prisma will call our seeding file as well.

### Connect to the database

Ok, one last thing we need to do is connect to the database in our app. We do this at the top of our `prisma/seed.ts` file:

```ts nocopy
import { PrismaClient } from '@prisma/client';
const db = new PrismaClient();
```

This works just fine, but the problem is, during development, we don't want to close down and completely restart our server every time we make a server-side change. So `@remix-run/serve` actually rebuilds our code and requires it brand new. The problem here is that every time we make a code change, we'll make a new connection to the database and eventually run out of connections! This is such a common problem with database-accessing apps that Prisma has a warning for it:

> Warning: 10 Prisma Clients are already running

So we've got a bit of extra work to do to avoid this development time problem.

Note that this isn't a remix-only problem. Any time you have "live reload" of server code, you're going to have to either disconnect and reconnect to databases (which can be slow) or use the [`global` singleton workaround][global-singleton-workaround].

üíø Copy this into two new files called `app/utils/singleton.server.ts` & `app/utils/db.server.ts`

```ts filename=app/utils/singleton.server.ts
export const singleton = <Value>(name: string, valueFactory: () => Value): Value => {
  const g = global as any;
  g.__singletons ??= {};
  g.__singletons[name] ??= valueFactory();
  return g.__singletons[name];
};
```

```ts filename=app/utils/db.server.ts
import { PrismaClient } from '@prisma/client';

import { singleton } from './singleton.server';

// Hard-code a unique key, so we can look up the client when this module gets re-imported
export const db = singleton('prisma', () => new PrismaClient());
```

I'll leave analysis of this code as an exercise for the reader because again, this has nothing to do with Remix directly.

The one thing that I will call out is the file name convention. The `.server` part of the filename informs Remix that this code should never end up in the browser. This is optional, because Remix does a good job of ensuring server code doesn't end up in the client. But sometimes some server-only dependencies are difficult to treeshake, so adding the `.server` to the filename is a hint to the compiler to not worry about this module or its imports when bundling for the browser. The `.server` acts as a sort of boundary for the compiler.

### Read from the database in a Remix loader

Ok, ready to get back to writing Remix code? Me too!

Our goal is to put a list of jokes on the `/jokes` route, so we can have a list of links to jokes people can choose from. In Remix, each route module is responsible for getting its own data. So if we want data on the `/jokes` route, then we'll be updating the `app/routes/jokes.tsx` file.

To _load_ data in a Remix route module, you use a [`loader`][loader]. This is simply an `async` function you export that returns a response, and is accessed on the component through the [`useLoaderData`][use-loader-data] hook. Here's a quick example:

```tsx nocopy
// this is just an example. No need to copy/paste this üòÑ
import { json } from '@remix-run/node';
import { useLoaderData } from '@remix-run/react';

import { db } from '@/utils/db.server';

export const loader = async () => {
  return json({
    sandwiches: await db.sandwich.findMany(),
  });
};

export default function Sandwiches() {
  const data = useLoaderData<typeof loader>();
  return (
    <ul>
      {data.sandwiches.map((sandwich) => (
        <li key={sandwich.id}>{sandwich.name}</li>
      ))}
    </ul>
  );
}
```

Does that give you a good idea of what to do here? If not, you can take a look at my solution in the `<details>` below üòÑ

<docs-info>

Remix and the `tsconfig.json` you get from the starter template are configured to allow imports from the `app/` directory via `~` as demonstrated above, so you don't have `../../` all over the place.

</docs-info>

üíø Update the `app/routes/jokes.tsx` route module to load jokes from our database and render a list of links to the jokes.

<details>

<summary>app/routes/jokes.tsx</summary>

```tsx filename=app/routes/jokes.tsx lines=[2,6,10,16-20,23,47-51]
import type { LinksFunction } from '@remix-run/node';
import { json } from '@remix-run/node';
import { Link, Outlet, useLoaderData } from '@remix-run/react';

import stylesUrl from '@/styles/jokes.css';
import { db } from '@/utils/db.server';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

export const loader = async () => {
  return json({
    jokeListItems: await db.joke.findMany(),
  });
};

export default function JokesRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div className="jokes-layout">
      <header className="jokes-header">
        <div className="container">
          <h1 className="home-link">
            <Link to="/" title="Remix Jokes" aria-label="Remix Jokes">
              <span className="logo">ü§™</span>
              <span className="logo-medium">Jü§™KES</span>
            </Link>
          </h1>
        </div>
      </header>
      <main className="jokes-main">
        <div className="container">
          <div className="jokes-list">
            <Link to=".">Get a random joke</Link>
            <p>Here are a few more jokes to check out:</p>
            <ul>
              {data.jokeListItems.map(({ id, name }) => (
                <li key={id}>
                  <Link to={id}>{name}</Link>
                </li>
              ))}
            </ul>
            <Link to="new" className="button">
              Add your own
            </Link>
          </div>
          <div className="jokes-outlet">
            <Outlet />
          </div>
        </div>
      </main>
    </div>
  );
}
```

</details>

And here's what we have with that now:

![List of links to jokes][list-of-links-to-jokes]

### Data overfetching

I want to call out something specific in my solution. Here's my loader:

```tsx lines=[3-7]
export const loader = async () => {
  return json({
    jokeListItems: await db.joke.findMany({
      orderBy: { createdAt: 'desc' },
      select: { id: true, name: true },
      take: 5,
    }),
  });
};
```

Notice that all I need for this page is the joke `id` and `name`. I don't need to bother getting the `content`. I'm also limiting to a total of 5 items and ordering by creation date, so we get the latest jokes. So with `prisma`, I can change my query to be exactly what I need and avoid sending too much data to the client! That makes my app faster and more responsive for my users.

And to make it even cooler, you don't necessarily need Prisma or direct database access to do this. You've got a GraphQL backend you're hitting? Sweet, use your regular GraphQL stuff in your loader. It's even better than doing it on the client because you don't need to worry about shipping a [huge GraphQL client][huge-graphql-client] to the client. Keep that on your server and filter down to what you want.

Oh, you've just got REST endpoints you hit? That's fine too! You can easily filter out the extra data before sending it off in your loader. Because it all happens on the server, you can save your user's download size easily without having to convince your backend engineers to change their entire API. Neat!

Filtering out data you don't render isn't just about sending less over the wire, you should also filter out any sensitive data you don't want exposed to the client.

<docs-error>
Whatever you return from your loader will be exposed to the client, even if the component doesn't render it. Treat your loaders with the same care as public API endpoints.
</docs-error>

### Network Type Safety

In our code we're using the `useLoaderData`'s type generic and pass our `loader` so we can get nice auto-complete, but it's not _really_ getting us type safety because the `loader` and the `useLoaderData` are running in completely different environments. Remix ensures we get what the server sent, but who really knows? Maybe in a fit of rage, your co-worker set up your server to automatically remove references to dogs (they prefer cats).

So the only way to really be 100% positive that your data is correct, you should use [assertion functions][assertion-functions] on the `data` you get back from `useLoaderData`. That's outside the scope of this tutorial, but we're fans of [zod][zod] which can aid in this.

### Wrap up database queries

Before we get to the `/jokes/:jokeId` route, here's a quick example of how you can access params (like `:jokeId`) in your loader.

```tsx nocopy
export const loader = async ({ params }: LoaderFunctionArgs) => {
  console.log(params); // <-- {jokeId: "123"}
};
```

And here's how you get the joke from Prisma:

```tsx nocopy
const joke = await db.joke.findUnique({
  where: { id: jokeId },
});
```

<docs-warning>Remember, when we're referencing the URL route, it's `/jokes/:jokeId`, and when we talk about the file system it's `/app/routes/jokes.$jokeId.tsx`.</docs-warning>

üíø Great! Now you know everything you need to continue and connect the `/jokes/:jokeId` route in `app/routes/jokes.$jokeId.tsx`.

<details>

<summary>app/routes/jokes.$jokeId.tsx</summary>

```tsx filename=app/routes/jokes.$jokeId.tsx lines=[1-3,5,7-17,20,25-26]
import type { LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import { Link, useLoaderData } from '@remix-run/react';

import { db } from '@/utils/db.server';

export const loader = async ({ params }: LoaderFunctionArgs) => {
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Error('Joke not found');
  }
  return json({ joke });
};

export default function JokeRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div>
      <p>Here's your hilarious joke:</p>
      <p>{data.joke.content}</p>
      <Link to=".">"{data.joke.name}" Permalink</Link>
    </div>
  );
}
```

</details>

With that you should be able to go to [`/jokes`][jokes] and click on a link to get the joke:

![Jokes page showing a unique joke][jokes-page-showing-a-unique-joke]

We'll handle the case where someone tries to access a joke that doesn't exist in the database in the next section.

Next, let's handle the `/jokes` index route in `app/routes/jokes._index.tsx` that shows a random joke.

Here's how you get a random joke from Prisma:

```tsx
const count = await db.joke.count();
const randomRowNumber = Math.floor(Math.random() * count);
const [randomJoke] = await db.joke.findMany({
  skip: randomRowNumber,
  take: 1,
});
```

üíø You should be able to get the loader working from there.

<details>

<summary>app/routes/jokes._index.tsx</summary>

```tsx filename=app/routes/jokes._index.tsx lines=[1-2,4,6-14,17,22-25]
import { json } from '@remix-run/node';
import { Link, useLoaderData } from '@remix-run/react';

import { db } from '@/utils/db.server';

export const loader = async () => {
  const count = await db.joke.count();
  const randomRowNumber = Math.floor(Math.random() * count);
  const [randomJoke] = await db.joke.findMany({
    skip: randomRowNumber,
    take: 1,
  });
  return json({ randomJoke });
};

export default function JokesIndexRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div>
      <p>Here's a random joke:</p>
      <p>{data.randomJoke.content}</p>
      <Link to={data.randomJoke.id}>"{data.randomJoke.name}" Permalink</Link>
    </div>
  );
}
```

</details>

With that your [`/jokes`][jokes] route should display a list of links to jokes as well as a random joke:

![Jokes page showing a random joke][jokes-page-showing-a-random-joke]

## Mutations

We've got ourselves a `/jokes/new` route, but that form doesn't do anything yet. Let's wire it up! As a reminder here's what that code should look like right now (the `method="post"` is important so make sure yours has it):

```tsx filename=app/routes/jokes.new.tsx
export default function NewJokeRoute() {
  return (
    <div>
      <p>Add your own hilarious joke</p>
      <form method="post">
        <div>
          <label>
            Name: <input type="text" name="name" />
          </label>
        </div>
        <div>
          <label>
            Content: <textarea name="content" />
          </label>
        </div>
        <div>
          <button type="submit" className="button">
            Add
          </button>
        </div>
      </form>
    </div>
  );
}
```

Not much there. Just a form. What if I told you that you could make that form work with a single export to the route module? Well you can! It's the [`action`][action] function export! Read up on that a bit.

Here's the Prisma code you'll need:

```tsx
const joke = await db.joke.create({
  data: { name, content },
});
```

üíø Create an `action` in `app/routes/jokes.new.tsx`.

<details>

<summary>app/routes/jokes.new.tsx</summary>

```tsx filename=app/routes/jokes.new.tsx lines=[1-2,4,6-25]
import type { ActionFunctionArgs } from '@remix-run/node';
import { redirect } from '@remix-run/node';

import { db } from '@/utils/db.server';

export const action = async ({ request }: ActionFunctionArgs) => {
  const form = await request.formData();
  const content = form.get('content');
  const name = form.get('name');
  // we do this type check to be extra sure and to make TypeScript happy
  // we'll explore validation next!
  if (typeof content !== 'string' || typeof name !== 'string') {
    throw new Error('Form not submitted correctly.');
  }

  const fields = { content, name };

  const joke = await db.joke.create({ data: fields });
  return redirect(`/jokes/${joke.id}`);
};

export default function NewJokeRoute() {
  return (
    <div>
      <p>Add your own hilarious joke</p>
      <form method="post">
        <div>
          <label>
            Name: <input type="text" name="name" />
          </label>
        </div>
        <div>
          <label>
            Content: <textarea name="content" />
          </label>
        </div>
        <div>
          <button type="submit" className="button">
            Add
          </button>
        </div>
      </form>
    </div>
  );
}
```

</details>

If you've got that working, you should be able to create new jokes and be redirected to the new joke's page.

<docs-info>

The `redirect` utility is a simple utility in Remix for creating a [`Response`][response] object that has the right headers/status codes to redirect the user.

</docs-info>

![Create new joke form filled out][create-new-joke-form-filled-out]

![Newly created joke displayed][newly-created-joke-displayed]

Hooray! How cool is that? No `useEffect` or `useAnything` hooks. Just a form, and an async function to process the submission. Pretty cool. You can definitely still do all that stuff if you wanted to, but why would you? This is really nice.

Another thing you'll notice is that when we were redirected to the joke's new page, it was there! But we didn't have to think about updating the cache at all. Remix handles invalidating the cache for us automatically. You don't have to think about it. _That_ is cool üòé

Why don't we add some validation? We could definitely do the typical React validation approach. Wiring up `useState` with `onChange` handlers and such. And sometimes that's nice to get some real-time validation as the user's typing. But even if you do all that work, you're still going to want to do validation on the server.

Before I set you off on this one, there's one more thing you need to know about route module `action` functions. The return value is expected to be the same as the `loader` function: A `Response`, or (as a convenience) a serializable JavaScript object. Normally you want to `redirect` when the action is successful to avoid the annoying "confirm resubmission" dialog you might have seen on some websites.

<!-- TODO: add a page about why `redirect`ing is better for successful actions and link it here. -->

But if there's an error, you can return an object with the error messages and then the component can get those values from [`useActionData`][use-action-data] and display them to the user.

üíø Go ahead and validate that the `name` and `content` fields are long enough. I'd say the name should be at least 3 characters long and the content should be at least 10 characters long. Do this validation server-side.

<details>

<summary>app/routes/jokes.new.tsx</summary>

```tsx filename=app/routes/jokes.new.tsx lines=[3,6,8-12,14-18,30-34,37-40,42-48,55,65,68-75,78-86,92,94-101,104-112,115-122]
import type { ActionFunctionArgs } from '@remix-run/node';
import { redirect } from '@remix-run/node';
import { useActionData } from '@remix-run/react';

import { db } from '@/utils/db.server';
import { badRequest } from '@/utils/request.server';

function validateJokeContent(content: string) {
  if (content.length < 10) {
    return 'That joke is too short';
  }
}

function validateJokeName(name: string) {
  if (name.length < 3) {
    return "That joke's name is too short";
  }
}

export const action = async ({ request }: ActionFunctionArgs) => {
  const form = await request.formData();
  const content = form.get('content');
  const name = form.get('name');
  if (typeof content !== 'string' || typeof name !== 'string') {
    return badRequest({
      fieldErrors: null,
      fields: null,
      formError: 'Form not submitted correctly.',
    });
  }

  const fieldErrors = {
    content: validateJokeContent(content),
    name: validateJokeName(name),
  };
  const fields = { content, name };
  if (Object.values(fieldErrors).some(Boolean)) {
    return badRequest({
      fieldErrors,
      fields,
      formError: null,
    });
  }

  const joke = await db.joke.create({ data: fields });
  return redirect(`/jokes/${joke.id}`);
};

export default function NewJokeRoute() {
  const actionData = useActionData<typeof action>();

  return (
    <div>
      <p>Add your own hilarious joke</p>
      <form method="post">
        <div>
          <label>
            Name:{' '}
            <input
              defaultValue={actionData?.fields?.name}
              name="name"
              type="text"
              aria-invalid={Boolean(actionData?.fieldErrors?.name)}
              aria-errormessage={actionData?.fieldErrors?.name ? 'name-error' : undefined}
            />
          </label>
          {actionData?.fieldErrors?.name ? (
            <p className="form-validation-error" id="name-error" role="alert">
              {actionData.fieldErrors.name}
            </p>
          ) : null}
        </div>
        <div>
          <label>
            Content:{' '}
            <textarea
              defaultValue={actionData?.fields?.content}
              name="content"
              aria-invalid={Boolean(actionData?.fieldErrors?.content)}
              aria-errormessage={actionData?.fieldErrors?.content ? 'content-error' : undefined}
            />
          </label>
          {actionData?.fieldErrors?.content ? (
            <p className="form-validation-error" id="content-error" role="alert">
              {actionData.fieldErrors.content}
            </p>
          ) : null}
        </div>
        <div>
          {actionData?.formError ? (
            <p className="form-validation-error" role="alert">
              {actionData.formError}
            </p>
          ) : null}
          <button type="submit" className="button">
            Add
          </button>
        </div>
      </form>
    </div>
  );
}
```

</details>

<details>

<summary>app/utils/request.server.ts</summary>

```ts filename=app/utils/request.server.ts
import { json } from '@remix-run/node';

/**
 * This helper function helps us to return the accurate HTTP status,
 * 400 Bad Request, to the client.
 */
export const badRequest = <T>(data: T) => json<T>(data, { status: 400 });
```

</details>

Great! You should now have a form that validates the fields on the server and displays those errors on the client:

![New joke form with validation errors][new-joke-form-with-validation-errors]

Why don't you pop open my code example for a second? I want to show you a few things about the way I'm doing this.

First I want you to notice that I've passed `typeof action` to the `useActionData` generic function. This way, `actionData` type will properly be inferred, and we'll get some type safety. Keep in mind that `useActionData` can return `undefined` if the action hasn't been called yet, so we've got a bit of defensive programming going on there.

You may also notice that I return the fields as well. This is so that the form can be re-rendered with the values from the server in the event that JavaScript fails to load for some reason. That's what the `defaultValue` stuff is all about as well.

The `badRequest` helper function will automatically infer the type of the passed data, while still returning the accurate HTTP status, [`400 Bad Request`][400-bad-request], to the client. If we just used `json()` without specifying the status, that would result in a `200 OK` response, which isn't suitable since the form submission had errors.

Another thing I want to call out is how all of this is just so nice and declarative. You don't have to think about state at all here. Your action gets some data, you process it and return a value. The component consumes the action data and renders based on that value. No managing state here. No thinking about race conditions. Nothing.

Oh, and if you _do_ want to have client-side validation (for while the user is typing), you can simply call the `validateJokeContent` and `validateJokeName` functions that the action is using. You can _actually_ seamlessly share code between the client and server! Now _that_ is cool!

## Authentication

It's the moment we've all been waiting for! We're going to add authentication to our little application. The reason we want to add authentication is so jokes can be associated to the users who created them.

One thing that would be good to understand for this section is how [HTTP cookies][http-cookies] work on the web.

We're going to handroll our own authentication from scratch. Don't worry, I promise it's not as scary as it sounds.

### Preparing the database

<docs-warning>Remember, if your database gets messed up, you can always delete the `prisma/dev.db` file and run `npx prisma db push` again. Remember to also restart your dev server with `npm run dev`.</docs-warning>

Let's start by showing you our updated `prisma/schema.prisma` file.

üíø Go ahead and update your `prisma/schema.prisma` file to look like this:

```prisma filename=prisma/schema.prisma lines=[13-20,24-25]
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(uuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  username     String   @unique
  passwordHash String
  jokes        Joke[]
}

model Joke {
  id         String   @id @default(uuid())
  jokesterId String
  jokester   User     @relation(fields: [jokesterId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  name       String
  content    String
}
```

With that updated, let's go ahead and reset our database to this schema:

üíø Run this:

```shellscript nonumber
npx prisma db push
```

It will prompt you to reset the database, hit "y" to confirm.

That will give you this output:

```
Environment variables loaded from .env
Prisma schema loaded from prisma/schema.prisma
Datasource "db": SQLite database "dev.db" at "file:./dev.db"


‚ö†Ô∏è We found changes that cannot be executed:

  ‚Ä¢ Added the required column `jokesterId` to the `Joke` table without a default value. There are 9 rows in this table, it is not possible to execute this step.


‚úî To apply this change we need to reset the database, do you want to continue? All data will be lost. ‚Ä¶ yes
The SQLite database "dev.db" from "file:./dev.db" was successfully reset.

üöÄ  Your database is now in sync with your Prisma schema. Done in 1.56s

‚úî Generated Prisma Client (4.12.0 | library) to ./node_modules/@prisma/client in 34ms
```

With this change, we're going to start experiencing some TypeScript errors in our project because you can no longer create a `joke` without a `jokesterId` value.

üíø Let's start by fixing our `prisma/seed.ts` file.

```ts filename=prisma/seed.ts lines=[5-12,15-16]
import { PrismaClient } from '@prisma/client';
const db = new PrismaClient();

async function seed() {
  const kody = await db.user.create({
    data: {
      username: 'kody',
      // this is a hashed version of "twixrox"
      passwordHash: '$2b$10$K7L1OJ45/4Y2nIvhRVpCe.FSmhDdWoXehVzJptJ/op0lSsvqNu/1u',
    },
  });
  await Promise.all(
    getJokes().map((joke) => {
      const data = { jokesterId: kody.id, ...joke };
      return db.joke.create({ data });
    }),
  );
}

seed();

function getJokes() {
  // shout-out to https://icanhazdadjoke.com/

  return [
    {
      name: 'Road worker',
      content: `I never wanted to believe that my Dad was stealing from his job as a road worker. But when I got home, all the signs were there.`,
    },
    {
      name: 'Frisbee',
      content: `I was wondering why the frisbee was getting bigger, then it hit me.`,
    },
    {
      name: 'Trees',
      content: `Why do trees seem suspicious on sunny days? Dunno, they're just a bit shady.`,
    },
    {
      name: 'Skeletons',
      content: `Why don't skeletons ride roller coasters? They don't have the stomach for it.`,
    },
    {
      name: 'Hippos',
      content: `Why don't you find hippopotamuses hiding in trees? They're really good at it.`,
    },
    {
      name: 'Dinner',
      content: `What did one plate say to the other plate? Dinner is on me!`,
    },
    {
      name: 'Elevator',
      content: `My first time using an elevator was an uplifting experience. The second time let me down.`,
    },
  ];
}
```

üíø Great, now run the seed again:

```shellscript nonumber
npx prisma db seed
```

And that outputs:

```
Environment variables loaded from .env
Running seed command `ts-node --require tsconfig-paths/register prisma/seed.ts` ...

üå±  The seed command has been executed.
```

Great! Our database is now ready to go.

### Auth Flow Overview

So our authentication will be of the traditional username/password variety. We'll be using [`bcryptjs`][bcryptjs] to hash our passwords so nobody will be able to reasonably brute-force their way into an account.

üíø Go ahead and get that installed right now, so we don't forget:

```shellscript nonumber
npm install bcryptjs
```

üíø The `bcryptjs` library has TypeScript definitions in DefinitelyTyped, so let's install those as well:

```shellscript nonumber
npm install --save-dev @types/bcryptjs
```

Let me give you a quick diagram of the flow of things:

![Excalidraw Authentication diagram][excalidraw-authentication-diagram]

Here's that written out:

- On the `/login` route.
- User submits login form.
- Form data is validated.
  - If the form data is invalid, return the form with the errors.
- Login type is "register"
  - Check whether the username is available
    - If the username is not available, return the form with an error.
  - Hash the password
  - Create a new user
- Login type is "login"
  - Check whether the user exists
    - If the user doesn't exist, return the form with an error.
  - Check whether the password hash matches
    - If the password hash doesn't match, return the form with an error.
- Create a new session
- Redirect to the `/jokes` route with the `Set-Cookie` header.

### Build the login form

Alright, enough high-level stuff. Let's start writing some Remix code!

We're going to create a login page, and I've got some CSS for you to use on that page:

<details>

<summary>üíø Copy this CSS into `app/styles/login.css`</summary>

```css
/*
 * when the user visits this page, this style will apply, when they leave, it
 * will get unloaded, so don't worry so much about conflicting styles between
 * pages!
 */

body {
  background-image: var(--gradient-background);
}

.container {
  min-height: inherit;
}

.container,
.content {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.content {
  padding: 1rem;
  background-color: hsl(0, 0%, 100%);
  border-radius: 5px;
  box-shadow: 0 0.2rem 1rem rgba(0, 0, 0, 0.5);
  width: 400px;
  max-width: 100%;
}

@media print, (min-width: 640px) {
  .content {
    padding: 2rem;
    border-radius: 8px;
  }
}

h1 {
  margin-top: 0;
}

fieldset {
  display: flex;
  justify-content: center;
}

fieldset > :not(:last-child) {
  margin-right: 2rem;
}

.links ul {
  margin-top: 1rem;
  padding: 0;
  list-style: none;
  display: flex;
  gap: 1.5rem;
  align-items: center;
}

.links a:hover {
  text-decoration-style: wavy;
  text-decoration-thickness: 1px;
}
```

</details>

üíø Create a `/login` route by adding a `app/routes/login.tsx` file.

<details>

<summary>app/routes/login.tsx</summary>

```tsx filename=app/routes/login.tsx
import type { LinksFunction } from '@remix-run/node';
import { Link, useSearchParams } from '@remix-run/react';

import stylesUrl from '@/styles/login.css';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

export default function Login() {
  const [searchParams] = useSearchParams();
  return (
    <div className="container">
      <div className="content" data-light="">
        <h1>Login</h1>
        <form method="post">
          <input
            type="hidden"
            name="redirectTo"
            value={searchParams.get('redirectTo') ?? undefined}
          />
          <fieldset>
            <legend className="sr-only">Login or Register?</legend>
            <label>
              <input type="radio" name="loginType" value="login" defaultChecked /> Login
            </label>
            <label>
              <input type="radio" name="loginType" value="register" /> Register
            </label>
          </fieldset>
          <div>
            <label htmlFor="username-input">Username</label>
            <input type="text" id="username-input" name="username" />
          </div>
          <div>
            <label htmlFor="password-input">Password</label>
            <input id="password-input" name="password" type="password" />
          </div>
          <button type="submit" className="button">
            Submit
          </button>
        </form>
      </div>
      <div className="links">
        <ul>
          <li>
            <Link to="/">Home</Link>
          </li>
          <li>
            <Link to="/jokes">Jokes</Link>
          </li>
        </ul>
      </div>
    </div>
  );
}
```

</details>

This should look something like this:

![A login form with a login/register radio button and username/password fields and a submit button][a-login-form-with-a-login-register-radio-button-and-username-password-fields-and-a-submit-button]

Notice in my solution I'm using `useSearchParams` to get the `redirectTo` query parameter and putting that in a hidden input. This way our `action` can know where to redirect the user. This will be useful later when we redirect a user to the login page.

Great, now that we've got the UI looking nice, let's add some logic. This will be very similar to the sort of thing we did in the `/jokes/new` route. Fill in as much as you can (validation and stuff) and we'll just leave comments for the parts of the logic we don't have implemented yet (like _actually_ registering/logging in).

üíø Implement validation with an `action` in `app/routes/login.tsx`

<details>

<summary>app/routes/login.tsx</summary>

```tsx filename=app/routes/login.tsx lines=[2,7,12-13,19-23,25-29,31-37,39-112,115,138-141,150-153,164-172,174-182,190-198,200-208,210-219]
import type { ActionFunctionArgs, LinksFunction } from '@remix-run/node';
import { Link, useActionData, useSearchParams } from '@remix-run/react';

import stylesUrl from '@/styles/login.css';
import { db } from '@/utils/db.server';
import { badRequest } from '@/utils/request.server';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

function validateUsername(username: string) {
  if (username.length < 3) {
    return 'Usernames must be at least 3 characters long';
  }
}

function validatePassword(password: string) {
  if (password.length < 6) {
    return 'Passwords must be at least 6 characters long';
  }
}

function validateUrl(url: string) {
  const urls = ['/jokes', '/', 'https://remix.run'];
  if (urls.includes(url)) {
    return url;
  }
  return '/jokes';
}

export const action = async ({ request }: ActionFunctionArgs) => {
  const form = await request.formData();
  const loginType = form.get('loginType');
  const password = form.get('password');
  const username = form.get('username');
  const redirectTo = validateUrl((form.get('redirectTo') as string) || '/jokes');
  if (
    typeof loginType !== 'string' ||
    typeof password !== 'string' ||
    typeof username !== 'string'
  ) {
    return badRequest({
      fieldErrors: null,
      fields: null,
      formError: 'Form not submitted correctly.',
    });
  }

  const fields = { loginType, password, username };
  const fieldErrors = {
    password: validatePassword(password),
    username: validateUsername(username),
  };
  if (Object.values(fieldErrors).some(Boolean)) {
    return badRequest({
      fieldErrors,
      fields,
      formError: null,
    });
  }

  switch (loginType) {
    case 'login': {
      // login to get the user
      // if there's no user, return the fields and a formError
      // if there is a user, create their session and redirect to /jokes
      return badRequest({
        fieldErrors: null,
        fields,
        formError: 'Not implemented',
      });
    }
    case 'register': {
      const userExists = await db.user.findFirst({
        where: { username },
      });
      if (userExists) {
        return badRequest({
          fieldErrors: null,
          fields,
          formError: `User with username ${username} already exists`,
        });
      }
      // create the user
      // create their session and redirect to /jokes
      return badRequest({
        fieldErrors: null,
        fields,
        formError: 'Not implemented',
      });
    }
    default: {
      return badRequest({
        fieldErrors: null,
        fields,
        formError: 'Login type invalid',
      });
    }
  }
};

export default function Login() {
  const actionData = useActionData<typeof action>();
  const [searchParams] = useSearchParams();
  return (
    <div className="container">
      <div className="content" data-light="">
        <h1>Login</h1>
        <form method="post">
          <input
            type="hidden"
            name="redirectTo"
            value={searchParams.get('redirectTo') ?? undefined}
          />
          <fieldset>
            <legend className="sr-only">Login or Register?</legend>
            <label>
              <input
                type="radio"
                name="loginType"
                value="login"
                defaultChecked={
                  !actionData?.fields?.loginType || actionData?.fields?.loginType === 'login'
                }
              />{' '}
              Login
            </label>
            <label>
              <input
                type="radio"
                name="loginType"
                value="register"
                defaultChecked={actionData?.fields?.loginType === 'register'}
              />{' '}
              Register
            </label>
          </fieldset>
          <div>
            <label htmlFor="username-input">Username</label>
            <input
              type="text"
              id="username-input"
              name="username"
              defaultValue={actionData?.fields?.username}
              aria-invalid={Boolean(actionData?.fieldErrors?.username)}
              aria-errormessage={actionData?.fieldErrors?.username ? 'username-error' : undefined}
            />
            {actionData?.fieldErrors?.username ? (
              <p className="form-validation-error" role="alert" id="username-error">
                {actionData.fieldErrors.username}
              </p>
            ) : null}
          </div>
          <div>
            <label htmlFor="password-input">Password</label>
            <input
              id="password-input"
              name="password"
              type="password"
              defaultValue={actionData?.fields?.password}
              aria-invalid={Boolean(actionData?.fieldErrors?.password)}
              aria-errormessage={actionData?.fieldErrors?.password ? 'password-error' : undefined}
            />
            {actionData?.fieldErrors?.password ? (
              <p className="form-validation-error" role="alert" id="password-error">
                {actionData.fieldErrors.password}
              </p>
            ) : null}
          </div>
          <div id="form-error-message">
            {actionData?.formError ? (
              <p className="form-validation-error" role="alert">
                {actionData.formError}
              </p>
            ) : null}
          </div>
          <button type="submit" className="button">
            Submit
          </button>
        </form>
      </div>
      <div className="links">
        <ul>
          <li>
            <Link to="/">Home</Link>
          </li>
          <li>
            <Link to="/jokes">Jokes</Link>
          </li>
        </ul>
      </div>
    </div>
  );
}
```

</details>

Once you've got that done, your form should look something like this:

![Login form with errors][login-form-with-errors]

Sweet! Now it's time for the juicy stuff. Let's start with the `login` side of things. We seed in a user with the username `kody` and the password (hashed) is `twixrox`. So we want to implement enough logic that will allow us to login as that user. We're going to put this logic in a separate file called `app/utils/session.server.ts`.

Here's what we need in that file to get started:

- Export a function called `login` that accepts the `username` and `password`
- Queries Prisma for a user with the `username`
- If there is no user, return `null`
- Use `bcrypt.compare` to compare the given `password` to the user's `passwordHash`
- If the passwords don't match, return `null`
- If the passwords match, return the user

üíø Create a file called `app/utils/session.server.ts` and implement the above requirements.

<details>

<summary>app/utils/session.server.ts</summary>

```ts filename=app/utils/session.server.ts
import bcrypt from 'bcryptjs';

import { db } from './db.server';

type LoginForm = {
  password: string;
  username: string;
};

export async function login({ password, username }: LoginForm) {
  const user = await db.user.findUnique({
    where: { username },
  });
  if (!user) {
    return null;
  }

  const isCorrectPassword = await bcrypt.compare(password, user.passwordHash);
  if (!isCorrectPassword) {
    return null;
  }

  return { id: user.id, username };
}
```

</details>

Great, with that in place, we can now update `app/routes/login.tsx` to use it:

<details>

<summary>app/routes/login.tsx</summary>

```tsx filename=app/routes/login.tsx lines=[6,16-25] nocopy
// ...

import stylesUrl from '@/styles/login.css';
import { db } from '@/utils/db.server';
import { badRequest } from '@/utils/request.server';
import { login } from '@/utils/session.server';

// ...

export const action = async ({ request }: ActionFunctionArgs) => {
  // ...
  switch (loginType) {
    case 'login': {
      const user = await login({ username, password });
      console.log({ user });
      if (!user) {
        return badRequest({
          fieldErrors: null,
          fields,
          formError: 'Username/Password combination is incorrect',
        });
      }
      // if there is a user, create their session and redirect to /jokes
      return badRequest({
        fieldErrors: null,
        fields,
        formError: 'Not implemented',
      });
    }
    // ...
  }
};

export default function Login() {
  // ...
}
```

</details>

To check our work, I added a `console.log` to `app/routes/login.tsx` after the `login` call.

<docs-info>Remember, `actions` and `loaders` run on the server, so `console.log` calls you put in those you can't see in the browser console. Those will show up in the terminal window you're running your server in.</docs-info>

üíø With that in place, try to log in with the username `kody` and the password `twixrox` and check the terminal output. Here's what I get:

```
{
  user: {
    id: '1dc45f54-4061-4d9e-8a6d-28d6df6a8d7f',
    username: 'kody'
  }
}
```

<docs-warning>If you're having trouble, run `npx prisma studio` to see the database in the browser. It's possible you don't have any data because you forgot to run `npx prisma db seed` (like I did when I was writing this üòÖ).</docs-warning>

Wahoo! We got the user! Now we need to put that user's ID into the session. We're going to do this in `app/utils/session.server.ts`. Remix has a built-in abstraction to help us with managing several types of storage mechanisms for sessions ([here are the docs][here-are-the-docs]). We'll be using [`createCookieSessionStorage`][create-cookie-session-storage] as it's the simplest and scales quite well.

üíø Write a `createUserSession` function in `app/utils/session.server.ts` that accepts a user ID and a route to redirect to. It should do the following:

- creates a new session (via the cookie storage `getSession` function)
- sets the `userId` field on the session
- redirects to the given route setting the `Set-Cookie` header (via the cookie storage `commitSession` function)

Note: If you need a hand, there's a small example of how the whole basic flow goes in [the session docs][here-are-the-docs]. Once you have that, you'll want to use it in `app/routes/login.tsx` to set the session and redirect to the `/jokes` route.

<details>

<summary>app/utils/session.server.ts</summary>

```ts filename=app/utils/session.server.ts lines=[1-4,35-38,40-53,55-66]
import { createCookieSessionStorage, redirect } from '@remix-run/node';
import bcrypt from 'bcryptjs';

import { db } from './db.server';

type LoginForm = {
  username: string;
  password: string;
};

export async function login({ username, password }: LoginForm) {
  const user = await db.user.findUnique({
    where: { username },
  });
  if (!user) {
    return null;
  }
  const isCorrectPassword = await bcrypt.compare(password, user.passwordHash);
  if (!isCorrectPassword) {
    return null;
  }

  return { id: user.id, username };
}

const sessionSecret = process.env.SESSION_SECRET;
if (!sessionSecret) {
  throw new Error('SESSION_SECRET must be set');
}

const storage = createCookieSessionStorage({
  cookie: {
    name: 'RJ_session',
    // normally you want this to be `secure: true`
    // but that doesn't work on localhost for Safari
    // https://web.dev/when-to-use-local-https/
    secure: process.env.NODE_ENV === 'production',
    secrets: [sessionSecret],
    sameSite: 'lax',
    path: '/',
    maxAge: 60 * 60 * 24 * 30,
    httpOnly: true,
  },
});

export async function createUserSession(userId: string, redirectTo: string) {
  const session = await storage.getSession();
  session.set('userId', userId);
  return redirect(redirectTo, {
    headers: {
      'Set-Cookie': await storage.commitSession(session),
    },
  });
}
```

</details>

<details>

<summary>app/routes/login.tsx</summary>

```tsx filename=app/routes/login.tsx lines=[7,29] nocopy
// ...

import stylesUrl from '@/styles/login.css';
import { db } from '@/utils/db.server';
import { badRequest } from '@/utils/request.server';
import { createUserSession, login } from '@/utils/session.server';

// ...

export const action = async ({ request }: ActionFunctionArgs) => {
  // ...

  switch (loginType) {
    case 'login': {
      const user = await login({ username, password });

      if (!user) {
        return badRequest({
          fieldErrors: null,
          fields,
          formError: `Username/Password combination is incorrect`,
        });
      }
      return createUserSession(user.id, redirectTo);
    }

    // ...
  }
};

// ...
```

</details>

I want to call out the `SESSION_SECRET` environment variable I'm using really quick. The value of the `secrets` option is not the sort of thing you want in your code because the baddies could use it for their nefarious purposes. So instead we are going to read the value from the environment. This means you'll need to set the environment variable in your `.env` file. Incidentally, Prisma loads that file for us automatically so all we need to do is make sure we set that value when we deploy to production.

üíø Update `.env` file with `SESSION_SECRET` (with any value you like).

With that, pop open your [Network tab][network-tab], go to [`/login`][login] and enter `kody` and `twixrox` and check the response headers in the network tab. Should look something like this:

![DevTools Network tab showing a "Set-Cookie" header on the POST response][dev-tools-network-tab-showing-a-set-cookie-header-on-the-post-response]

And if you check the cookies section of the [Application tab][application-tab] then you should have the cookie set in there as well.

![DevTools Application tab showing ][dev-tools-application-tab-showing]

And now every request the browser makes to our server will include that cookie (we don't have to do anything on the client, [this is how cookies work][http-cookies]):

![Request headers showing the Cookie][request-headers-showing-the-cookie]

So we can now check whether the user is authenticated on the server by reading that header to get the `userId` we had set into it. To test this out, let's fix the `/jokes/new` route by adding the `jokesterId` field to `db.joke.create` call.

<docs-info>Remember to check [the docs][here-are-the-docs] to learn how to get the session from the request</docs-info>

üíø Update `app/utils/session.server.ts` to get the `userId` from the session. In my solution I create three functions: `getUserSession(request: Request)`, `getUserId(request: Request)` and `requireUserId(request: Request, redirectTo: string)`.

<details>

<summary>app/utils/session.server.ts</summary>

```ts filename=app/utils/session.server.ts lines=[55-57,59-66,68-81]
import { createCookieSessionStorage, redirect } from '@remix-run/node';
import bcrypt from 'bcryptjs';

import { db } from './db.server';

type LoginForm = {
  username: string;
  password: string;
};

export async function login({ username, password }: LoginForm) {
  const user = await db.user.findUnique({
    where: { username },
  });
  if (!user) {
    return null;
  }
  const isCorrectPassword = await bcrypt.compare(password, user.passwordHash);
  if (!isCorrectPassword) {
    return null;
  }

  return { id: user.id, username };
}

const sessionSecret = process.env.SESSION_SECRET;
if (!sessionSecret) {
  throw new Error('SESSION_SECRET must be set');
}

const storage = createCookieSessionStorage({
  cookie: {
    name: 'RJ_session',
    // normally you want this to be `secure: true`
    // but that doesn't work on localhost for Safari
    // https://web.dev/when-to-use-local-https/
    secure: process.env.NODE_ENV === 'production',
    secrets: [sessionSecret],
    sameSite: 'lax',
    path: '/',
    maxAge: 60 * 60 * 24 * 30,
    httpOnly: true,
  },
});

function getUserSession(request: Request) {
  return storage.getSession(request.headers.get('Cookie'));
}

export async function getUserId(request: Request) {
  const session = await getUserSession(request);
  const userId = session.get('userId');
  if (!userId || typeof userId !== 'string') {
    return null;
  }
  return userId;
}

export async function requireUserId(
  request: Request,
  redirectTo: string = new URL(request.url).pathname,
) {
  const session = await getUserSession(request);
  const userId = session.get('userId');
  if (!userId || typeof userId !== 'string') {
    const searchParams = new URLSearchParams([['redirectTo', redirectTo]]);
    throw redirect(`/login?${searchParams}`);
  }
  return userId;
}

export async function createUserSession(userId: string, redirectTo: string) {
  const session = await storage.getSession();
  session.set('userId', userId);
  return redirect(redirectTo, {
    headers: {
      'Set-Cookie': await storage.commitSession(session),
    },
  });
}
```

</details>

<docs-info>Did you notice in my example that we're `throw`ing a `Response`?!</docs-info>

In my example, I created a `requireUserId` which will throw a `redirect`. Remember `redirect` is a utility function that returns a [`Response`][response] object. Remix will catch that thrown response and send it back to the client. It's a great way to "exit early" in abstractions like this so users of our `requireUserId` function can just assume that the return will always give us the `userId` and don't need to worry about what happens if there isn't a `userId` because the response is thrown which stops their code execution!

We'll cover this more in the error handling sections later.

You may also notice that our solution makes use of the `login` route's `redirectTo` feature we had earlier.

üíø Now update `app/routes/jokes.new.tsx` to use that function to get the `userId` and pass it to the `db.joke.create` call.

<details>

<summary>app/routes/jokes.new.tsx</summary>

```tsx filename=app/routes/jokes.new.tsx lines=[7,24,53]
import type { ActionFunctionArgs } from '@remix-run/node';
import { redirect } from '@remix-run/node';
import { useActionData } from '@remix-run/react';

import { db } from '@/utils/db.server';
import { badRequest } from '@/utils/request.server';
import { requireUserId } from '@/utils/session.server';

function validateJokeContent(content: string) {
  if (content.length < 10) {
    return 'That joke is too short';
  }
}

function validateJokeName(name: string) {
  if (name.length < 3) {
    return "That joke's name is too short";
  }
}

export const action = async ({ request }: ActionFunctionArgs) => {
  const userId = await requireUserId(request);
  const form = await request.formData();
  const content = form.get('content');
  const name = form.get('name');
  if (typeof content !== 'string' || typeof name !== 'string') {
    return badRequest({
      fieldErrors: null,
      fields: null,
      formError: 'Form not submitted correctly.',
    });
  }

  const fieldErrors = {
    content: validateJokeContent(content),
    name: validateJokeName(name),
  };
  const fields = { content, name };
  if (Object.values(fieldErrors).some(Boolean)) {
    return badRequest({
      fieldErrors,
      fields,
      formError: null,
    });
  }

  const joke = await db.joke.create({
    data: { ...fields, jokesterId: userId },
  });
  return redirect(`/jokes/${joke.id}`);
};

export default function NewJokeRoute() {
  const actionData = useActionData<typeof action>();

  return (
    <div>
      <p>Add your own hilarious joke</p>
      <form method="post">
        <div>
          <label>
            Name:{' '}
            <input
              defaultValue={actionData?.fields?.name}
              name="name"
              type="text"
              aria-invalid={Boolean(actionData?.fieldErrors?.name)}
              aria-errormessage={actionData?.fieldErrors?.name ? 'name-error' : undefined}
            />
          </label>
          {actionData?.fieldErrors?.name ? (
            <p className="form-validation-error" id="name-error" role="alert">
              {actionData.fieldErrors.name}
            </p>
          ) : null}
        </div>
        <div>
          <label>
            Content:{' '}
            <textarea
              defaultValue={actionData?.fields?.content}
              name="content"
              aria-invalid={Boolean(actionData?.fieldErrors?.content)}
              aria-errormessage={actionData?.fieldErrors?.content ? 'content-error' : undefined}
            />
          </label>
          {actionData?.fieldErrors?.content ? (
            <p className="form-validation-error" id="content-error" role="alert">
              {actionData.fieldErrors.content}
            </p>
          ) : null}
        </div>
        <div>
          {actionData?.formError ? (
            <p className="form-validation-error" role="alert">
              {actionData.formError}
            </p>
          ) : null}
          <button type="submit" className="button">
            Add
          </button>
        </div>
      </form>
    </div>
  );
}
```

</details>

Super! So now if a user attempts to create a new joke, they'll be redirected to the login page because a `userId` is required to create a new joke.

### Build Logout Action

We should probably give people the ability to see that they're logged in and a way to log out right? Yeah, I think so. Let's implement that.

üíø Update `app/utils/session.server.ts` to add a `getUser` function that gets the user from Prisma and a `logout` function that uses [`destroySession`][destroy-session] to log the user out.

<details>

<summary>app/utils/session.server.ts</summary>

```ts filename=app/utils/session.server.ts lines=[84-100,102-109]
import { createCookieSessionStorage, redirect } from '@remix-run/node';
import bcrypt from 'bcryptjs';

import { db } from './db.server';

type LoginForm = {
  password: string;
  username: string;
};

export async function login({ password, username }: LoginForm) {
  const user = await db.user.findUnique({
    where: { username },
  });
  if (!user) {
    return null;
  }

  const isCorrectPassword = await bcrypt.compare(password, user.passwordHash);
  if (!isCorrectPassword) {
    return null;
  }

  return { id: user.id, username };
}

const sessionSecret = process.env.SESSION_SECRET;
if (!sessionSecret) {
  throw new Error('SESSION_SECRET must be set');
}

const storage = createCookieSessionStorage({
  cookie: {
    name: 'RJ_session',
    // normally you want this to be `secure: true`
    // but that doesn't work on localhost for Safari
    // https://web.dev/when-to-use-local-https/
    secure: process.env.NODE_ENV === 'production',
    secrets: [sessionSecret],
    sameSite: 'lax',
    path: '/',
    maxAge: 60 * 60 * 24 * 30,
    httpOnly: true,
  },
});

function getUserSession(request: Request) {
  return storage.getSession(request.headers.get('Cookie'));
}

export async function getUserId(request: Request) {
  const session = await getUserSession(request);
  const userId = session.get('userId');
  if (!userId || typeof userId !== 'string') {
    return null;
  }
  return userId;
}

export async function requireUserId(
  request: Request,
  redirectTo: string = new URL(request.url).pathname,
) {
  const session = await getUserSession(request);
  const userId = session.get('userId');
  if (!userId || typeof userId !== 'string') {
    const searchParams = new URLSearchParams([['redirectTo', redirectTo]]);
    throw redirect(`/login?${searchParams}`);
  }
  return userId;
}

export async function getUser(request: Request) {
  const userId = await getUserId(request);
  if (typeof userId !== 'string') {
    return null;
  }

  const user = await db.user.findUnique({
    select: { id: true, username: true },
    where: { id: userId },
  });

  if (!user) {
    throw await logout(request);
  }

  return user;
}

export async function logout(request: Request) {
  const session = await getUserSession(request);
  return redirect('/login', {
    headers: {
      'Set-Cookie': await storage.destroySession(session),
    },
  });
}

export async function createUserSession(userId: string, redirectTo: string) {
  const session = await storage.getSession();
  session.set('userId', userId);
  return redirect(redirectTo, {
    headers: {
      'Set-Cookie': await storage.commitSession(session),
    },
  });
}
```

</details>

üíø Great, now we're going to update the `app/routes/jokes.tsx` route, so we can display a login link if the user isn't logged in. If they are logged in then we'll display their username and a logout form. I'm also going to clean up the UI a bit to match the class names we've got as well, so feel free to copy/paste the example when you're ready.

<details>

<summary>app/routes/jokes.tsx</summary>

```tsx filename=app/routes/jokes.tsx lines=[3,14,20-22,28,30,50-61]
import type { LinksFunction, LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import { Link, Outlet, useLoaderData } from '@remix-run/react';

import stylesUrl from '@/styles/jokes.css';
import { db } from '@/utils/db.server';
import { getUser } from '@/utils/session.server';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const jokeListItems = await db.joke.findMany({
    orderBy: { createdAt: 'desc' },
    select: { id: true, name: true },
    take: 5,
  });
  const user = await getUser(request);

  return json({ jokeListItems, user });
};

export default function JokesRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div className="jokes-layout">
      <header className="jokes-header">
        <div className="container">
          <h1 className="home-link">
            <Link to="/" title="Remix Jokes" aria-label="Remix Jokes">
              <span className="logo">ü§™</span>
              <span className="logo-medium">Jü§™KES</span>
            </Link>
          </h1>
          {data.user ? (
            <div className="user-info">
              <span>{`Hi ${data.user.username}`}</span>
              <form action="/logout" method="post">
                <button type="submit" className="button">
                  Logout
                </button>
              </form>
            </div>
          ) : (
            <Link to="/login">Login</Link>
          )}
        </div>
      </header>
      <main className="jokes-main">
        <div className="container">
          <div className="jokes-list">
            <Link to=".">Get a random joke</Link>
            <p>Here are a few more jokes to check out:</p>
            <ul>
              {data.jokeListItems.map(({ id, name }) => (
                <li key={id}>
                  <Link to={id}>{name}</Link>
                </li>
              ))}
            </ul>
            <Link to="new" className="button">
              Add your own
            </Link>
          </div>
          <div className="jokes-outlet">
            <Outlet />
          </div>
        </div>
      </main>
    </div>
  );
}
```

</details>

<details>

<summary>app/routes/logout.tsx</summary>

```tsx filename=app/routes/logout.tsx
import type { ActionFunctionArgs } from '@remix-run/node';
import { redirect } from '@remix-run/node';

import { logout } from '@/utils/session.server';

export const action = async ({ request }: ActionFunctionArgs) => logout(request);

export const loader = async () => redirect('/');
```

</details>

Hopefully getting the user in the loader and rendering them in the component was pretty straightforward. There are a few things I want to call out about other parts of my version of the code before we continue.

First, the new `logout` route is just there to make it easy for us to logout. The reason that we're using an action (rather than a loader) is because we want to avoid [CSRF][csrf] problems by using a POST request rather than a GET request. This is why the logout button is a form and not a link. Additionally, Remix will only re-call our loaders when we perform an `action`, so if we used a `loader` then the cache would not get invalidated. The `loader` is just there in case someone somehow lands on that page, we'll just redirect them back home.

```tsx
<Link to="new" className="button">
  Add your own
</Link>
```

Notice that the `to` prop is set to "new" without any `/`. This is the benefit of nested routing. You don't have to construct the entire URL. It can be relative. This is the same thing for the `<Link to=".">Get a random joke</Link>` link which will effectively tell Remix to reload the data for the current route.

Terrific, now our app looks like this:

![Jokes page nice and designed][jokes-page-nice-and-designed]

![New Joke form designed][new-joke-form-designed]

### User Registration

I suppose now would be a good time to add support for user registration! Did you forget like I did? üòÖ Well, let's get that bit added before moving on.

Luckily, all we need to do to support this is to update `app/utils/session.server.ts` with a `register` function that's pretty similar to our `login` function. The difference here is that we need to use `bcrypt.hash` to hash the password before we store it in the database. Then update the `register` case in our `app/routes/login.tsx` route to handle the registration.

üíø Update both `app/utils/session.server.ts` and `app/routes/login.tsx` to handle user registration.

<details>

<summary>app/utils/session.server.ts</summary>

```tsx filename=app/utils/session.server.ts lines=[14-23]
import { createCookieSessionStorage, redirect } from '@remix-run/node';
import bcrypt from 'bcryptjs';

import { db } from './db.server';

type LoginForm = {
  password: string;
  username: string;
};

export async function register({ password, username }: LoginForm) {
  const passwordHash = await bcrypt.hash(password, 10);
  const user = await db.user.create({
    data: { passwordHash, username },
  });
  return { id: user.id, username };
}

export async function login({ password, username }: LoginForm) {
  const user = await db.user.findUnique({
    where: { username },
  });
  if (!user) {
    return null;
  }

  const isCorrectPassword = await bcrypt.compare(password, user.passwordHash);
  if (!isCorrectPassword) {
    return null;
  }

  return { id: user.id, username };
}

const sessionSecret = process.env.SESSION_SECRET;
if (!sessionSecret) {
  throw new Error('SESSION_SECRET must be set');
}

const storage = createCookieSessionStorage({
  cookie: {
    name: 'RJ_session',
    // normally you want this to be `secure: true`
    // but that doesn't work on localhost for Safari
    // https://web.dev/when-to-use-local-https/
    secure: process.env.NODE_ENV === 'production',
    secrets: [sessionSecret],
    sameSite: 'lax',
    path: '/',
    maxAge: 60 * 60 * 24 * 30,
    httpOnly: true,
  },
});

function getUserSession(request: Request) {
  return storage.getSession(request.headers.get('Cookie'));
}

export async function getUserId(request: Request) {
  const session = await getUserSession(request);
  const userId = session.get('userId');
  if (!userId || typeof userId !== 'string') {
    return null;
  }
  return userId;
}

export async function requireUserId(
  request: Request,
  redirectTo: string = new URL(request.url).pathname,
) {
  const session = await getUserSession(request);
  const userId = session.get('userId');
  if (!userId || typeof userId !== 'string') {
    const searchParams = new URLSearchParams([['redirectTo', redirectTo]]);
    throw redirect(`/login?${searchParams}`);
  }
  return userId;
}

export async function getUser(request: Request) {
  const userId = await getUserId(request);
  if (typeof userId !== 'string') {
    return null;
  }

  const user = await db.user.findUnique({
    select: { id: true, username: true },
    where: { id: userId },
  });

  if (!user) {
    throw await logout(request);
  }

  return user;
}

export async function logout(request: Request) {
  const session = await getUserSession(request);
  return redirect('/login', {
    headers: {
      'Set-Cookie': await storage.destroySession(session),
    },
  });
}

export async function createUserSession(userId: string, redirectTo: string) {
  const session = await storage.getSession();
  session.set('userId', userId);
  return redirect(redirectTo, {
    headers: {
      'Set-Cookie': await storage.commitSession(session),
    },
  });
}
```

</details>

<details>

<summary>app/routes/login.tsx</summary>

```tsx filename=app/routes/login.tsx lines=[17,104-112]
import type { ActionFunctionArgs, LinksFunction } from '@remix-run/node';
import { Link, useActionData, useSearchParams } from '@remix-run/react';

import stylesUrl from '@/styles/login.css';
import { db } from '@/utils/db.server';
import { badRequest } from '@/utils/request.server';
import { createUserSession, login, register } from '@/utils/session.server';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

function validateUsername(username: string) {
  if (username.length < 3) {
    return 'Usernames must be at least 3 characters long';
  }
}

function validatePassword(password: string) {
  if (password.length < 6) {
    return 'Passwords must be at least 6 characters long';
  }
}

function validateUrl(url: string) {
  const urls = ['/jokes', '/', 'https://remix.run'];
  if (urls.includes(url)) {
    return url;
  }
  return '/jokes';
}

export const action = async ({ request }: ActionFunctionArgs) => {
  const form = await request.formData();
  const loginType = form.get('loginType');
  const password = form.get('password');
  const username = form.get('username');
  const redirectTo = validateUrl((form.get('redirectTo') as string) || '/jokes');
  if (
    typeof loginType !== 'string' ||
    typeof password !== 'string' ||
    typeof username !== 'string'
  ) {
    return badRequest({
      fieldErrors: null,
      fields: null,
      formError: 'Form not submitted correctly.',
    });
  }

  const fields = { loginType, password, username };
  const fieldErrors = {
    password: validatePassword(password),
    username: validateUsername(username),
  };
  if (Object.values(fieldErrors).some(Boolean)) {
    return badRequest({
      fieldErrors,
      fields,
      formError: null,
    });
  }

  switch (loginType) {
    case 'login': {
      const user = await login({ username, password });
      console.log({ user });
      if (!user) {
        return badRequest({
          fieldErrors: null,
          fields,
          formError: 'Username/Password combination is incorrect',
        });
      }
      return createUserSession(user.id, redirectTo);
    }
    case 'register': {
      const userExists = await db.user.findFirst({
        where: { username },
      });
      if (userExists) {
        return badRequest({
          fieldErrors: null,
          fields,
          formError: `User with username ${username} already exists`,
        });
      }
      const user = await register({ username, password });
      if (!user) {
        return badRequest({
          fieldErrors: null,
          fields,
          formError: 'Something went wrong trying to create a new user.',
        });
      }
      return createUserSession(user.id, redirectTo);
    }
    default: {
      return badRequest({
        fieldErrors: null,
        fields,
        formError: 'Login type invalid',
      });
    }
  }
};

export default function Login() {
  const actionData = useActionData<typeof action>();
  const [searchParams] = useSearchParams();
  return (
    <div className="container">
      <div className="content" data-light="">
        <h1>Login</h1>
        <form method="post">
          <input
            type="hidden"
            name="redirectTo"
            value={searchParams.get('redirectTo') ?? undefined}
          />
          <fieldset>
            <legend className="sr-only">Login or Register?</legend>
            <label>
              <input
                type="radio"
                name="loginType"
                value="login"
                defaultChecked={
                  !actionData?.fields?.loginType || actionData?.fields?.loginType === 'login'
                }
              />{' '}
              Login
            </label>
            <label>
              <input
                type="radio"
                name="loginType"
                value="register"
                defaultChecked={actionData?.fields?.loginType === 'register'}
              />{' '}
              Register
            </label>
          </fieldset>
          <div>
            <label htmlFor="username-input">Username</label>
            <input
              type="text"
              id="username-input"
              name="username"
              defaultValue={actionData?.fields?.username}
              aria-invalid={Boolean(actionData?.fieldErrors?.username)}
              aria-errormessage={actionData?.fieldErrors?.username ? 'username-error' : undefined}
            />
            {actionData?.fieldErrors?.username ? (
              <p className="form-validation-error" role="alert" id="username-error">
                {actionData.fieldErrors.username}
              </p>
            ) : null}
          </div>
          <div>
            <label htmlFor="password-input">Password</label>
            <input
              id="password-input"
              name="password"
              type="password"
              defaultValue={actionData?.fields?.password}
              aria-invalid={Boolean(actionData?.fieldErrors?.password)}
              aria-errormessage={actionData?.fieldErrors?.password ? 'password-error' : undefined}
            />
            {actionData?.fieldErrors?.password ? (
              <p className="form-validation-error" role="alert" id="password-error">
                {actionData.fieldErrors.password}
              </p>
            ) : null}
          </div>
          <div id="form-error-message">
            {actionData?.formError ? (
              <p className="form-validation-error" role="alert">
                {actionData.formError}
              </p>
            ) : null}
          </div>
          <button type="submit" className="button">
            Submit
          </button>
        </form>
      </div>
      <div className="links">
        <ul>
          <li>
            <Link to="/">Home</Link>
          </li>
          <li>
            <Link to="/jokes">Jokes</Link>
          </li>
        </ul>
      </div>
    </div>
  );
}
```

</details>

Phew, there we go. Now users can register for a new account!

## Unexpected errors

I'm sorry, but there's no way you'll be able to avoid errors at some point. Servers fall over, co-workers use `// @ts-ignore`, and so on. So we need to just embrace the possibility of unexpected errors and deal with them.

Luckily, error handling in Remix is stellar. You may have used React's [Error Boundary feature][error-boundary-feature]. With Remix, your route modules can export an [`ErrorBoundary` component][error-boundary-component], and it will be used. But it's even cooler because it works on the server too! Not only that, but it'll handle errors in `loader`s and `action`s too! Wowza! So let's get to it!

Just like the `useLoaderData` hook to get data from the `loader` and the `useActionData` hook to get data from the `action`, the `ErrorBoundary` gets the thrown instance from the `useRouteError` hook.

We're going to add four `ErrorBoundary`s in our app. One in each of the child routes in `app/routes/jokes.*` in case there's an error reading or processing stuff with the jokes, and one in `app/root.tsx` to handle errors for everything else.

<docs-info>The `app/root.tsx` `ErrorBoundary` is a bit more complicated</docs-info>

Remember that the `app/root.tsx` module is responsible for rendering our `<html>` element. When the `ErrorBoundary` is rendered, it's rendered _in place_ of the default export. That means the `app/root.tsx` module should render the `<html>` element along with the `<Link />` elements, etc.

üíø Add a simple `ErrorBoundary` to each of those files.

<details>

<summary>app/root.tsx</summary>

```tsx filename=app/root.tsx lines=[6,8,28-49,51-57,59-74]
import type { LinksFunction } from '@remix-run/node';
import { Links, LiveReload, Outlet, useRouteError } from '@remix-run/react';
import type { PropsWithChildren } from 'react';

import globalLargeStylesUrl from '@/styles/global-large.css';
import globalMediumStylesUrl from '@/styles/global-medium.css';
import globalStylesUrl from '@/styles/global.css';

export const links: LinksFunction = () => [
  { rel: 'stylesheet', href: globalStylesUrl },
  {
    rel: 'stylesheet',
    href: globalMediumStylesUrl,
    media: 'print, (min-width: 640px)',
  },
  {
    rel: 'stylesheet',
    href: globalLargeStylesUrl,
    media: 'screen and (min-width: 1024px)',
  },
];

function Document({
  children,
  title = "Remix: So great, it's funny!",
}: PropsWithChildren<{ title?: string }>) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>{title}</title>
        <Links />
      </head>
      <body>
        {children}
        <LiveReload />
      </body>
    </html>
  );
}

export default function App() {
  return (
    <Document>
      <Outlet />
    </Document>
  );
}

export function ErrorBoundary() {
  const error = useRouteError();

  const errorMessage = error instanceof Error ? error.message : 'Unknown error';
  return (
    <Document title="Uh-oh!">
      <div className="error-container">
        <h1>App Error</h1>
        <pre>{errorMessage}</pre>
      </div>
    </Document>
  );
}
```

</details>

<details>

<summary>app/routes/jokes.$jokeId.tsx</summary>

```tsx filename=app/routes/jokes.$jokeId.tsx lines=[6,11-19] nocopy
// ...

import { Link, useLoaderData, useParams } from '@remix-run/react';

// ...

export function ErrorBoundary() {
  const { jokeId } = useParams();
  return (
    <div className="error-container">
      There was an error loading joke by the id "${jokeId}". Sorry.
    </div>
  );
}
```

</details>

<details>

<summary>app/routes/jokes.new.tsx</summary>

```tsx filename=app/routes/jokes.new.tsx nocopy
// ...

export function ErrorBoundary() {
  return <div className="error-container">Something unexpected went wrong. Sorry about that.</div>;
}
```

</details>

<details>

<summary>app/routes/jokes._index.tsx</summary>

```tsx filename=app/routes/jokes._index.tsx nocopy
// ...

export function ErrorBoundary() {
  return <div className="error-container">I did a whoopsies.</div>;
}
```

</details>

Ok great, with those in place, let's check what happens when there's an error. Go ahead and just add this to the default component, loader, or action of each of the routes.

```ts
throw new Error('Testing Error Boundary');
```

Here's what I get:

![App error][app-error]

![Joke Page Error][joke-page-error]

![Joke Index Page Error][joke-index-page-error]

![New Joke Page Error][new-joke-page-error]

What I love about this is that in the case of the children routes, the only unusable part of the app is the part that actually broke. The rest of the app is completely interactive. There's another point for the user's experience!

## Expected errors

Sometimes users do things we can anticipate. I'm not talking about validation necessarily. I'm talking about things like whether the user's authenticated (status `401`) or authorized (status `403`) to do what they're trying to do. Or maybe they're looking for something that isn't there (status `404`).

It might help to think of the unexpected errors as 500-level errors ([server errors][server-errors]) and the expected errors as 400-level errors ([client errors][client-errors]).

To check for client error responses, Remix offers the [`isRouteErrorResponse`][is-route-error-response] helper function. In the case that your server code detects a problem, it'll throw a [`Response`][response] object. Remix then catches that thrown `Response` and renders your `ErrorBoundary`. Since you can throw whatever you want, the `isRouteErrorResponse` helper function is a way to check if the thrown instance is a `Response` object.

One last thing, this isn't for form validations and stuff. We already discussed that earlier with `useActionData`. This is just for situations where the user did something that means we can't reasonably render our default component, so we want to render something else instead.

<docs-info>`ErrorBoundary` allows our default exports to represent the "happy path" and not worry about errors. If the default component is rendered, then we can assume all is right with the world.</docs-info>

With that understanding, we're going to add a `isRouteErrorResponse` check to the following routes:

- `app/root.tsx` - Just as a last resort fallback.
- `app/routes/jokes.$jokeId.tsx` - When a user tries to access a joke that doesn't exist (404).
- `app/routes/jokes.new.tsx` - When a user tries to go to this page without being authenticated (401). Right now they'll just get redirected to the login if they try to submit it without authenticating. That would be super annoying to spend time writing a joke only to get redirected. Rather than inexplicably redirecting them, we could render a message that says they need to authenticate first.
- `app/routes/jokes._index.tsx` - If there are no jokes in the database then a random joke is 404-not found. (simulate this by deleting the `prisma/dev.db` and running `npx prisma db push`. Don't forget to run `npx prisma db seed` afterward to get your seed data back.)

üíø Let's add these `isRouteErrorResponse` checks to the routes.

<details>

<summary>app/root.tsx</summary>

```tsx filename=app/root.tsx lines=[3,63-75]
import type { LinksFunction } from '@remix-run/node';
import { isRouteErrorResponse, Links, LiveReload, Outlet, useRouteError } from '@remix-run/react';
import type { PropsWithChildren } from 'react';

import globalLargeStylesUrl from '@/styles/global-large.css';
import globalMediumStylesUrl from '@/styles/global-medium.css';
import globalStylesUrl from '@/styles/global.css';

export const links: LinksFunction = () => [
  { rel: 'stylesheet', href: globalStylesUrl },
  {
    rel: 'stylesheet',
    href: globalMediumStylesUrl,
    media: 'print, (min-width: 640px)',
  },
  {
    rel: 'stylesheet',
    href: globalLargeStylesUrl,
    media: 'screen and (min-width: 1024px)',
  },
];

function Document({
  children,
  title = "Remix: So great, it's funny!",
}: PropsWithChildren<{ title?: string }>) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>{title}</title>
        <Links />
      </head>
      <body>
        {children}
        <LiveReload />
      </body>
    </html>
  );
}

export default function App() {
  return (
    <Document>
      <Outlet />
    </Document>
  );
}

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    return (
      <Document title={`${error.status} ${error.statusText}`}>
        <div className="error-container">
          <h1>
            {error.status} {error.statusText}
          </h1>
        </div>
      </Document>
    );
  }

  const errorMessage = error instanceof Error ? error.message : 'Unknown error';
  return (
    <Document title="Uh-oh!">
      <div className="error-container">
        <h1>App Error</h1>
        <pre>{errorMessage}</pre>
      </div>
    </Document>
  );
}
```

</details>

<details>

<summary>app/routes/jokes.$jokeId.tsx</summary>

```tsx filename=app/routes/jokes.$jokeId.tsx lines=[4,8,20-22,41,43-49]
import type { LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import {
  isRouteErrorResponse,
  Link,
  useLoaderData,
  useParams,
  useRouteError,
} from '@remix-run/react';

import { db } from '@/utils/db.server';

export const loader = async ({ params }: LoaderFunctionArgs) => {
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Response('What a joke! Not found.', {
      status: 404,
    });
  }
  return json({ joke });
};

export default function JokeRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div>
      <p>Here's your hilarious joke:</p>
      <p>{data.joke.content}</p>
      <Link to=".">"{data.joke.name}" Permalink</Link>
    </div>
  );
}

export function ErrorBoundary() {
  const { jokeId } = useParams();
  const error = useRouteError();

  if (isRouteErrorResponse(error) && error.status === 404) {
    return <div className="error-container">Huh? What the heck is "{jokeId}"?</div>;
  }

  return (
    <div className="error-container">
      There was an error loading joke by the id "${jokeId}". Sorry.
    </div>
  );
}
```

</details>

<details>

<summary>app/routes/jokes._index.tsx</summary>

```tsx filename=app/routes/jokes._index.tsx lines=[3,6,18-22,41,43-50]
import { json } from '@remix-run/node';
import { isRouteErrorResponse, Link, useLoaderData, useRouteError } from '@remix-run/react';

import { db } from '@/utils/db.server';

export const loader = async () => {
  const count = await db.joke.count();
  const randomRowNumber = Math.floor(Math.random() * count);
  const [randomJoke] = await db.joke.findMany({
    skip: randomRowNumber,
    take: 1,
  });
  if (!randomJoke) {
    throw new Response('No random joke found', {
      status: 404,
    });
  }
  return json({ randomJoke });
};

export default function JokesIndexRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div>
      <p>Here's a random joke:</p>
      <p>{data.randomJoke.content}</p>
      <Link to={data.randomJoke.id}>"{data.randomJoke.name}" Permalink</Link>
    </div>
  );
}

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error) && error.status === 404) {
    return (
      <div className="error-container">
        <p>There are no jokes to display.</p>
        <Link to="new">Add your own</Link>
      </div>
    );
  }

  return <div className="error-container">I did a whoopsies.</div>;
}
```

</details>

<details>

<summary>app/routes/jokes.new.tsx</summary>

```tsx filename=app/routes/jokes.new.tsx lines=[3,5,7,10,16,20-30,162,164-171]
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
import { isRouteErrorResponse, Link, useActionData, useRouteError } from '@remix-run/react';

import { db } from '@/utils/db.server';
import { badRequest } from '@/utils/request.server';
import { getUserId, requireUserId } from '@/utils/session.server';

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const userId = await getUserId(request);
  if (!userId) {
    throw new Response('Unauthorized', { status: 401 });
  }
  return json({});
};

function validateJokeContent(content: string) {
  if (content.length < 10) {
    return 'That joke is too short';
  }
}

function validateJokeName(name: string) {
  if (name.length < 3) {
    return "That joke's name is too short";
  }
}

export const action = async ({ request }: ActionFunctionArgs) => {
  const userId = await requireUserId(request);
  const form = await request.formData();
  const content = form.get('content');
  const name = form.get('name');
  if (typeof content !== 'string' || typeof name !== 'string') {
    return badRequest({
      fieldErrors: null,
      fields: null,
      formError: 'Form not submitted correctly.',
    });
  }

  const fieldErrors = {
    content: validateJokeContent(content),
    name: validateJokeName(name),
  };
  const fields = { content, name };
  if (Object.values(fieldErrors).some(Boolean)) {
    return badRequest({
      fieldErrors,
      fields,
      formError: null,
    });
  }

  const joke = await db.joke.create({
    data: { ...fields, jokesterId: userId },
  });
  return redirect(`/jokes/${joke.id}`);
};

export default function NewJokeRoute() {
  const actionData = useActionData<typeof action>();

  return (
    <div>
      <p>Add your own hilarious joke</p>
      <form method="post">
        <div>
          <label>
            Name:{' '}
            <input
              defaultValue={actionData?.fields?.name}
              name="name"
              type="text"
              aria-invalid={Boolean(actionData?.fieldErrors?.name)}
              aria-errormessage={actionData?.fieldErrors?.name ? 'name-error' : undefined}
            />
          </label>
          {actionData?.fieldErrors?.name ? (
            <p className="form-validation-error" id="name-error" role="alert">
              {actionData.fieldErrors.name}
            </p>
          ) : null}
        </div>
        <div>
          <label>
            Content:{' '}
            <textarea
              defaultValue={actionData?.fields?.content}
              name="content"
              aria-invalid={Boolean(actionData?.fieldErrors?.content)}
              aria-errormessage={actionData?.fieldErrors?.content ? 'content-error' : undefined}
            />
          </label>
          {actionData?.fieldErrors?.content ? (
            <p className="form-validation-error" id="content-error" role="alert">
              {actionData.fieldErrors.content}
            </p>
          ) : null}
        </div>
        <div>
          {actionData?.formError ? (
            <p className="form-validation-error" role="alert">
              {actionData.formError}
            </p>
          ) : null}
          <button type="submit" className="button">
            Add
          </button>
        </div>
      </form>
    </div>
  );
}

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error) && error.status === 401) {
    return (
      <div className="error-container">
        <p>You must be logged in to create a joke.</p>
        <Link to="/login">Login</Link>
      </div>
    );
  }

  return <div className="error-container">Something unexpected went wrong. Sorry about that.</div>;
}
```

</details>

Here's what I've got with that:

![App 400 Bad Request][app-400-bad-request]

![A 404 on the joke page][a-404-on-the-joke-page]

![A 404 on the random joke page][a-404-on-the-random-joke-page]

![A 401 on the new joke page][a-401-on-the-new-joke-page]

Awesome! We're ready to handle errors, and it didn't complicate our happy path one bit! üéâ

Oh, and don't you love how it's all contextual? So the rest of the app continues to function just as well. Another point for user experience üí™

You know what, while we're adding `ErrorBoundary`s. Why don't we improve the `app/routes/jokes.$jokeId.tsx` route a bit by allowing users to delete the joke if they own it. If they don't, we can give them a 403 error in the `ErrorBoundary`.

One thing to keep in mind with `delete` is that HTML forms only support `method="get"` and `method="post"`. They don't support `method="delete"`. So to make sure our form will work with and without JavaScript, it's a good idea to do something like this:

```tsx
<form method="post">
  <button name="intent" type="submit" value="delete">
    Delete
  </button>
</form>
```

And then the `action` can determine whether the intention is to delete based on the `request.formData().get('intent')`.

üíø Add a delete capability to `app/routes/jokes.$jokeId.tsx` route.

<details>

<summary>app/routes/jokes.$jokeId.tsx</summary>

```tsx filename=app/routes/jokes.$jokeId.tsx lines=[2,5,7,11,15,31-59,69-78,88-101]
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
import {
  isRouteErrorResponse,
  Link,
  useLoaderData,
  useParams,
  useRouteError,
} from '@remix-run/react';

import { db } from '@/utils/db.server';
import { requireUserId } from '@/utils/session.server';

export const loader = async ({ params }: LoaderFunctionArgs) => {
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Response('What a joke! Not found.', {
      status: 404,
    });
  }
  return json({ joke });
};

export const action = async ({ params, request }: ActionFunctionArgs) => {
  const form = await request.formData();
  if (form.get('intent') !== 'delete') {
    throw new Response(`The intent ${form.get('intent')} is not supported`, { status: 400 });
  }
  const userId = await requireUserId(request);
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Response("Can't delete what does not exist", {
      status: 404,
    });
  }
  if (joke.jokesterId !== userId) {
    throw new Response("Pssh, nice try. That's not your joke", { status: 403 });
  }
  await db.joke.delete({ where: { id: params.jokeId } });
  return redirect('/jokes');
};

export default function JokeRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div>
      <p>Here's your hilarious joke:</p>
      <p>{data.joke.content}</p>
      <Link to=".">"{data.joke.name}" Permalink</Link>
      <form method="post">
        <button className="button" name="intent" type="submit" value="delete">
          Delete
        </button>
      </form>
    </div>
  );
}

export function ErrorBoundary() {
  const { jokeId } = useParams();
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    if (error.status === 400) {
      return <div className="error-container">What you're trying to do is not allowed.</div>;
    }
    if (error.status === 403) {
      return <div className="error-container">Sorry, but "{jokeId}" is not your joke.</div>;
    }
    if (error.status === 404) {
      return <div className="error-container">Huh? What the heck is "{jokeId}"?</div>;
    }
  }

  return (
    <div className="error-container">
      There was an error loading joke by the id "${jokeId}". Sorry.
    </div>
  );
}
```

</details>

Now that people will get a proper error message if they try to delete a joke that is not theirs, maybe we could also simply hide the delete button if the user doesn't own the joke.

<details>

<summary>app/routes/jokes.$jokeId.tsx</summary>

```tsx filename=app/routes/jokes.$jokeId.tsx lines=[16,22,24,34,77,88]
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
import {
  isRouteErrorResponse,
  Link,
  useLoaderData,
  useParams,
  useRouteError,
} from '@remix-run/react';

import { db } from '@/utils/db.server';
import { getUserId, requireUserId } from '@/utils/session.server';

export const loader = async ({ params, request }: LoaderFunctionArgs) => {
  const userId = await getUserId(request);
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Response('What a joke! Not found.', {
      status: 404,
    });
  }
  return json({
    isOwner: userId === joke.jokesterId,
    joke,
  });
};

export const action = async ({ params, request }: ActionFunctionArgs) => {
  const form = await request.formData();
  if (form.get('intent') !== 'delete') {
    throw new Response(`The intent ${form.get('intent')} is not supported`, { status: 400 });
  }
  const userId = await requireUserId(request);
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Response("Can't delete what does not exist", {
      status: 404,
    });
  }
  if (joke.jokesterId !== userId) {
    throw new Response("Pssh, nice try. That's not your joke", { status: 403 });
  }
  await db.joke.delete({ where: { id: params.jokeId } });
  return redirect('/jokes');
};

export default function JokeRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div>
      <p>Here's your hilarious joke:</p>
      <p>{data.joke.content}</p>
      <Link to=".">"{data.joke.name}" Permalink</Link>
      {data.isOwner ? (
        <form method="post">
          <button className="button" name="intent" type="submit" value="delete">
            Delete
          </button>
        </form>
      ) : null}
    </div>
  );
}

export function ErrorBoundary() {
  const { jokeId } = useParams();
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    if (error.status === 400) {
      return <div className="error-container">What you're trying to do is not allowed.</div>;
    }
    if (error.status === 403) {
      return <div className="error-container">Sorry, but "{jokeId}" is not your joke.</div>;
    }
    if (error.status === 404) {
      return <div className="error-container">Huh? What the heck is "{jokeId}"?</div>;
    }
  }

  return (
    <div className="error-container">
      There was an error loading joke by the id "${jokeId}". Sorry.
    </div>
  );
}
```

</details>

## SEO with Meta tags

Meta tags are useful for SEO and social media. The tricky bit is that often the part of the code that has access to the data you need is in components that request/use the data.

This is why Remix has the [`meta`][meta] export. Why don't you go through and add a few useful meta tags to the following routes:

- `app/routes/login.tsx`
- `app/routes/jokes.$jokeId.tsx` - (this one you can reference the joke's name in the title which is fun)

But before you get started, remember that we're in charge of rendering everything from the `<html>` to the `</html>` which means we need to make sure these `meta` tags are rendered in the `<head>` of the `<html>`. This is why Remix gives us a [`Meta` component][meta-component].

üíø Add the `Meta` component to `app/root.tsx`, and add the `meta` export to the routes mentioned above. The `Meta` component needs to be placed above the existing `<title>` tag to be able to overwrite it when provided.

<details>

<summary>app/root.tsx</summary>

```tsx filename=app/root.tsx lines=[3,9,33-42,46,56-69]
import type { LinksFunction, MetaFunction } from '@remix-run/node';
import {
  isRouteErrorResponse,
  Links,
  LiveReload,
  Meta,
  Outlet,
  useRouteError,
} from '@remix-run/react';
import type { PropsWithChildren } from 'react';

import globalLargeStylesUrl from '@/styles/global-large.css';
import globalMediumStylesUrl from '@/styles/global-medium.css';
import globalStylesUrl from '@/styles/global.css';

export const links: LinksFunction = () => [
  { rel: 'stylesheet', href: globalStylesUrl },
  {
    rel: 'stylesheet',
    href: globalMediumStylesUrl,
    media: 'print, (min-width: 640px)',
  },
  {
    rel: 'stylesheet',
    href: globalLargeStylesUrl,
    media: 'screen and (min-width: 1024px)',
  },
];

export const meta: MetaFunction = () => {
  const description = 'Learn Remix and laugh at the same time!';

  return [
    { name: 'description', content: description },
    { name: 'twitter:description', content: description },
    { title: "Remix: So great, it's funny!" },
  ];
};

function Document({ children, title }: PropsWithChildren<{ title?: string }>) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="keywords" content="Remix,jokes" />
        <meta name="twitter:image" content="https://remix-jokes.lol/social.png" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:creator" content="@remix_run" />
        <meta name="twitter:site" content="@remix_run" />
        <meta name="twitter:title" content="Remix Jokes" />
        <Meta />
        {title ? <title>{title}</title> : null}
        <Links />
      </head>
      <body>
        {children}
        <LiveReload />
      </body>
    </html>
  );
}

export default function App() {
  return (
    <Document>
      <Outlet />
    </Document>
  );
}

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    return (
      <Document title={`${error.status} ${error.statusText}`}>
        <div className="error-container">
          <h1>
            {error.status} {error.statusText}
          </h1>
        </div>
      </Document>
    );
  }

  const errorMessage = error instanceof Error ? error.message : 'Unknown error';
  return (
    <Document title="Uh-oh!">
      <div className="error-container">
        <h1>App Error</h1>
        <pre>{errorMessage}</pre>
      </div>
    </Document>
  );
}
```

</details>

<details>

<summary>app/routes/login.tsx</summary>

```tsx filename=app/routes/login.tsx lines=[4,25-34]
import type { ActionFunctionArgs, LinksFunction, MetaFunction } from '@remix-run/node';
import { Link, useActionData, useSearchParams } from '@remix-run/react';

import stylesUrl from '@/styles/login.css';
import { db } from '@/utils/db.server';
import { badRequest } from '@/utils/request.server';
import { createUserSession, login, register } from '@/utils/session.server';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

export const meta: MetaFunction = () => {
  const description = 'Login to submit your own jokes to Remix Jokes!';

  return [
    { name: 'description', content: description },
    { name: 'twitter:description', content: description },
    { title: 'Remix Jokes | Login' },
  ];
};

function validateUsername(username: string) {
  if (username.length < 3) {
    return 'Usernames must be at least 3 characters long';
  }
}

function validatePassword(password: string) {
  if (password.length < 6) {
    return 'Passwords must be at least 6 characters long';
  }
}

function validateUrl(url: string) {
  const urls = ['/jokes', '/', 'https://remix.run'];
  if (urls.includes(url)) {
    return url;
  }
  return '/jokes';
}

export const action = async ({ request }: ActionFunctionArgs) => {
  const form = await request.formData();
  const loginType = form.get('loginType');
  const password = form.get('password');
  const username = form.get('username');
  const redirectTo = validateUrl((form.get('redirectTo') as string) || '/jokes');
  if (
    typeof loginType !== 'string' ||
    typeof password !== 'string' ||
    typeof username !== 'string'
  ) {
    return badRequest({
      fieldErrors: null,
      fields: null,
      formError: 'Form not submitted correctly.',
    });
  }

  const fields = { loginType, password, username };
  const fieldErrors = {
    password: validatePassword(password),
    username: validateUsername(username),
  };
  if (Object.values(fieldErrors).some(Boolean)) {
    return badRequest({
      fieldErrors,
      fields,
      formError: null,
    });
  }

  switch (loginType) {
    case 'login': {
      const user = await login({ username, password });
      console.log({ user });
      if (!user) {
        return badRequest({
          fieldErrors: null,
          fields,
          formError: 'Username/Password combination is incorrect',
        });
      }
      return createUserSession(user.id, redirectTo);
    }
    case 'register': {
      const userExists = await db.user.findFirst({
        where: { username },
      });
      if (userExists) {
        return badRequest({
          fieldErrors: null,
          fields,
          formError: `User with username ${username} already exists`,
        });
      }
      const user = await register({ username, password });
      if (!user) {
        return badRequest({
          fieldErrors: null,
          fields,
          formError: 'Something went wrong trying to create a new user.',
        });
      }
      return createUserSession(user.id, redirectTo);
    }
    default: {
      return badRequest({
        fieldErrors: null,
        fields,
        formError: 'Login type invalid',
      });
    }
  }
};

export default function Login() {
  const actionData = useActionData<typeof action>();
  const [searchParams] = useSearchParams();
  return (
    <div className="container">
      <div className="content" data-light="">
        <h1>Login</h1>
        <form method="post">
          <input
            type="hidden"
            name="redirectTo"
            value={searchParams.get('redirectTo') ?? undefined}
          />
          <fieldset>
            <legend className="sr-only">Login or Register?</legend>
            <label>
              <input
                type="radio"
                name="loginType"
                value="login"
                defaultChecked={
                  !actionData?.fields?.loginType || actionData?.fields?.loginType === 'login'
                }
              />{' '}
              Login
            </label>
            <label>
              <input
                type="radio"
                name="loginType"
                value="register"
                defaultChecked={actionData?.fields?.loginType === 'register'}
              />{' '}
              Register
            </label>
          </fieldset>
          <div>
            <label htmlFor="username-input">Username</label>
            <input
              type="text"
              id="username-input"
              name="username"
              defaultValue={actionData?.fields?.username}
              aria-invalid={Boolean(actionData?.fieldErrors?.username)}
              aria-errormessage={actionData?.fieldErrors?.username ? 'username-error' : undefined}
            />
            {actionData?.fieldErrors?.username ? (
              <p className="form-validation-error" role="alert" id="username-error">
                {actionData.fieldErrors.username}
              </p>
            ) : null}
          </div>
          <div>
            <label htmlFor="password-input">Password</label>
            <input
              id="password-input"
              name="password"
              type="password"
              defaultValue={actionData?.fields?.password}
              aria-invalid={Boolean(actionData?.fieldErrors?.password)}
              aria-errormessage={actionData?.fieldErrors?.password ? 'password-error' : undefined}
            />
            {actionData?.fieldErrors?.password ? (
              <p className="form-validation-error" role="alert" id="password-error">
                {actionData.fieldErrors.password}
              </p>
            ) : null}
          </div>
          <div id="form-error-message">
            {actionData?.formError ? (
              <p className="form-validation-error" role="alert">
                {actionData.formError}
              </p>
            ) : null}
          </div>
          <button type="submit" className="button">
            Submit
          </button>
        </form>
      </div>
      <div className="links">
        <ul>
          <li>
            <Link to="/">Home</Link>
          </li>
          <li>
            <Link to="/jokes">Jokes</Link>
          </li>
        </ul>
      </div>
    </div>
  );
}
```

</details>

<details>

<summary>app/routes/jokes.$jokeId.tsx</summary>

```tsx filename=app/routes/jokes.$jokeId.tsx lines=[4,21-36]
import type { ActionFunctionArgs, LoaderFunctionArgs, MetaFunction } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
import {
  isRouteErrorResponse,
  Link,
  useLoaderData,
  useParams,
  useRouteError,
} from '@remix-run/react';

import { db } from '@/utils/db.server';
import { getUserId, requireUserId } from '@/utils/session.server';

export const meta: MetaFunction<typeof loader> = ({ data }) => {
  const { description, title } = data
    ? {
        description: `Enjoy the "${data.joke.name}" joke and much more`,
        title: `"${data.joke.name}" joke`,
      }
    : { description: 'No joke found', title: 'No joke' };

  return [
    { name: 'description', content: description },
    { name: 'twitter:description', content: description },
    { title },
  ];
};

export const loader = async ({ params, request }: LoaderFunctionArgs) => {
  const userId = await getUserId(request);
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Response('What a joke! Not found.', {
      status: 404,
    });
  }
  return json({
    isOwner: userId === joke.jokesterId,
    joke,
  });
};

export const action = async ({ params, request }: ActionFunctionArgs) => {
  const form = await request.formData();
  if (form.get('intent') !== 'delete') {
    throw new Response(`The intent ${form.get('intent')} is not supported`, { status: 400 });
  }
  const userId = await requireUserId(request);
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Response("Can't delete what does not exist", {
      status: 404,
    });
  }
  if (joke.jokesterId !== userId) {
    throw new Response("Pssh, nice try. That's not your joke", { status: 403 });
  }
  await db.joke.delete({ where: { id: params.jokeId } });
  return redirect('/jokes');
};

export default function JokeRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div>
      <p>Here's your hilarious joke:</p>
      <p>{data.joke.content}</p>
      <Link to=".">"{data.joke.name}" Permalink</Link>
      {data.isOwner ? (
        <form method="post">
          <button className="button" name="intent" type="submit" value="delete">
            Delete
          </button>
        </form>
      ) : null}
    </div>
  );
}

export function ErrorBoundary() {
  const { jokeId } = useParams();
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    if (error.status === 400) {
      return <div className="error-container">What you're trying to do is not allowed.</div>;
    }
    if (error.status === 403) {
      return <div className="error-container">Sorry, but "{jokeId}" is not your joke.</div>;
    }
    if (error.status === 404) {
      return <div className="error-container">Huh? What the heck is "{jokeId}"?</div>;
    }
  }

  return (
    <div className="error-container">
      There was an error loading joke by the id "${jokeId}". Sorry.
    </div>
  );
}
```

</details>

Sweet! Now search engines and social media platforms will like our site a bit better.

## Resource Routes

Sometimes we want our routes to render something other than an HTML document. For example, maybe you have an endpoint that generates your social image for a blog post, or the image for a product, or the CSV data for a report, or an RSS feed, or sitemap, or maybe you want to implement API routes for your mobile app, or anything else.

This is what [Resource Routes][resource-routes] are for. I think it'd be cool to have an RSS feed of all our jokes. I think it would make sense to be at the URL `/jokes.rss`. For that to work, you'll need to escape the `.` because that character has special meaning in Remix route filenames. Learn more about [escaping special characters here][escaping-special-characters-here].

<docs-info>Believe it or not, you've actually already made one of these. Check out your logout route! No UI necessary because it's just there to handle mutations and redirect lost souls.</docs-info>

For this one, you'll probably want to at least peek at the example unless you want to go read up on the RSS spec üòÖ.

üíø Make a `/jokes.rss` route.

<details>

<summary>app/routes/jokes[.]rss.tsx</summary>

```tsx filename=app/routes/jokes[.]rss.tsx
import type { LoaderFunctionArgs } from '@remix-run/node';

import { db } from '@/utils/db.server';

function escapeCdata(s: string) {
  return s.replace(/\]\]>/g, ']]]]><![CDATA[>');
}

function escapeHtml(s: string) {
  return s
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const jokes = await db.joke.findMany({
    include: { jokester: { select: { username: true } } },
    orderBy: { createdAt: 'desc' },
    take: 100,
  });

  const host = request.headers.get('X-Forwarded-Host') ?? request.headers.get('host');
  if (!host) {
    throw new Error('Could not determine domain URL.');
  }
  const protocol = host.includes('localhost') ? 'http' : 'https';
  const domain = `${protocol}://${host}`;
  const jokesUrl = `${domain}/jokes`;

  const rssString = `
    <rss xmlns:blogChannel="${jokesUrl}" version="2.0">
      <channel>
        <title>Remix Jokes</title>
        <link>${jokesUrl}</link>
        <description>Some funny jokes</description>
        <language>en-us</language>
        <generator>Kody the Koala</generator>
        <ttl>40</ttl>
        ${jokes
          .map((joke) =>
            `
            <item>
              <title><![CDATA[${escapeCdata(joke.name)}]]></title>
              <description><![CDATA[A funny joke called ${escapeHtml(joke.name)}]]></description>
              <author><![CDATA[${escapeCdata(joke.jokester.username)}]]></author>
              <pubDate>${joke.createdAt.toUTCString()}</pubDate>
              <link>${jokesUrl}/${joke.id}</link>
              <guid>${jokesUrl}/${joke.id}</guid>
            </item>
          `.trim(),
          )
          .join('\n')}
      </channel>
    </rss>
  `.trim();

  return new Response(rssString, {
    headers: {
      'Cache-Control': `public, max-age=${60 * 10}, s-maxage=${60 * 60 * 24}`,
      'Content-Type': 'application/xml',
      'Content-Length': String(Buffer.byteLength(rssString)),
    },
  });
};
```

</details>

![XML document for RSS feed][xml-document-for-rss-feed]

Wahoo! You can seriously do anything you can imagine with this API. You could even make a JSON API for a native version of your app if you wanted to. Lots of power here.

üíø Feel free to throw a link to that RSS feed on `app/routes/_index.tsx` and `app/routes/jokes.tsx` pages. Note that if you use `<Link />` you'll want to use the `reloadDocument` prop because you can't do a client-side transition to a URL that's not technically part of the React app.

<details>

<summary>app/routes/_index.tsx</summary>

```tsx filename=app/routes/_index.tsx lines=[22-26]
import type { LinksFunction } from '@remix-run/node';
import { Link } from '@remix-run/react';

import stylesUrl from '@/styles/index.css';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

export default function IndexRoute() {
  return (
    <div className="container">
      <div className="content">
        <h1>
          Remix <span>Jokes!</span>
        </h1>
        <nav>
          <ul>
            <li>
              <Link to="jokes">Read Jokes</Link>
            </li>
            <li>
              <Link reloadDocument to="/jokes.rss">
                RSS
              </Link>
            </li>
          </ul>
        </nav>
      </div>
    </div>
  );
}
```

</details>

<details>

<summary>app/routes/jokes.tsx</summary>

```tsx filename=app/routes/jokes.tsx lines=[85-91]
import type { LinksFunction, LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import { Link, Outlet, useLoaderData } from '@remix-run/react';

import stylesUrl from '@/styles/jokes.css';
import { db } from '@/utils/db.server';
import { getUser } from '@/utils/session.server';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const jokeListItems = await db.joke.findMany({
    orderBy: { createdAt: 'desc' },
    select: { id: true, name: true },
    take: 5,
  });
  const user = await getUser(request);

  return json({ jokeListItems, user });
};

export default function JokesRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div className="jokes-layout">
      <header className="jokes-header">
        <div className="container">
          <h1 className="home-link">
            <Link to="/" title="Remix Jokes" aria-label="Remix Jokes">
              <span className="logo">ü§™</span>
              <span className="logo-medium">Jü§™KES</span>
            </Link>
          </h1>
          {data.user ? (
            <div className="user-info">
              <span>{`Hi ${data.user.username}`}</span>
              <form action="/logout" method="post">
                <button type="submit" className="button">
                  Logout
                </button>
              </form>
            </div>
          ) : (
            <Link to="/login">Login</Link>
          )}
        </div>
      </header>
      <main className="jokes-main">
        <div className="container">
          <div className="jokes-list">
            <Link to=".">Get a random joke</Link>
            <p>Here are a few more jokes to check out:</p>
            <ul>
              {data.jokeListItems.map(({ id, name }) => (
                <li key={id}>
                  <Link to={id}>{name}</Link>
                </li>
              ))}
            </ul>
            <Link to="new" className="button">
              Add your own
            </Link>
          </div>
          <div className="jokes-outlet">
            <Outlet />
          </div>
        </div>
      </main>
      <footer className="jokes-footer">
        <div className="container">
          <Link reloadDocument to="/jokes.rss">
            RSS
          </Link>
        </div>
      </footer>
    </div>
  );
}
```

</details>

## JavaScript...

Maybe we should actually include JavaScript on our JavaScript app. üòÇ

Seriously, pull up your network tab and navigate to our app.

![Network tab indicating no JavaScript is loaded][network-tab-indicating-no-java-script-is-loaded]

Did you notice that our app isn't loading any JavaScript before now? üòÜ This actually is pretty significant. Our entire app can work without JavaScript on the page at all. This is because Remix leverages the platform so well for us.

Why does it matter that our app works without JavaScript? Is it because we're worried about the 0.002% of users who run around with JS disabled? Not really. It's because not everyone's connected to your app on a lightning-fast connection and sometimes JavaScript takes some time to load or fails to load at all. Making your app functional without JavaScript means that when that happens, your app _still works_ for your users even before the JavaScript finishes loading.

Another point for user experience!

There are reasons to include JavaScript on the page. For example, some common UI experiences can't be accessible without JavaScript (focus management in particular is not great when you have full-page reloads all over the place). And we can make an even nicer user experience with optimistic UI (coming soon) when we have JavaScript on the page. But we thought it'd be cool to show you how far you can get with Remix without JavaScript for your users on poor network connections. üí™

Ok, so let's load JavaScript on this page now üòÜ

üíø Use Remix's [`<Scripts />` component][scripts-component] to load all the JavaScript files in `app/root.tsx`.

<details>

<summary>app/root.tsx</summary>

```tsx filename=app/root.tsx lines=[11,75]
import type { LinksFunction, MetaFunction } from '@remix-run/node';
import {
  isRouteErrorResponse,
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  useRouteError,
} from '@remix-run/react';
import type { PropsWithChildren } from 'react';

import globalLargeStylesUrl from '@/styles/global-large.css';
import globalMediumStylesUrl from '@/styles/global-medium.css';
import globalStylesUrl from '@/styles/global.css';

export const links: LinksFunction = () => [
  { rel: 'stylesheet', href: globalStylesUrl },
  {
    rel: 'stylesheet',
    href: globalMediumStylesUrl,
    media: 'print, (min-width: 640px)',
  },
  {
    rel: 'stylesheet',
    href: globalLargeStylesUrl,
    media: 'screen and (min-width: 1024px)',
  },
];

export const meta: MetaFunction = () => {
  const description = 'Learn Remix and laugh at the same time!';

  return [
    { name: 'description', content: description },
    { name: 'twitter:description', content: description },
    { title: "Remix: So great, it's funny!" },
  ];
};

function Document({ children, title }: PropsWithChildren<{ title?: string }>) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="keywords" content="Remix,jokes" />
        <meta name="twitter:image" content="https://remix-jokes.lol/social.png" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:creator" content="@remix_run" />
        <meta name="twitter:site" content="@remix_run" />
        <meta name="twitter:title" content="Remix Jokes" />
        <Meta />
        {title ? <title>{title}</title> : null}
        <Links />
      </head>
      <body>
        {children}
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}

export default function App() {
  return (
    <Document>
      <Outlet />
    </Document>
  );
}

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    return (
      <Document title={`${error.status} ${error.statusText}`}>
        <div className="error-container">
          <h1>
            {error.status} {error.statusText}
          </h1>
        </div>
      </Document>
    );
  }

  const errorMessage = error instanceof Error ? error.message : 'Unknown error';
  return (
    <Document title="Uh-oh!">
      <div className="error-container">
        <h1>App Error</h1>
        <pre>{errorMessage}</pre>
      </div>
    </Document>
  );
}
```

</details>

![Network tab showing JavaScript loaded][network-tab-showing-java-script-loaded]

üíø Another thing we can do now is you can `console.error(error);` in all your `ErrorBoundary` components, and you'll get even server-side errors logged in the browser's console. ü§Ø

<details>

<summary>app/root.tsx</summary>

```tsx filename=app/root.tsx lines=[92]
import type { LinksFunction, MetaFunction } from '@remix-run/node';
import {
  isRouteErrorResponse,
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  useRouteError,
} from '@remix-run/react';
import type { PropsWithChildren } from 'react';

import globalLargeStylesUrl from '@/styles/global-large.css';
import globalMediumStylesUrl from '@/styles/global-medium.css';
import globalStylesUrl from '@/styles/global.css';

export const links: LinksFunction = () => [
  { rel: 'stylesheet', href: globalStylesUrl },
  {
    rel: 'stylesheet',
    href: globalMediumStylesUrl,
    media: 'print, (min-width: 640px)',
  },
  {
    rel: 'stylesheet',
    href: globalLargeStylesUrl,
    media: 'screen and (min-width: 1024px)',
  },
];

export const meta: MetaFunction = () => {
  const description = 'Learn Remix and laugh at the same time!';

  return [
    { name: 'description', content: description },
    { name: 'twitter:description', content: description },
    { title: "Remix: So great, it's funny!" },
  ];
};

function Document({ children, title }: PropsWithChildren<{ title?: string }>) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="keywords" content="Remix,jokes" />
        <meta name="twitter:image" content="https://remix-jokes.lol/social.png" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:creator" content="@remix_run" />
        <meta name="twitter:site" content="@remix_run" />
        <meta name="twitter:title" content="Remix Jokes" />
        <Meta />
        {title ? <title>{title}</title> : null}
        <Links />
      </head>
      <body>
        {children}
        <Scripts />
        <LiveReload />
      </body>
    </html>
  );
}

export default function App() {
  return (
    <Document>
      <Outlet />
    </Document>
  );
}

export function ErrorBoundary() {
  const error = useRouteError();
  console.error(error);

  if (isRouteErrorResponse(error)) {
    return (
      <Document title={`${error.status} ${error.statusText}`}>
        <div className="error-container">
          <h1>
            {error.status} {error.statusText}
          </h1>
        </div>
      </Document>
    );
  }

  const errorMessage = error instanceof Error ? error.message : 'Unknown error';
  return (
    <Document title="Uh-oh!">
      <div className="error-container">
        <h1>App Error</h1>
        <pre>{errorMessage}</pre>
      </div>
    </Document>
  );
}
```

</details>

<details>

<summary>app/routes/jokes.$jokeId.tsx</summary>

```tsx filename=app/routes/jokes.$jokeId.tsx lines=[114]
import type { ActionFunctionArgs, LoaderFunctionArgs, MetaFunction } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
import {
  isRouteErrorResponse,
  Link,
  useLoaderData,
  useParams,
  useRouteError,
} from '@remix-run/react';

import { db } from '@/utils/db.server';
import { getUserId, requireUserId } from '@/utils/session.server';

export const meta: MetaFunction<typeof loader> = ({ data }) => {
  const { description, title } = data
    ? {
        description: `Enjoy the "${data.joke.name}" joke and much more`,
        title: `"${data.joke.name}" joke`,
      }
    : { description: 'No joke found', title: 'No joke' };

  return [
    { name: 'description', content: description },
    { name: 'twitter:description', content: description },
    { title },
  ];
};

export const loader = async ({ params, request }: LoaderFunctionArgs) => {
  const userId = await getUserId(request);
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Response('What a joke! Not found.', {
      status: 404,
    });
  }
  return json({
    isOwner: userId === joke.jokesterId,
    joke,
  });
};

export const action = async ({ params, request }: ActionFunctionArgs) => {
  const form = await request.formData();
  if (form.get('intent') !== 'delete') {
    throw new Response(`The intent ${form.get('intent')} is not supported`, { status: 400 });
  }
  const userId = await requireUserId(request);
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Response("Can't delete what does not exist", {
      status: 404,
    });
  }
  if (joke.jokesterId !== userId) {
    throw new Response("Pssh, nice try. That's not your joke", { status: 403 });
  }
  await db.joke.delete({ where: { id: params.jokeId } });
  return redirect('/jokes');
};

export default function JokeRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div>
      <p>Here's your hilarious joke:</p>
      <p>{data.joke.content}</p>
      <Link to=".">"{data.joke.name}" Permalink</Link>
      {data.isOwner ? (
        <form method="post">
          <button className="button" name="intent" type="submit" value="delete">
            Delete
          </button>
        </form>
      ) : null}
    </div>
  );
}

export function ErrorBoundary() {
  const { jokeId } = useParams();
  const error = useRouteError();
  console.error(error);

  if (isRouteErrorResponse(error)) {
    if (error.status === 400) {
      return <div className="error-container">What you're trying to do is not allowed.</div>;
    }
    if (error.status === 403) {
      return <div className="error-container">Sorry, but "{jokeId}" is not your joke.</div>;
    }
    if (error.status === 404) {
      return <div className="error-container">Huh? What the heck is "{jokeId}"?</div>;
    }
  }

  return (
    <div className="error-container">
      There was an error loading joke by the id "${jokeId}". Sorry.
    </div>
  );
}
```

</details>

<details>

<summary>app/routes/jokes._index.tsx</summary>

```tsx filename=app/routes/jokes._index.tsx lines=[42]
import { json } from '@remix-run/node';
import { isRouteErrorResponse, Link, useLoaderData, useRouteError } from '@remix-run/react';

import { db } from '@/utils/db.server';

export const loader = async () => {
  const count = await db.joke.count();
  const randomRowNumber = Math.floor(Math.random() * count);
  const [randomJoke] = await db.joke.findMany({
    skip: randomRowNumber,
    take: 1,
  });
  if (!randomJoke) {
    throw new Response('No random joke found', {
      status: 404,
    });
  }
  return json({ randomJoke });
};

export default function JokesIndexRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div>
      <p>Here's a random joke:</p>
      <p>{data.randomJoke.content}</p>
      <Link to={data.randomJoke.id}>"{data.randomJoke.name}" Permalink</Link>
    </div>
  );
}

export function ErrorBoundary() {
  const error = useRouteError();
  console.error(error);

  if (isRouteErrorResponse(error) && error.status === 404) {
    return (
      <div className="error-container">
        <p>There are no jokes to display.</p>
        <Link to="new">Add your own</Link>
      </div>
    );
  }

  return <div className="error-container">I did a whoopsies.</div>;
}
```

</details>

<details>

<summary>app/routes/jokes.new.tsx</summary>

```tsx filename=app/routes/jokes.new.tsx lines=[159]
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
import { isRouteErrorResponse, Link, useActionData, useRouteError } from '@remix-run/react';

import { db } from '@/utils/db.server';
import { badRequest } from '@/utils/request.server';
import { getUserId, requireUserId } from '@/utils/session.server';

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const userId = await getUserId(request);
  if (!userId) {
    throw new Response('Unauthorized', { status: 401 });
  }
  return json({});
};

function validateJokeContent(content: string) {
  if (content.length < 10) {
    return 'That joke is too short';
  }
}

function validateJokeName(name: string) {
  if (name.length < 3) {
    return "That joke's name is too short";
  }
}

export const action = async ({ request }: ActionFunctionArgs) => {
  const userId = await requireUserId(request);
  const form = await request.formData();
  const content = form.get('content');
  const name = form.get('name');
  if (typeof content !== 'string' || typeof name !== 'string') {
    return badRequest({
      fieldErrors: null,
      fields: null,
      formError: 'Form not submitted correctly.',
    });
  }

  const fieldErrors = {
    content: validateJokeContent(content),
    name: validateJokeName(name),
  };
  const fields = { content, name };
  if (Object.values(fieldErrors).some(Boolean)) {
    return badRequest({
      fieldErrors,
      fields,
      formError: null,
    });
  }

  const joke = await db.joke.create({
    data: { ...fields, jokesterId: userId },
  });
  return redirect(`/jokes/${joke.id}`);
};

export default function NewJokeRoute() {
  const actionData = useActionData<typeof action>();

  return (
    <div>
      <p>Add your own hilarious joke</p>
      <form method="post">
        <div>
          <label>
            Name:{' '}
            <input
              defaultValue={actionData?.fields?.name}
              name="name"
              type="text"
              aria-invalid={Boolean(actionData?.fieldErrors?.name)}
              aria-errormessage={actionData?.fieldErrors?.name ? 'name-error' : undefined}
            />
          </label>
          {actionData?.fieldErrors?.name ? (
            <p className="form-validation-error" id="name-error" role="alert">
              {actionData.fieldErrors.name}
            </p>
          ) : null}
        </div>
        <div>
          <label>
            Content:{' '}
            <textarea
              defaultValue={actionData?.fields?.content}
              name="content"
              aria-invalid={Boolean(actionData?.fieldErrors?.content)}
              aria-errormessage={actionData?.fieldErrors?.content ? 'content-error' : undefined}
            />
          </label>
          {actionData?.fieldErrors?.content ? (
            <p className="form-validation-error" id="content-error" role="alert">
              {actionData.fieldErrors.content}
            </p>
          ) : null}
        </div>
        <div>
          {actionData?.formError ? (
            <p className="form-validation-error" role="alert">
              {actionData.formError}
            </p>
          ) : null}
          <button type="submit" className="button">
            Add
          </button>
        </div>
      </form>
    </div>
  );
}

export function ErrorBoundary() {
  const error = useRouteError();
  console.error(error);

  if (isRouteErrorResponse(error) && error.status === 401) {
    return (
      <div className="error-container">
        <p>You must be logged in to create a joke.</p>
        <Link to="/login">Login</Link>
      </div>
    );
  }

  return <div className="error-container">Something unexpected went wrong. Sorry about that.</div>;
}
```

</details>

![Browser console showing the log of a server-side error][browser-console-showing-the-log-of-a-server-side-error]

### Forms

Remix has its own [`<Form />`][form-component] component. When JavaScript is not yet loaded, it works the same way as a regular form, but when JavaScript is enabled, it's "progressively enhanced" to make a `fetch` request instead, so we don't do a full-page reload.

üíø Find all `<form />` elements and change them to the Remix `<Form />` component.

<details>

<summary>app/routes/login.tsx</summary>

```tsx filename=app/routes/login.tsx lines=[7,145,247]
import type { ActionFunctionArgs, LinksFunction, MetaFunction } from '@remix-run/node';
import { Form, Link, useActionData, useSearchParams } from '@remix-run/react';

import stylesUrl from '@/styles/login.css';
import { db } from '@/utils/db.server';
import { badRequest } from '@/utils/request.server';
import { createUserSession, login, register } from '@/utils/session.server';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

export const meta: MetaFunction = () => {
  const description = 'Login to submit your own jokes to Remix Jokes!';

  return [
    { name: 'description', content: description },
    { name: 'twitter:description', content: description },
    { title: 'Remix Jokes | Login' },
  ];
};

function validateUsername(username: string) {
  if (username.length < 3) {
    return 'Usernames must be at least 3 characters long';
  }
}

function validatePassword(password: string) {
  if (password.length < 6) {
    return 'Passwords must be at least 6 characters long';
  }
}

function validateUrl(url: string) {
  const urls = ['/jokes', '/', 'https://remix.run'];
  if (urls.includes(url)) {
    return url;
  }
  return '/jokes';
}

export const action = async ({ request }: ActionFunctionArgs) => {
  const form = await request.formData();
  const loginType = form.get('loginType');
  const password = form.get('password');
  const username = form.get('username');
  const redirectTo = validateUrl((form.get('redirectTo') as string) || '/jokes');
  if (
    typeof loginType !== 'string' ||
    typeof password !== 'string' ||
    typeof username !== 'string'
  ) {
    return badRequest({
      fieldErrors: null,
      fields: null,
      formError: 'Form not submitted correctly.',
    });
  }

  const fields = { loginType, password, username };
  const fieldErrors = {
    password: validatePassword(password),
    username: validateUsername(username),
  };
  if (Object.values(fieldErrors).some(Boolean)) {
    return badRequest({
      fieldErrors,
      fields,
      formError: null,
    });
  }

  switch (loginType) {
    case 'login': {
      const user = await login({ username, password });
      console.log({ user });
      if (!user) {
        return badRequest({
          fieldErrors: null,
          fields,
          formError: 'Username/Password combination is incorrect',
        });
      }
      return createUserSession(user.id, redirectTo);
    }
    case 'register': {
      const userExists = await db.user.findFirst({
        where: { username },
      });
      if (userExists) {
        return badRequest({
          fieldErrors: null,
          fields,
          formError: `User with username ${username} already exists`,
        });
      }
      const user = await register({ username, password });
      if (!user) {
        return badRequest({
          fieldErrors: null,
          fields,
          formError: 'Something went wrong trying to create a new user.',
        });
      }
      return createUserSession(user.id, redirectTo);
    }
    default: {
      return badRequest({
        fieldErrors: null,
        fields,
        formError: 'Login type invalid',
      });
    }
  }
};

export default function Login() {
  const actionData = useActionData<typeof action>();
  const [searchParams] = useSearchParams();
  return (
    <div className="container">
      <div className="content" data-light="">
        <h1>Login</h1>
        <Form method="post">
          <input
            type="hidden"
            name="redirectTo"
            value={searchParams.get('redirectTo') ?? undefined}
          />
          <fieldset>
            <legend className="sr-only">Login or Register?</legend>
            <label>
              <input
                type="radio"
                name="loginType"
                value="login"
                defaultChecked={
                  !actionData?.fields?.loginType || actionData?.fields?.loginType === 'login'
                }
              />{' '}
              Login
            </label>
            <label>
              <input
                type="radio"
                name="loginType"
                value="register"
                defaultChecked={actionData?.fields?.loginType === 'register'}
              />{' '}
              Register
            </label>
          </fieldset>
          <div>
            <label htmlFor="username-input">Username</label>
            <input
              type="text"
              id="username-input"
              name="username"
              defaultValue={actionData?.fields?.username}
              aria-invalid={Boolean(actionData?.fieldErrors?.username)}
              aria-errormessage={actionData?.fieldErrors?.username ? 'username-error' : undefined}
            />
            {actionData?.fieldErrors?.username ? (
              <p className="form-validation-error" role="alert" id="username-error">
                {actionData.fieldErrors.username}
              </p>
            ) : null}
          </div>
          <div>
            <label htmlFor="password-input">Password</label>
            <input
              id="password-input"
              name="password"
              type="password"
              defaultValue={actionData?.fields?.password}
              aria-invalid={Boolean(actionData?.fieldErrors?.password)}
              aria-errormessage={actionData?.fieldErrors?.password ? 'password-error' : undefined}
            />
            {actionData?.fieldErrors?.password ? (
              <p className="form-validation-error" role="alert" id="password-error">
                {actionData.fieldErrors.password}
              </p>
            ) : null}
          </div>
          <div id="form-error-message">
            {actionData?.formError ? (
              <p className="form-validation-error" role="alert">
                {actionData.formError}
              </p>
            ) : null}
          </div>
          <button type="submit" className="button">
            Submit
          </button>
        </Form>
      </div>
      <div className="links">
        <ul>
          <li>
            <Link to="/">Home</Link>
          </li>
          <li>
            <Link to="/jokes">Jokes</Link>
          </li>
        </ul>
      </div>
    </div>
  );
}
```

</details>

<details>

<summary>app/routes/jokes.tsx</summary>

```tsx filename=app/routes/jokes.tsx lines=[7,54,58]
import type { LinksFunction, LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import { Form, Link, Outlet, useLoaderData } from '@remix-run/react';

import stylesUrl from '@/styles/jokes.css';
import { db } from '@/utils/db.server';
import { getUser } from '@/utils/session.server';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const jokeListItems = await db.joke.findMany({
    orderBy: { createdAt: 'desc' },
    select: { id: true, name: true },
    take: 5,
  });
  const user = await getUser(request);

  return json({ jokeListItems, user });
};

export default function JokesRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div className="jokes-layout">
      <header className="jokes-header">
        <div className="container">
          <h1 className="home-link">
            <Link to="/" title="Remix Jokes" aria-label="Remix Jokes">
              <span className="logo">ü§™</span>
              <span className="logo-medium">Jü§™KES</span>
            </Link>
          </h1>
          {data.user ? (
            <div className="user-info">
              <span>{`Hi ${data.user.username}`}</span>
              <Form action="/logout" method="post">
                <button type="submit" className="button">
                  Logout
                </button>
              </Form>
            </div>
          ) : (
            <Link to="/login">Login</Link>
          )}
        </div>
      </header>
      <main className="jokes-main">
        <div className="container">
          <div className="jokes-list">
            <Link to=".">Get a random joke</Link>
            <p>Here are a few more jokes to check out:</p>
            <ul>
              {data.jokeListItems.map(({ id, name }) => (
                <li key={id}>
                  <Link to={id}>{name}</Link>
                </li>
              ))}
            </ul>
            <Link to="new" className="button">
              Add your own
            </Link>
          </div>
          <div className="jokes-outlet">
            <Outlet />
          </div>
        </div>
      </main>
      <footer className="jokes-footer">
        <div className="container">
          <Link reloadDocument to="/jokes.rss">
            RSS
          </Link>
        </div>
      </footer>
    </div>
  );
}
```

</details>

<details>

<summary>app/routes/jokes.$jokeId.tsx</summary>

```tsx filename=app/routes/jokes.$jokeId.tsx lines=[8,97,106]
import type { ActionFunctionArgs, LoaderFunctionArgs, MetaFunction } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
import {
  Form,
  isRouteErrorResponse,
  Link,
  useLoaderData,
  useParams,
  useRouteError,
} from '@remix-run/react';

import { db } from '@/utils/db.server';
import { getUserId, requireUserId } from '@/utils/session.server';

export const meta: MetaFunction<typeof loader> = ({ data }) => {
  const { description, title } = data
    ? {
        description: `Enjoy the "${data.joke.name}" joke and much more`,
        title: `"${data.joke.name}" joke`,
      }
    : { description: 'No joke found', title: 'No joke' };

  return [
    { name: 'description', content: description },
    { name: 'twitter:description', content: description },
    { title },
  ];
};

export const loader = async ({ params, request }: LoaderFunctionArgs) => {
  const userId = await getUserId(request);
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Response('What a joke! Not found.', {
      status: 404,
    });
  }
  return json({
    isOwner: userId === joke.jokesterId,
    joke,
  });
};

export const action = async ({ params, request }: ActionFunctionArgs) => {
  const form = await request.formData();
  if (form.get('intent') !== 'delete') {
    throw new Response(`The intent ${form.get('intent')} is not supported`, { status: 400 });
  }
  const userId = await requireUserId(request);
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Response("Can't delete what does not exist", {
      status: 404,
    });
  }
  if (joke.jokesterId !== userId) {
    throw new Response("Pssh, nice try. That's not your joke", { status: 403 });
  }
  await db.joke.delete({ where: { id: params.jokeId } });
  return redirect('/jokes');
};

export default function JokeRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div>
      <p>Here's your hilarious joke:</p>
      <p>{data.joke.content}</p>
      <Link to=".">"{data.joke.name}" Permalink</Link>
      {data.isOwner ? (
        <Form method="post">
          <button className="button" name="intent" type="submit" value="delete">
            Delete
          </button>
        </Form>
      ) : null}
    </div>
  );
}

export function ErrorBoundary() {
  const { jokeId } = useParams();
  const error = useRouteError();
  console.error(error);

  if (isRouteErrorResponse(error)) {
    if (error.status === 400) {
      return <div className="error-container">What you're trying to do is not allowed.</div>;
    }
    if (error.status === 403) {
      return <div className="error-container">Sorry, but "{jokeId}" is not your joke.</div>;
    }
    if (error.status === 404) {
      return <div className="error-container">Huh? What the heck is "{jokeId}"?</div>;
    }
  }

  return (
    <div className="error-container">
      There was an error loading joke by the id "${jokeId}". Sorry.
    </div>
  );
}
```

</details>

<details>

<summary>app/routes/jokes.new.tsx</summary>

```tsx filename=app/routes/jokes.new.tsx lines=[7,86,153]
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
import { Form, isRouteErrorResponse, Link, useActionData, useRouteError } from '@remix-run/react';

import { db } from '@/utils/db.server';
import { badRequest } from '@/utils/request.server';
import { getUserId, requireUserId } from '@/utils/session.server';

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const userId = await getUserId(request);
  if (!userId) {
    throw new Response('Unauthorized', { status: 401 });
  }
  return json({});
};

function validateJokeContent(content: string) {
  if (content.length < 10) {
    return 'That joke is too short';
  }
}

function validateJokeName(name: string) {
  if (name.length < 3) {
    return "That joke's name is too short";
  }
}

export const action = async ({ request }: ActionFunctionArgs) => {
  const userId = await requireUserId(request);
  const form = await request.formData();
  const content = form.get('content');
  const name = form.get('name');
  if (typeof content !== 'string' || typeof name !== 'string') {
    return badRequest({
      fieldErrors: null,
      fields: null,
      formError: 'Form not submitted correctly.',
    });
  }

  const fieldErrors = {
    content: validateJokeContent(content),
    name: validateJokeName(name),
  };
  const fields = { content, name };
  if (Object.values(fieldErrors).some(Boolean)) {
    return badRequest({
      fieldErrors,
      fields,
      formError: null,
    });
  }

  const joke = await db.joke.create({
    data: { ...fields, jokesterId: userId },
  });
  return redirect(`/jokes/${joke.id}`);
};

export default function NewJokeRoute() {
  const actionData = useActionData<typeof action>();

  return (
    <div>
      <p>Add your own hilarious joke</p>
      <Form method="post">
        <div>
          <label>
            Name:{' '}
            <input
              defaultValue={actionData?.fields?.name}
              name="name"
              type="text"
              aria-invalid={Boolean(actionData?.fieldErrors?.name)}
              aria-errormessage={actionData?.fieldErrors?.name ? 'name-error' : undefined}
            />
          </label>
          {actionData?.fieldErrors?.name ? (
            <p className="form-validation-error" id="name-error" role="alert">
              {actionData.fieldErrors.name}
            </p>
          ) : null}
        </div>
        <div>
          <label>
            Content:{' '}
            <textarea
              defaultValue={actionData?.fields?.content}
              name="content"
              aria-invalid={Boolean(actionData?.fieldErrors?.content)}
              aria-errormessage={actionData?.fieldErrors?.content ? 'content-error' : undefined}
            />
          </label>
          {actionData?.fieldErrors?.content ? (
            <p className="form-validation-error" id="content-error" role="alert">
              {actionData.fieldErrors.content}
            </p>
          ) : null}
        </div>
        <div>
          {actionData?.formError ? (
            <p className="form-validation-error" role="alert">
              {actionData.formError}
            </p>
          ) : null}
          <button type="submit" className="button">
            Add
          </button>
        </div>
      </Form>
    </div>
  );
}

export function ErrorBoundary() {
  const error = useRouteError();
  console.error(error);

  if (isRouteErrorResponse(error) && error.status === 401) {
    return (
      <div className="error-container">
        <p>You must be logged in to create a joke.</p>
        <Link to="/login">Login</Link>
      </div>
    );
  }

  return <div className="error-container">Something unexpected went wrong. Sorry about that.</div>;
}
```

</details>

### Prefetching

If a user focuses or mouses-over a link, it's likely they want to go there. So we can prefetch the page that they're going to. And this is all it takes to enable that for a specific link:

```
<Link prefetch="intent" to="somewhere/neat">Somewhere Neat</Link>
```

üíø Add `prefetch="intent"` to the list of Joke links in `app/routes/jokes.tsx`.

<details>

<summary>app/routes/jokes.tsx</summary>

```tsx filename=app/routes/jokes.tsx lines=[73]
import type { LinksFunction, LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import { Form, Link, Outlet, useLoaderData } from '@remix-run/react';

import stylesUrl from '@/styles/jokes.css';
import { db } from '@/utils/db.server';
import { getUser } from '@/utils/session.server';

export const links: LinksFunction = () => [{ rel: 'stylesheet', href: stylesUrl }];

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const jokeListItems = await db.joke.findMany({
    orderBy: { createdAt: 'desc' },
    select: { id: true, name: true },
    take: 5,
  });
  const user = await getUser(request);

  return json({ jokeListItems, user });
};

export default function JokesRoute() {
  const data = useLoaderData<typeof loader>();

  return (
    <div className="jokes-layout">
      <header className="jokes-header">
        <div className="container">
          <h1 className="home-link">
            <Link to="/" title="Remix Jokes" aria-label="Remix Jokes">
              <span className="logo">ü§™</span>
              <span className="logo-medium">Jü§™KES</span>
            </Link>
          </h1>
          {data.user ? (
            <div className="user-info">
              <span>{`Hi ${data.user.username}`}</span>
              <Form action="/logout" method="post">
                <button type="submit" className="button">
                  Logout
                </button>
              </Form>
            </div>
          ) : (
            <Link to="/login">Login</Link>
          )}
        </div>
      </header>
      <main className="jokes-main">
        <div className="container">
          <div className="jokes-list">
            <Link to=".">Get a random joke</Link>
            <p>Here are a few more jokes to check out:</p>
            <ul>
              {data.jokeListItems.map(({ id, name }) => (
                <li key={id}>
                  <Link prefetch="intent" to={id}>
                    {name}
                  </Link>
                </li>
              ))}
            </ul>
            <Link to="new" className="button">
              Add your own
            </Link>
          </div>
          <div className="jokes-outlet">
            <Outlet />
          </div>
        </div>
      </main>
      <footer className="jokes-footer">
        <div className="container">
          <Link reloadDocument to="/jokes.rss">
            RSS
          </Link>
        </div>
      </footer>
    </div>
  );
}
```

</details>

## Optimistic UI

Now that we have JavaScript on the page, we can benefit from _progressive enhancement_ and make our site _even better_ with JavaScript by adding some _optimistic UI_ to our app.

Even though our app is quite fast (especially locally üòÖ), some users may have a poor connection to our app. This means that they're going to submit their jokes, but then they'll have to wait for a while before they see anything. We could add a loading spinner somewhere, but it'd be a much better user experience to be optimistic about the success of the request and render what the user would see.

We have a pretty in depth [guide on Optimistic UI][guide-on-optimistic-ui], so go give that a read

üíø Add optimistic UI to the `app/routes/jokes.new.tsx` route.

Note, you'll probably want to create a new file in `app/components/` called `joke.tsx` so you can reuse that UI in both `app/routes/jokes.$jokeId.tsx` & `app/routes/jokes.new.tsx`.

<details>

<summary>app/components/joke.tsx</summary>

```tsx filename=app/components/joke.tsx lines=[5,9,16-18,22]
import type { Joke } from '@prisma/client';
import { Form, Link } from '@remix-run/react';

export function JokeDisplay({
  canDelete = true,
  isOwner,
  joke,
}: {
  canDelete?: boolean;
  isOwner: boolean;
  joke: Pick<Joke, 'content' | 'name'>;
}) {
  return (
    <div>
      <p>Here's your hilarious joke:</p>
      <p>{joke.content}</p>
      <Link to=".">"{joke.name}" Permalink</Link>
      {isOwner ? (
        <Form method="post">
          <button
            className="button"
            disabled={!canDelete}
            name="intent"
            type="submit"
            value="delete"
          >
            Delete
          </button>
        </Form>
      ) : null}
    </div>
  );
}
```

</details>

<details>

<summary>app/routes/jokes.$jokeId.tsx</summary>

```tsx filename=app/routes/jokes.$jokeId.tsx lines=[14,91]
import type { ActionFunctionArgs, LoaderFunctionArgs, MetaFunction } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
import { isRouteErrorResponse, useLoaderData, useParams, useRouteError } from '@remix-run/react';

import { JokeDisplay } from '@/components/joke';
import { db } from '@/utils/db.server';
import { getUserId, requireUserId } from '@/utils/session.server';

export const meta: MetaFunction<typeof loader> = ({ data }) => {
  const { description, title } = data
    ? {
        description: `Enjoy the "${data.joke.name}" joke and much more`,
        title: `"${data.joke.name}" joke`,
      }
    : { description: 'No joke found', title: 'No joke' };

  return [
    { name: 'description', content: description },
    { name: 'twitter:description', content: description },
    { title },
  ];
};

export const loader = async ({ params, request }: LoaderFunctionArgs) => {
  const userId = await getUserId(request);
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Response('What a joke! Not found.', {
      status: 404,
    });
  }
  return json({
    isOwner: userId === joke.jokesterId,
    joke,
  });
};

export const action = async ({ params, request }: ActionFunctionArgs) => {
  const form = await request.formData();
  if (form.get('intent') !== 'delete') {
    throw new Response(`The intent ${form.get('intent')} is not supported`, { status: 400 });
  }
  const userId = await requireUserId(request);
  const joke = await db.joke.findUnique({
    where: { id: params.jokeId },
  });
  if (!joke) {
    throw new Response("Can't delete what does not exist", {
      status: 404,
    });
  }
  if (joke.jokesterId !== userId) {
    throw new Response("Pssh, nice try. That's not your joke", { status: 403 });
  }
  await db.joke.delete({ where: { id: params.jokeId } });
  return redirect('/jokes');
};

export default function JokeRoute() {
  const data = useLoaderData<typeof loader>();

  return <JokeDisplay isOwner={data.isOwner} joke={data.joke} />;
}

export function ErrorBoundary() {
  const { jokeId } = useParams();
  const error = useRouteError();
  console.error(error);

  if (isRouteErrorResponse(error)) {
    if (error.status === 400) {
      return <div className="error-container">What you're trying to do is not allowed.</div>;
    }
    if (error.status === 403) {
      return <div className="error-container">Sorry, but "{jokeId}" is not your joke.</div>;
    }
    if (error.status === 404) {
      return <div className="error-container">Huh? What the heck is "{jokeId}"?</div>;
    }
  }

  return (
    <div className="error-container">
      There was an error loading joke by the id "${jokeId}". Sorry.
    </div>
  );
}
```

</details>

<details>

<summary>app/routes/jokes.new.tsx</summary>

```tsx filename=app/routes/jokes.new.tsx lines=[11,15,84,86-103]
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
import {
  Form,
  isRouteErrorResponse,
  Link,
  useActionData,
  useNavigation,
  useRouteError,
} from '@remix-run/react';

import { JokeDisplay } from '@/components/joke';
import { db } from '@/utils/db.server';
import { badRequest } from '@/utils/request.server';
import { getUserId, requireUserId } from '@/utils/session.server';

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const userId = await getUserId(request);
  if (!userId) {
    throw new Response('Unauthorized', { status: 401 });
  }
  return json({});
};

function validateJokeContent(content: string) {
  if (content.length < 10) {
    return 'That joke is too short';
  }
}

function validateJokeName(name: string) {
  if (name.length < 3) {
    return "That joke's name is too short";
  }
}

export const action = async ({ request }: ActionFunctionArgs) => {
  const userId = await requireUserId(request);
  const form = await request.formData();
  const content = form.get('content');
  const name = form.get('name');
  if (typeof content !== 'string' || typeof name !== 'string') {
    return badRequest({
      fieldErrors: null,
      fields: null,
      formError: 'Form not submitted correctly.',
    });
  }

  const fieldErrors = {
    content: validateJokeContent(content),
    name: validateJokeName(name),
  };
  const fields = { content, name };
  if (Object.values(fieldErrors).some(Boolean)) {
    return badRequest({
      fieldErrors,
      fields,
      formError: null,
    });
  }

  const joke = await db.joke.create({
    data: { ...fields, jokesterId: userId },
  });
  return redirect(`/jokes/${joke.id}`);
};

export default function NewJokeRoute() {
  const actionData = useActionData<typeof action>();
  const navigation = useNavigation();

  if (navigation.formData) {
    const content = navigation.formData.get('content');
    const name = navigation.formData.get('name');
    if (
      typeof content === 'string' &&
      typeof name === 'string' &&
      !validateJokeContent(content) &&
      !validateJokeName(name)
    ) {
      return <JokeDisplay canDelete={false} isOwner={true} joke={{ name, content }} />;
    }
  }

  return (
    <div>
      <p>Add your own hilarious joke</p>
      <Form method="post">
        <div>
          <label>
            Name:{' '}
            <input
              defaultValue={actionData?.fields?.name}
              name="name"
              type="text"
              aria-invalid={Boolean(actionData?.fieldErrors?.name)}
              aria-errormessage={actionData?.fieldErrors?.name ? 'name-error' : undefined}
            />
          </label>
          {actionData?.fieldErrors?.name ? (
            <p className="form-validation-error" id="name-error" role="alert">
              {actionData.fieldErrors.name}
            </p>
          ) : null}
        </div>
        <div>
          <label>
            Content:{' '}
            <textarea
              defaultValue={actionData?.fields?.content}
              name="content"
              aria-invalid={Boolean(actionData?.fieldErrors?.content)}
              aria-errormessage={actionData?.fieldErrors?.content ? 'content-error' : undefined}
            />
          </label>
          {actionData?.fieldErrors?.content ? (
            <p className="form-validation-error" id="content-error" role="alert">
              {actionData.fieldErrors.content}
            </p>
          ) : null}
        </div>
        <div>
          {actionData?.formError ? (
            <p className="form-validation-error" role="alert">
              {actionData.formError}
            </p>
          ) : null}
          <button type="submit" className="button">
            Add
          </button>
        </div>
      </Form>
    </div>
  );
}

export function ErrorBoundary() {
  const error = useRouteError();
  console.error(error);

  if (isRouteErrorResponse(error) && error.status === 401) {
    return (
      <div className="error-container">
        <p>You must be logged in to create a joke.</p>
        <Link to="/login">Login</Link>
      </div>
    );
  }

  return <div className="error-container">Something unexpected went wrong. Sorry about that.</div>;
}
```

</details>

One thing I like about my example is that it can use the _exact_ same validation functions that the server uses! So if what they submitted will fail server-side validation, we don't even bother rendering the optimistic UI because we know it would fail.

That said, this declarative optimistic UI approach is fantastic because we don't have to worry about error recovery. If the request fails, then our component will be re-rendered, it will no longer be a submission and everything will work as it did before. Nice!

Here's a demonstration of what that experience looks like:

<video src="/jokes-tutorial/img/optimistic-ui.mp4" controls muted loop autoplay></video>

## Deployment

I feel pretty great about the user experience we've created here. So let's get this thing deployed! With Remix, you have a lot of options for deployment. When you ran `npx create-remix@latest` at the start of this tutorial, there were several options given to you. Because the tutorial we've built relies on Node.js (`prisma`), we're going to deploy to one of our favorite hosting providers: [Fly.io][fly-io].

üíø Before proceeding, you're going to need to [install fly][install-fly] and [sign up for an account][sign-up-for-an-account].

<docs-info>Fly.io asks you a credit card number at account creation (see why in [their blog article][their-blog-article]) but there are free tiers that cover the needs of this app hosted as a simple side project.</docs-info>

üíø Once you've done that, run this command from within your project directory:

```shellscript nonumber
fly launch
```

The folks at fly were kind enough to put together a great setup experience. They'll detect your Remix project and ask you a few questions to get you started. Here's my output/choices:

```
Creating app in /Users/kentcdodds/Desktop/remix-jokes
Scanning source code
Detected a Remix app
? Choose an app name (leave blank to generate one): remix-jokes
automatically selected personal organization: Kent C. Dodds
Some regions require a paid plan (fra, maa).
See https://fly.io/plans to set up a plan.

? Choose a region for deployment: Dallas, Texas (US) (dfw)
Created app 'remix-jokes' in organization 'personal'
Admin URL: https://fly.io/apps/remix-jokes
Hostname: remix-jokes.fly.dev
Created a 1GB volume vol_18l524yj27947zmp in the dfw region
Wrote config file fly.toml

This launch configuration uses SQLite on a single, dedicated volume. It will not scale beyond a single VM. Look into 'fly postgres' for a more robust production database.

? Would you like to deploy now? No
Your app is ready! Deploy with `flyctl deploy`
```

You'll want to choose a different app name because I already took `remix-jokes` (sorry üôÉ).

It also allowed you to select a region, I recommend choosing one that's close to you. If you decide to deploy a real app on Fly in the future, you may decide to scale up your fly to multiple regions.

Fly also detected that this project is using SQLite with Prisma and created a persistence volume for us.

We don't want to deploy right now because we have an environment variable we need to set! So choose "No".

Fly generated a few files for us:

- `fly.toml` - Fly-specific configuration
- `Dockerfile` - Remix-specific Dockerfile for the app
- `.dockerignore` - It just ignores `node_modules` because we'll run the installation as we build the image.

üíø Now set the `SESSION_SECRET` environment variable by running this command:

```shellscript nonumber
fly secrets set SESSION_SECRET=your-secret-here
```

`your-secret-here` can be whatever you want. It's just a string that's used to sign the session cookie. Use a password generator if you like.

One other thing we need to do is get Prisma ready to set up our database for the first time. Now that we're happy with our schema, we can create our first migration.

üíø Run this command:

```shellscript nonumber
npx prisma migrate dev
```

This will create a migration file in the `migrations` directory. You may get an error when it tries to run the seed file. You can safely ignore that. It will ask you what you want to call your migration:

```
Environment variables loaded from .env
Prisma schema loaded from prisma/schema.prisma
Datasource "db": SQLite database "dev.db" at "file:./dev.db"

SQLite database dev.db created at file:./dev.db

‚úî Enter a name for the new migration: ‚Ä¶ init
```

üíø I called mine "init". Then you'll get the rest of the output:

```
Applying migration `20211121111251_init`

The following migration(s) have been created and applied from new schema changes:

migrations/
  ‚îî‚îÄ 20211121111251_init/
    ‚îî‚îÄ migration.sql

Your database is now in sync with your schema.

‚úî Generated Prisma Client (4.12.0 | library) to ./node_modules/@prisma/client in 52ms


Running seed command `ts-node --require tsconfig-paths/register prisma/seed.ts` ...

üå±  The seed command has been executed.
```

üíø If you did get an error when running the seed, you can run it manually now:

```shellscript nonumber
npx prisma db seed
```

With that done, you're ready to deploy.

üíø Run this command:

```shellscript nonumber
fly deploy
```

This will build the docker image and deploy it on Fly in the region you selected. It will take a little while. While you wait, you can think of someone you haven't talked to in a while and shoot them a message telling them why you appreciate them.

Great! We're done and you made someone's day! Success!

Your app is now live at `https://<your-app-name>.fly.dev`! You can find that URL in your fly account online as well: [fly.io/apps][fly-io-apps].

Any time you make a change, simply run `fly deploy` again to redeploy.

## Conclusion

Phew! And there we have it. If you made it through this whole thing then I'm really impressed ([tweet your success][tweet-your-success])! There's a lot to Remix, and we've only gotten you started. Good luck on the rest of your Remix journey!

[classic-remix-compiler]: ../guides/vite#classic-remix-compiler-vs-remix-vite
[remix-vite]: ../guides/vite
[remix-jokes]: https://remix-jokes.lol
[mdn]: https://developer.mozilla.org/en-US
[prisma]: https://www.prisma.io
[code-sandbox]: https://codesandbox.com
[node-js]: https://nodejs.org
[npm]: https://www.npmjs.com
[vs-code]: https://code.visualstudio.com
[fly-io]: https://fly.io
[java-script-to-know-for-react]: https://kentcdodds.com/blog/javascript-to-know-for-react
[the-beginner-s-guide-to-react]: https://kcd.im/beginner-react
[the-http-api]: https://developer.mozilla.org/en-US/docs/Web/HTTP
[the-basic-example]: https://codesandbox.io/s/github/remix-run/examples/tree/main/basic
[express]: https://expressjs.com
[hydrate]: https://react.dev/reference/react-dom/client/hydrateRoot
[http-localhost-3000]: http://localhost:3000
[bare-bones-hello-world-app]: /jokes-tutorial/img/bare-bones.png
[remix-config-js]: ../file-conventions/remix-config
[the-route-filename-convention]: ../file-conventions/routes
[react_router]: https://reactrouter.com
[a-greeting-from-the-index-route]: /jokes-tutorial/img/index-route-greeting.png
[jokes]: http://localhost:3000/jokes
[a-random-joke-on-the-jokes-page-i-was-wondering-why-the-frisbee-was-getting-bigger-then-it-hit-me]: /jokes-tutorial/img/random-joke.png
[jokes-new]: http://localhost:3000/jokes/new
[a-new-joke-form]: /jokes-tutorial/img/new-joke.png
[jokes-anything-you-want]: http://localhost:3000/jokes/hippos
[a-new-joke-form-2]: /jokes-tutorial/img/param-route.png
[links]: ../route/links
[links-component]: ../components/link
[the-homepage-with-a-purple-gradient-background-and-white-text-with-the-words-hello-index-route]: /jokes-tutorial/img/homepage-styles.png
[the-jokes-page-with-no-background-gradient]: /jokes-tutorial/img/jokes-no-styles.png
[check-out-the-mdn-page-for-link]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link
[styled-components]: https://www.styled-components.com
[tailwind]: https://tailwindcss.com
[firebase]: https://firebase.google.com
[supabase]: https://supabase.com
[airtable]: https://www.airtable.com
[hasura]: https://hasura.io
[google-spreadsheets]: https://www.google.com/sheets/about
[cloudflare-workers-kv]: https://www.cloudflare.com/products/workers-kv
[fauna]: https://fauna.com/features
[postgre-sql]: https://www.postgresql.org
[a-vs-code-extension]: https://marketplace.visualstudio.com/items?itemName=Prisma.prisma
[sq-lite]: https://sqlite.org/index.html
[their-docs]: https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference
[loader]: ../route/loader
[use-loader-data]: ../hooks/use-loader-data
[list-of-links-to-jokes]: /jokes-tutorial/img/jokes-loaded.png
[huge-graphql-client]: https://bundlephobia.com/package/graphql@16.0.1
[assertion-functions]: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions
[zod]: https://npm.im/zod
[jokes-page-showing-a-unique-joke]: /jokes-tutorial/img/joke-page.png
[jokes-page-showing-a-random-joke]: /jokes-tutorial/img/random-joke-loaded.png
[action]: ../route/action
[response]: https://developer.mozilla.org/en-US/docs/Web/API/Response
[create-new-joke-form-filled-out]: /jokes-tutorial/img/creating-new-joke.png
[newly-created-joke-displayed]: /jokes-tutorial/img/new-joke-created.png
[use-action-data]: ../hooks/use-action-data
[new-joke-form-with-validation-errors]: /jokes-tutorial/img/new-joke-form-with-errors.png
[400-bad-request]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400
[http-cookies]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies
[bcryptjs]: https://npm.im/bcryptjs
[excalidraw-authentication-diagram]: /jokes-tutorial/img/auth-flow.png
[a-login-form-with-a-login-register-radio-button-and-username-password-fields-and-a-submit-button]: /jokes-tutorial/img/login-route.png
[login-form-with-errors]: /jokes-tutorial/img/login-form-with-errors.png
[here-are-the-docs]: ../utils/sessions
[create-cookie-session-storage]: ../utils/sessions#createcookiesessionstorage
[network-tab]: https://developer.chrome.com/docs/devtools/network/reference
[login]: http://localhost:3000/login
[dev-tools-network-tab-showing-a-set-cookie-header-on-the-post-response]: /jokes-tutorial/img/network-tab-set-cookie.png
[application-tab]: https://developer.chrome.com/docs/devtools/storage/cookies
[dev-tools-application-tab-showing]: /jokes-tutorial/img/application-tab-cookies.png
[request-headers-showing-the-cookie]: /jokes-tutorial/img/cookie-header-on-request.png
[destroy-session]: ../utils/sessions#using-sessions
[csrf]: https://developer.mozilla.org/en-US/docs/Glossary/CSRF
[jokes-page-nice-and-designed]: /jokes-tutorial/img/random-joke-designed.png
[new-joke-form-designed]: /jokes-tutorial/img/new-joke-designed.png
[error-boundary-feature]: https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary
[error-boundary-component]: ../route/error-boundary
[app-error]: /jokes-tutorial/img/app-level-error.png
[joke-page-error]: /jokes-tutorial/img/joke-id-error.png
[joke-index-page-error]: /jokes-tutorial/img/jokes-index-error.png
[new-joke-page-error]: /jokes-tutorial/img/new-joke-error.png
[server-errors]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses
[client-errors]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses
[is-route-error-response]: ../utils/is-route-error-response
[app-400-bad-request]: /jokes-tutorial/img/app-400.png
[a-404-on-the-joke-page]: /jokes-tutorial/img/joke-404.png
[a-404-on-the-random-joke-page]: /jokes-tutorial/img/jokes-404.png
[a-401-on-the-new-joke-page]: /jokes-tutorial/img/new-joke-401.png
[meta]: ../route/meta
[meta-component]: ../components/meta
[resource-routes]: ../guides/resource-routes
[escaping-special-characters-here]: ../file-conventions/routes-files#escaping-special-characters
[xml-document-for-rss-feed]: /jokes-tutorial/img/jokes-rss-feed.png
[network-tab-indicating-no-java-script-is-loaded]: /jokes-tutorial/img/no-javascript.png
[scripts-component]: ../components/scripts
[network-tab-showing-java-script-loaded]: /jokes-tutorial/img/yes-javascript.png
[browser-console-showing-the-log-of-a-server-side-error]: /jokes-tutorial/img/server-side-error-in-browser.png
[form-component]: ../components/form
[guide-on-optimistic-ui]: ../discussion/pending-ui
[install-fly]: https://fly.io/docs/hands-on/installing
[sign-up-for-an-account]: https://fly.io/docs/hands-on/sign-up
[their-blog-article]: https://fly.io/blog/free-postgres/#a-note-about-credit-cards
[fly-io-apps]: https://fly.io/apps
[tweet-your-success]: https://twitter.com/intent/tweet?text=I%20went%20through%20the%20whole%20remix.run%20jokes%20tutorial!%20%F0%9F%92%BF%20And%20now%20I%20love%20@remix_run!&url=https://remix.run/tutorials/jokes
[global-singleton-workaround]: ../guides/manual-mode#keeping-in-memory-server-state-across-rebuilds

---

## File: ./utils/cookies.md

---

## title: Cookies

# Cookies

A [cookie][cookie] is a small piece of information that your server sends someone in a HTTP response that their browser will send back on subsequent requests. This technique is a fundamental building block of many interactive websites that adds state so you can build authentication (see [sessions][sessions]), shopping carts, user preferences, and many other features that require remembering who is "logged in".

Remix's `Cookie` interface provides a logical, reusable container for cookie metadata.

## Using cookies

While you may create these cookies manually, it is more common to use a [session storage][sessions].

In Remix, you will typically work with cookies in your `loader` and/or `action` functions (see <Link to="../mutations">mutations</Link>), since those are the places where you need to read and write data.

Let's say you have a banner on your e-commerce site that prompts users to check out the items you currently have on sale. The banner spans the top of your homepage, and includes a button on the side that allows the user to dismiss the banner so they don't see it for at least another week.

First, create a cookie:

```ts filename=app/cookies.server.ts
import { createCookie } from '@remix-run/node'; // or cloudflare/deno

export const userPrefs = createCookie('user-prefs', {
  maxAge: 604_800, // one week
});
```

Then, you can `import` the cookie and use it in your `loader` and/or `action`. The `loader` in this case just checks the value of the user preference so you can use it in your component for deciding whether to render the banner. When the button is clicked, the `<form>` calls the `action` on the server and reloads the page without the banner.

**Note:** We recommend (for now) that you create all the cookies your app needs in a `*.server.ts` file and `import` them into your route modules. This allows the Remix compiler to correctly prune these imports out of the browser build where they are not needed. We hope to eventually remove this caveat.

```tsx filename=app/routes/_index.tsx lines=[12,17-19,26-28,37]
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json, redirect } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData, Link, Form } from '@remix-run/react';

import { userPrefs } from '@/cookies.server';

export async function loader({ request }: LoaderFunctionArgs) {
  const cookieHeader = request.headers.get('Cookie');
  const cookie = (await userPrefs.parse(cookieHeader)) || {};
  return json({ showBanner: cookie.showBanner });
}

export async function action({ request }: ActionFunctionArgs) {
  const cookieHeader = request.headers.get('Cookie');
  const cookie = (await userPrefs.parse(cookieHeader)) || {};
  const bodyParams = await request.formData();

  if (bodyParams.get('bannerVisibility') === 'hidden') {
    cookie.showBanner = false;
  }

  return redirect('/', {
    headers: {
      'Set-Cookie': await userPrefs.serialize(cookie),
    },
  });
}

export default function Home() {
  const { showBanner } = useLoaderData<typeof loader>();

  return (
    <div>
      {showBanner ? (
        <div>
          <Link to="/sale">Don't miss our sale!</Link>
          <Form method="post">
            <input type="hidden" name="bannerVisibility" value="hidden" />
            <button type="submit">Hide</button>
          </Form>
        </div>
      ) : null}
      <h1>Welcome!</h1>
    </div>
  );
}
```

## Cookie attributes

Cookies have [several attributes][cookie-attrs] that control when they expire, how they are accessed, and where they are sent. Any of these attributes may be specified either in `createCookie(name, options)`, or during `serialize()` when the `Set-Cookie` header is generated.

```ts
const cookie = createCookie('user-prefs', {
  // These are defaults for this cookie.
  path: '/',
  sameSite: 'lax',
  httpOnly: true,
  secure: true,
  expires: new Date(Date.now() + 60_000),
  maxAge: 60,
});

// You can either use the defaults:
cookie.serialize(userPrefs);

// Or override individual ones as needed:
cookie.serialize(userPrefs, { sameSite: 'strict' });
```

Please read [more info about these attributes][cookie-attrs] to get a better understanding of what they do.

## Signing cookies

It is possible to sign a cookie to automatically verify its contents when it is received. Since it's relatively easy to spoof HTTP headers, this is a good idea for any information that you do not want someone to be able to fake, like authentication information (see [sessions][sessions]).

To sign a cookie, provide one or more `secrets` when you first create the cookie:

```ts
const cookie = createCookie('user-prefs', {
  secrets: ['s3cret1'],
});
```

Cookies that have one or more `secrets` will be stored and verified in a way that ensures the cookie's integrity.

Secrets may be rotated by adding new secrets to the front of the `secrets` array. Cookies that have been signed with old secrets will still be decoded successfully in `cookie.parse()`, and the newest secret (the first one in the array) will always be used to sign outgoing cookies created in `cookie.serialize()`.

```ts filename=app/cookies.server.ts
export const cookie = createCookie('user-prefs', {
  secrets: ['n3wsecr3t', 'olds3cret'],
});
```

```tsx filename=app/routes/route.tsx
import { cookie } from '@/cookies.server';

export async function loader({ request }: LoaderFunctionArgs) {
  const oldCookie = request.headers.get('Cookie');
  // oldCookie may have been signed with "olds3cret", but still parses ok
  const value = await cookie.parse(oldCookie);

  new Response('...', {
    headers: {
      // Set-Cookie is signed with "n3wsecr3t"
      'Set-Cookie': await cookie.serialize(value),
    },
  });
}
```

## `createCookie`

Creates a logical container for managing a browser cookie from the server.

```ts
import { createCookie } from '@remix-run/node'; // or cloudflare/deno

const cookie = createCookie('cookie-name', {
  // all of these are optional defaults that can be overridden at runtime
  expires: new Date(Date.now() + 60_000),
  httpOnly: true,
  maxAge: 60,
  path: '/',
  sameSite: 'lax',
  secrets: ['s3cret1'],
  secure: true,
});
```

To learn more about each attribute, please see the [MDN Set-Cookie docs][cookie-attrs].

## `isCookie`

Returns `true` if an object is a Remix cookie container.

```ts
import { isCookie } from '@remix-run/node'; // or cloudflare/deno
const cookie = createCookie('user-prefs');
console.log(isCookie(cookie));
// true
```

## Cookie API

A cookie container is returned from `createCookie` and has a handful of properties and methods.

```ts
const cookie = createCookie(name);
cookie.name;
cookie.parse();
// etc.
```

### `cookie.name`

The name of the cookie, used in `Cookie` and `Set-Cookie` HTTP headers.

### `cookie.parse()`

Extracts and returns the value of this cookie in a given `Cookie` header.

```ts
const value = await cookie.parse(request.headers.get('Cookie'));
```

### `cookie.serialize()`

Serializes a value and combines it with this cookie's options to create a `Set-Cookie` header, suitable for use in an outgoing `Response`.

```ts
new Response('...', {
  headers: {
    'Set-Cookie': await cookie.serialize({
      showBanner: true,
    }),
  },
});
```

### `cookie.isSigned`

Will be `true` if the cookie uses any `secrets`, `false` otherwise.

```ts
let cookie = createCookie('user-prefs');
console.log(cookie.isSigned); // false

cookie = createCookie('user-prefs', {
  secrets: ['soopersekrit'],
});
console.log(cookie.isSigned); // true
```

### `cookie.expires`

The `Date` on which this cookie expires. Note that if a cookie has both `maxAge` and `expires`, this value will be the date at the current time plus the `maxAge` value since `Max-Age` takes precedence over `Expires`.

```ts
const cookie = createCookie('user-prefs', {
  expires: new Date('2021-01-01'),
});

console.log(cookie.expires); // "2020-01-01T00:00:00.000Z"
```

[sessions]: ./sessions
[cookie]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies
[cookie-attrs]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#attributes

---

## File: ./utils/create-remix-stub.md

---

## title: createRemixStub

# `createRemixStub`

This utility allows you to unit-test your own components that rely on Remix hooks/components by setting up a mocked set of routes:

```tsx
import { createRemixStub } from '@remix-run/testing';

test('renders loader data', async () => {
  const RemixStub = createRemixStub([
    {
      path: '/',
      meta() {
        /* ... */
      },
      links() {
        /* ... */
      },
      Component: MyComponent,
      ErrorBoundary: MyErrorBoundary,
      action() {
        /* ... */
      },
      loader() {
        /* ... */
      },
    },
  ]);

  render(<RemixStub />);

  // Assert initial render
  await waitFor(() => screen.findByText('...'));

  // Click a button and assert a UI change
  user.click(screen.getByText('button text'));
  await waitFor(() => screen.findByText('...'));
});
```

If your [`loader`][loader]s rely on the `getLoadContext` method, you can provide a stubbed context via the second parameter to `createRemixStub`:

```tsx
const RemixStub = createRemixStub(
  [
    {
      path: '/',
      Component: MyComponent,
      loader({ context }) {
        return json({ message: context.key });
      },
    },
  ],
  { key: 'value' },
);
```

The `<RemixStub>` component itself takes properties similar to React Router if you need to control the initial URL, history stack, hydration data, or future flags:

```tsx
// Test the app rendered at "/2" with 2 prior history stack entries
render(<RemixStub initialEntries={['/', '/1', '/2']} initialIndex={2} />);

// Test the app rendered with initial loader data for the root route.  When using
// this, it's best to give your routes their own unique IDs in your route definitions
render(
  <RemixStub
    hydrationData={{
      loaderData: { root: { message: 'hello' } },
    }}
  />,
);

// Test the app rendered with given future flags enabled
render(<RemixStub future={{ v3_coolFeature: true }} />);
```

[loader]: ../route/loader

---

## File: ./utils/data.md

---

title: data
toc: false

---

# `data`

This is a utility for use with [Single Fetch][single-fetch] to return raw data accompanied with a status code or custom response headers. This avoids the need to serialize your data into a `Response` instance to provide custom status/headers. This is generally a replacement for `loader`/`action` functions that used [`json`][json] or [`defer`][defer] prior to Single Fetch.

```tsx
import { data } from '@remix-run/node'; // or cloudflare/deno

export const loader = async () => {
  return data(
    { not: 'coffee' },
    {
      status: 418,
      headers: {
        'Cache-Control': 'no-store',
      },
    },
  );
};
```

You should _not_ be using this function if you don't need to return custom status/headers - in that case, just return the data directly:

```tsx
export const loader = async () => {
  // ‚ùå Bad
  return data({ not: 'coffee' });

  // ‚úÖ Good
  return { not: 'coffee' };
};
```

[single-fetch]: ../guides/single-fetch
[json]: ./json
[defer]: ./defer

---

## File: ./utils/defer.md

---

title: defer
toc: false

---

# `defer`

To get started with streaming data, check out the [Streaming Guide][streaming_guide].

This is a shortcut for creating a streaming/deferred response. It assumes you are using `utf-8` encoding. From a developer perspective it behaves just like [`json()`][json], but with the ability to transport promises to your UI components.

```tsx lines=[1,7-10]
import { defer } from '@remix-run/node'; // or cloudflare/deno

export const loader = async () => {
  const aStillRunningPromise = loadSlowDataAsync();

  // So you can write this without awaiting the promise:
  return defer({
    critical: 'data',
    slowPromise: aStillRunningPromise,
  });
};
```

You can also pass a status code and headers:

```tsx lines=[9-14]
export const loader = async () => {
  const aStillRunningPromise = loadSlowDataAsync();

  return defer(
    {
      critical: 'data',
      slowPromise: aStillRunningPromise,
    },
    {
      status: 418,
      headers: {
        'Cache-Control': 'no-store',
      },
    },
  );
};
```

[streaming_guide]: ../guides/streaming
[json]: ./json

---

## File: ./utils/index.md

---

title: Utilities
order: 6

---

---

## File: ./utils/is-route-error-response.md

---

title: isRouteErrorResponse
toc: false

---

# `isRouteErrorResponse`

<docs-info>This util is simply a re-export of [React Router's `isRouteErrorResponse`][rr-isrouteerrorresponse].</docs-info>

[rr-isrouteerrorresponse]: https://reactrouter.com/v6/utils/is-route-error-response

---

## File: ./utils/json.md

---

title: json
toc: false

---

# `json`

This is a shortcut for creating `application/json` responses. It assumes you are using `utf-8` encoding.

```tsx lines=[1,5]
import { json } from '@remix-run/node'; // or cloudflare/deno

export const loader = async () => {
  // So you can write this:
  return json({ any: 'thing' });

  // Instead of this:
  return new Response(JSON.stringify({ any: 'thing' }), {
    headers: {
      'Content-Type': 'application/json; charset=utf-8',
    },
  });
};
```

You can also pass a status code and headers:

```tsx lines=[4-9]
export const loader = async () => {
  return json(
    { not: 'coffee' },
    {
      status: 418,
      headers: {
        'Cache-Control': 'no-store',
      },
    },
  );
};
```

---

## File: ./utils/parse-multipart-form-data.md

---

## title: unstable_parseMultipartFormData

# `unstable_parseMultipartFormData`

Allows you to handle multipart forms (file uploads) for your app.

Would be useful to understand [the Browser File API][the-browser-file-api] to know how to use this API.

It's to be used in place of `request.formData()`.

```diff
- const formData = await request.formData();
+ const formData = await unstable_parseMultipartFormData(request, uploadHandler);
```

For example:

```tsx lines=[4-7,12,25]
export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await unstable_parseMultipartFormData(
    request,
    uploadHandler, // <-- we'll look at this deeper next
  );

  // the returned value for the file field is whatever our uploadHandler returns.
  // Let's imagine we're uploading the avatar to s3,
  // so our uploadHandler returns the URL.
  const avatarUrl = formData.get('avatar');

  // update the currently logged in user's avatar in our database
  await updateUserAvatar(request, avatarUrl);

  // success! Redirect to account page
  return redirect('/account');
};

export default function AvatarUploadRoute() {
  return (
    <Form method="post" encType="multipart/form-data">
      <label htmlFor="avatar-input">Avatar</label>
      <input id="avatar-input" type="file" name="avatar" />
      <button>Upload</button>
    </Form>
  );
}
```

To read the contents of an uploaded file, use one of the methods it inherits from [the Blob API][the-blob-api]. For example, `.text()` asynchronously returns the text contents of the file, and `.arrayBuffer()` returns the binary contents.

### `uploadHandler`

The `uploadHandler` is the key to the whole thing. It's responsible for what happens to the multipart/form-data parts as they are being streamed from the client. You can save it to disk, store it in memory, or act as a proxy to send it somewhere else (like a file storage provider).

Remix has two utilities to create `uploadHandler`s for you:

- `unstable_createFileUploadHandler`
- `unstable_createMemoryUploadHandler`

These are fully featured utilities for handling fairly simple use cases. It's not recommended to load anything but quite small files into memory. Saving files to disk is a reasonable solution for many use cases. But if you want to upload the file to a file hosting provider, then you'll need to write your own.

[the-browser-file-api]: https://developer.mozilla.org/en-US/docs/Web/API/File
[the-blob-api]: https://developer.mozilla.org/en-US/docs/Web/API/Blob

---

## File: ./utils/redirect.md

---

title: redirect
toc: false

---

# `redirect`

This is a shortcut for sending 30x responses.

```tsx lines=[1,7]
import { redirect } from '@remix-run/node'; // or cloudflare/deno

export const action = async () => {
  const userSession = await getUserSessionOrWhatever();

  if (!userSession) {
    return redirect('/login');
  }

  return json({ ok: true });
};
```

By default, it sends 302, but you can change it to whichever redirect status code you'd like:

```ts
redirect(path, 301);
redirect(path, 303);
```

You can also send a `ResponseInit` to set headers, like committing a session.

```ts
redirect(path, {
  headers: {
    'Set-Cookie': await commitSession(session),
  },
});

redirect(path, {
  status: 302,
  headers: {
    'Set-Cookie': await commitSession(session),
  },
});
```

Of course, you can do redirects without this helper if you'd rather build it up yourself:

```ts
// this is a shortcut...
return redirect('/else/where', 303);

// ...for this
return new Response(null, {
  status: 303,
  headers: {
    Location: '/else/where',
  },
});
```

And you can throw redirects to break through the call stack and redirect right away:

```ts
if (!session) {
  throw redirect('/login', 302);
}
```

---

## File: ./utils/redirectDocument.md

---

title: redirectDocument
toc: false

---

# `redirectDocument`

This is a small wrapper around [`redirect`][redirect] that will trigger a document-level redirect to the new location instead of a client-side navigation.

This is most useful when you have a Remix app living next to a non-Remix app on the same domain and need to redirect from the Remix app to the non-Remix app:

```tsx lines=[1,7]
import { redirectDocument } from '@remix-run/node'; // or cloudflare/deno

export const action = async () => {
  const userSession = await getUserSessionOrWhatever();

  if (!userSession) {
    // Assuming `/login` is a separate non-Remix app
    return redirectDocument('/login');
  }

  return json({ ok: true });
};
```

Just like [`redirect`][redirect], it accepts a status code or a `ResponseInit` as the second parameter:

```ts
redirectDocument(path, 301);
redirectDocument(path, 303);
```

```ts
redirectDocument(path, {
  headers: {
    'Set-Cookie': await commitSession(session),
  },
});
```

[redirect]: ./redirect

---

## File: ./utils/replace.md

---

title: replace
toc: false

---

# `replace`

This is a small wrapper around [`redirect`][redirect] that will trigger a client-side redirect to the new location using `history.replaceState` instead of `history.pushState`.

If JavaScript has not loaded, this will behave as a standard document-level redirect and will add a new entry to the history stack.

Just like [`redirect`][redirect], it accepts a status code or a `ResponseInit` as the second parameter:

```ts
replace(path, 301);
replace(path, 303);
```

```ts
replace(path, {
  headers: {
    'Set-Cookie': await commitSession(session),
  },
});
```

[redirect]: ./redirect

---

## File: ./utils/sessions.md

---

## title: Sessions

# Sessions

Sessions are an important part of websites that allow the server to identify requests coming from the same person, especially when it comes to server-side form validation or when JavaScript is not on the page. Sessions are a fundamental building block of many sites that let users "log in", including social, e-commerce, business, and educational websites.

In Remix, sessions are managed on a per-route basis (rather than something like express middleware) in your `loader` and `action` methods using a "session storage" object (that implements the `SessionStorage` interface). Session storage understands how to parse and generate cookies, and how to store session data in a database or filesystem.

Remix comes with several pre-built session storage options for common scenarios, and one to create your own:

- `createCookieSessionStorage`
- `createMemorySessionStorage`
- `createFileSessionStorage` (node)
- `createWorkersKVSessionStorage` (Cloudflare Workers)
- `createArcTableSessionStorage` (architect, Amazon DynamoDB)
- custom storage with `createSessionStorage`

## Using Sessions

This is an example of a cookie session storage:

```ts filename=app/sessions.ts
// app/sessions.ts
import { createCookieSessionStorage } from '@remix-run/node'; // or cloudflare/deno

type SessionData = {
  userId: string;
};

type SessionFlashData = {
  error: string;
};

const { getSession, commitSession, destroySession } = createCookieSessionStorage<
  SessionData,
  SessionFlashData
>({
  // a Cookie from `createCookie` or the CookieOptions to create one
  cookie: {
    name: '__session',

    // all of these are optional
    domain: 'remix.run',
    // Expires can also be set (although maxAge overrides it when used in combination).
    // Note that this method is NOT recommended as `new Date` creates only one date on each server deployment, not a dynamic date in the future!
    //
    // expires: new Date(Date.now() + 60_000),
    httpOnly: true,
    maxAge: 60,
    path: '/',
    sameSite: 'lax',
    secrets: ['s3cret1'],
    secure: true,
  },
});

export { getSession, commitSession, destroySession };
```

We recommend setting up your session storage object in `app/sessions.ts` so all routes that need to access session data can import from the same spot (also, see our [Route Module Constraints][constraints]).

The input/output to a session storage object are HTTP cookies. `getSession()` retrieves the current session from the incoming request's `Cookie` header, and `commitSession()`/`destroySession()` provide the `Set-Cookie` header for the outgoing response.

You'll use methods to get access to sessions in your `loader` and `action` functions.

A login form might look something like this:

```tsx filename=app/routes/login.tsx lines=[8,13-15,17,22,26,34-36,47,52,57,62]
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node'; // or cloudflare/deno
import { json, redirect } from '@remix-run/node'; // or cloudflare/deno
import { useLoaderData } from '@remix-run/react';

import { getSession, commitSession } from '../sessions';

export async function loader({ request }: LoaderFunctionArgs) {
  const session = await getSession(request.headers.get('Cookie'));

  if (session.has('userId')) {
    // Redirect to the home page if they are already signed in.
    return redirect('/');
  }

  const data = { error: session.get('error') };

  return json(data, {
    headers: {
      'Set-Cookie': await commitSession(session),
    },
  });
}

export async function action({ request }: ActionFunctionArgs) {
  const session = await getSession(request.headers.get('Cookie'));
  const form = await request.formData();
  const username = form.get('username');
  const password = form.get('password');

  const userId = await validateCredentials(username, password);

  if (userId == null) {
    session.flash('error', 'Invalid username/password');

    // Redirect back to the login page with errors.
    return redirect('/login', {
      headers: {
        'Set-Cookie': await commitSession(session),
      },
    });
  }

  session.set('userId', userId);

  // Login succeeded, send them to the home page.
  return redirect('/', {
    headers: {
      'Set-Cookie': await commitSession(session),
    },
  });
}

export default function Login() {
  const { error } = useLoaderData<typeof loader>();

  return (
    <div>
      {error ? <div className="error">{error}</div> : null}
      <form method="POST">
        <div>
          <p>Please sign in</p>
        </div>
        <label>
          Username: <input type="text" name="username" />
        </label>
        <label>
          Password: <input type="password" name="password" />
        </label>
      </form>
    </div>
  );
}
```

And then a logout form might look something like this:

```tsx
import { getSession, destroySession } from '../sessions';

export const action = async ({ request }: ActionFunctionArgs) => {
  const session = await getSession(request.headers.get('Cookie'));
  return redirect('/login', {
    headers: {
      'Set-Cookie': await destroySession(session),
    },
  });
};

export default function LogoutRoute() {
  return (
    <>
      <p>Are you sure you want to log out?</p>
      <Form method="post">
        <button>Logout</button>
      </Form>
      <Link to="/">Never mind</Link>
    </>
  );
}
```

<docs-warning>It's important that you logout (or perform any mutation for that matter) in an `action` and not a `loader`. Otherwise you open your users to [Cross-Site Request Forgery][csrf] attacks. Also, Remix only re-calls `loaders` when `actions` are called.</docs-warning>

## Session Gotchas

Because of nested routes, multiple loaders can be called to construct a single page. When using `session.flash()` or `session.unset()`, you need to be sure no other loaders in the request are going to want to read that, otherwise you'll get race conditions. Typically if you're using flash, you'll want to have a single loader read it, if another loader wants a flash message, use a different key for that loader.

## `createSession`

TODO:

## `isSession`

Returns `true` if an object is a Remix session.

```ts
import { isSession } from '@remix-run/node'; // or cloudflare/deno

const sessionData = { foo: 'bar' };
const session = createSession(sessionData, 'remix-session');
console.log(isSession(session));
// true
```

## `createSessionStorage`

Remix makes it easy to store sessions in your own database if needed. The `createSessionStorage()` API requires a `cookie` (for options for creating a cookie, see [cookies][cookies]) and a set of create, read, update, and delete (CRUD) methods for managing the session data. The cookie is used to persist the session ID.

- `createData` will be called from `commitSession` on the initial session creation when no session ID exists in the cookie
- `readData` will be called from `getSession` when a session ID exists in the cookie
- `updateData` will be called from `commitSession` when a session ID already exists in the cookie
- `deleteData` is called from `destroySession`

The following example shows how you could do this using a generic database client:

```ts
import { createSessionStorage } from '@remix-run/node'; // or cloudflare/deno

function createDatabaseSessionStorage({ cookie, host, port }) {
  // Configure your database client...
  const db = createDatabaseClient(host, port);

  return createSessionStorage({
    cookie,
    async createData(data, expires) {
      // `expires` is a Date after which the data should be considered
      // invalid. You could use it to invalidate the data somehow or
      // automatically purge this record from your database.
      const id = await db.insert(data);
      return id;
    },
    async readData(id) {
      return (await db.select(id)) || null;
    },
    async updateData(id, data, expires) {
      await db.update(id, data);
    },
    async deleteData(id) {
      await db.delete(id);
    },
  });
}
```

And then you can use it like this:

```ts
const { getSession, commitSession, destroySession } = createDatabaseSessionStorage({
  host: 'localhost',
  port: 1234,
  cookie: {
    name: '__session',
    sameSite: 'lax',
  },
});
```

The `expires` argument to `createData` and `updateData` is the same `Date` at which the cookie itself expires and is no longer valid. You can use this information to automatically purge the session record from your database to save on space, or to ensure that you do not otherwise return any data for old, expired cookies.

## `createCookieSessionStorage`

For purely cookie-based sessions (where the session data itself is stored in the session cookie with the browser, see [cookies][cookies]) you can use `createCookieSessionStorage()`.

The main advantage of cookie session storage is that you don't need any additional backend services or databases to use it. It can also be beneficial in some load-balanced scenarios. However, cookie-based sessions may not exceed the browser's max-allowed cookie length (typically 4kb).

The downside is that you have to `commitSession` in almost every loader and action. If your loader or action changes the session at all, it must be committed. That means if you `session.flash` in an action, and then `session.get` in another, you must commit it for that flashed message to go away. With other session storage strategies you only have to commit it when it's created (the browser cookie doesn't need to change because it doesn't store the session data, just the key to find it elsewhere).

```ts
import { createCookieSessionStorage } from '@remix-run/node'; // or cloudflare/deno

const { getSession, commitSession, destroySession } = createCookieSessionStorage({
  // a Cookie from `createCookie` or the same CookieOptions to create one
  cookie: {
    name: '__session',
    secrets: ['r3m1xr0ck5'],
    sameSite: 'lax',
  },
});
```

Note that other session implementations store a unique session ID in a cookie and use that ID to look up the session in the source of truth (in-memory, filesystem, DB, etc.). In a cookie session, the cookie _is_ the source of truth so there is no unique ID out of the box. If you need to track a unique ID in your cookie session you will need to add an ID value yourself via `session.set()`.

## `createMemorySessionStorage`

This storage keeps all the cookie information in your server's memory.

<docs-error>This should only be used in development. Use one of the other methods in production.</docs-error>

```ts filename=app/sessions.ts
import { createCookie, createMemorySessionStorage } from '@remix-run/node'; // or cloudflare/deno

// In this example the Cookie is created separately.
const sessionCookie = createCookie('__session', {
  secrets: ['r3m1xr0ck5'],
  sameSite: true,
});

const { getSession, commitSession, destroySession } = createMemorySessionStorage({
  cookie: sessionCookie,
});

export { getSession, commitSession, destroySession };
```

## `createFileSessionStorage` (node)

For file-backed sessions, use `createFileSessionStorage()`. File session storage requires a file system, but this should be readily available on most cloud providers that run express, maybe with some extra configuration.

The advantage of file-backed sessions is that only the session ID is stored in the cookie while the rest of the data is stored in a regular file on disk, ideal for sessions with more than 4kb of data.

<docs-info>If you are deploying to a serverless function, ensure you have access to a persistent file system. They usually don't have one without extra configuration.</docs-info>

```ts filename=app/sessions.ts
import { createCookie, createFileSessionStorage } from '@remix-run/node'; // or cloudflare/deno

// In this example the Cookie is created separately.
const sessionCookie = createCookie('__session', {
  secrets: ['r3m1xr0ck5'],
  sameSite: true,
});

const { getSession, commitSession, destroySession } = createFileSessionStorage({
  // The root directory where you want to store the files.
  // Make sure it's writable!
  dir: '/app/sessions',
  cookie: sessionCookie,
});

export { getSession, commitSession, destroySession };
```

## `createWorkersKVSessionStorage` (Cloudflare Workers)

For [Cloudflare Workers KV][cloudflare-kv] backed sessions, use `createWorkersKVSessionStorage()`.

The advantage of KV backed sessions is that only the session ID is stored in the cookie while the rest of the data is stored in a globally-replicated, low-latency data store with exceptionally high-read volumes with low-latency.

```ts filename=app/sessions.server.ts
import { createCookie, createWorkersKVSessionStorage } from '@remix-run/cloudflare';

// In this example the Cookie is created separately.
const sessionCookie = createCookie('__session', {
  secrets: ['r3m1xr0ck5'],
  sameSite: true,
});

const { getSession, commitSession, destroySession } = createWorkersKVSessionStorage({
  // The KV Namespace where you want to store sessions
  kv: YOUR_NAMESPACE,
  cookie: sessionCookie,
});

export { getSession, commitSession, destroySession };
```

## `createArcTableSessionStorage` (architect, Amazon DynamoDB)

For [Amazon DynamoDB][amazon-dynamo-db] backed sessions, use `createArcTableSessionStorage()`.

The advantage of DynamoDB backed sessions is that only the session ID is stored in the cookie while the rest of the data is stored in a globally replicated, low-latency data store with exceptionally high read volumes with low-latency.

```
# app.arc
sessions
  _idx *String
  _ttl TTL
```

```ts filename=app/sessions.server.ts
import { createCookie, createArcTableSessionStorage } from '@remix-run/architect';

// In this example the Cookie is created separately.
const sessionCookie = createCookie('__session', {
  secrets: ['r3m1xr0ck5'],
  maxAge: 3600,
  sameSite: true,
});

const { getSession, commitSession, destroySession } = createArcTableSessionStorage({
  // The name of the table (should match app.arc)
  table: 'sessions',
  // The name of the key used to store the session ID (should match app.arc)
  idx: '_idx',
  // The name of the key used to store the expiration time (should match app.arc)
  ttl: '_ttl',
  cookie: sessionCookie,
});

export { getSession, commitSession, destroySession };
```

## Session API

After retrieving a session with `getSession`, the returned session object has a handful of methods and properties:

```tsx
export async function action({ request }: ActionFunctionArgs) {
  const session = await getSession(request.headers.get('Cookie'));
  session.get('foo');
  session.has('bar');
  // etc.
}
```

### `session.has(key)`

Returns `true` if the session has a variable with the given `name`.

```ts
session.has('userId');
```

### `session.set(key, value)`

Sets a session value for use in subsequent requests:

```ts
session.set('userId', '1234');
```

### `session.flash(key, value)`

Sets a session value that will be unset the first time it is read. After that, it's gone. Most useful for "flash messages" and server-side form validation messages:

```tsx
import { commitSession, getSession } from '../sessions';

export async function action({ params, request }: ActionFunctionArgs) {
  const session = await getSession(request.headers.get('Cookie'));
  const deletedProject = await archiveProject(params.projectId);

  session.flash('globalMessage', `Project ${deletedProject.name} successfully archived`);

  return redirect('/dashboard', {
    headers: {
      'Set-Cookie': await commitSession(session),
    },
  });
}
```

Now we can read the message in a loader.

<docs-info>You must commit the session whenever you read a `flash`. This is different than what you might be used to, where some type of middleware automatically sets the cookie header for you.</docs-info>

```tsx
import { json } from '@remix-run/node'; // or cloudflare/deno
import { Meta, Links, Scripts, Outlet } from '@remix-run/react';

import { getSession, commitSession } from './sessions';

export async function loader({ request }: LoaderFunctionArgs) {
  const session = await getSession(request.headers.get('Cookie'));
  const message = session.get('globalMessage') || null;

  return json(
    { message },
    {
      headers: {
        // only necessary with cookieSessionStorage
        'Set-Cookie': await commitSession(session),
      },
    },
  );
}

export default function App() {
  const { message } = useLoaderData<typeof loader>();

  return (
    <html>
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        {message ? <div className="flash">{message}</div> : null}
        <Outlet />
        <Scripts />
      </body>
    </html>
  );
}
```

### `session.get()`

Accesses a session value from a previous request:

```ts
session.get('name');
```

### `session.unset()`

Removes a value from the session.

```ts
session.unset('name');
```

<docs-info>When using cookieSessionStorage, you must commit the session whenever you `unset`</docs-info>

```tsx
export async function loader({ request }: LoaderFunctionArgs) {
  // ...

  return json(data, {
    headers: {
      'Set-Cookie': await commitSession(session),
    },
  });
}
```

[cookies]: ./cookies
[constraints]: ../guides/constraints
[csrf]: https://developer.mozilla.org/en-US/docs/Glossary/CSRF
[cloudflare-kv]: https://developers.cloudflare.com/workers/learning/how-kv-works
[amazon-dynamo-db]: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide

---

## File: ./utils/unstable-create-file-upload-handler.md

---

title: unstable_createFileUploadHandler
toc: false

---

# `unstable_createFileUploadHandler`

A Node.js upload handler that will write parts with a filename to disk to keep them out of memory, parts without a filename will not be parsed. Should be composed with another upload handler.

**Example:**

```tsx
export const action = async ({ request }: ActionFunctionArgs) => {
  const uploadHandler = unstable_composeUploadHandlers(
    unstable_createFileUploadHandler({
      maxPartSize: 5_000_000,
      file: ({ filename }) => filename,
    }),
    // parse everything else into memory
    unstable_createMemoryUploadHandler(),
  );
  const formData = await unstable_parseMultipartFormData(request, uploadHandler);

  const file = formData.get('avatar');

  // file is a "NodeOnDiskFile" which implements the "File" API
  // ... etc
};
```

**Options:**

| Property           | Type               | Default                         | Description                                                                                                                                                     |
| ------------------ | ------------------ | ------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| avoidFileConflicts | boolean            | true                            | Avoid file conflicts by appending a timestamp on the end of the filename if it already exists on disk                                                           |
| directory          | string \| Function | os.tmpdir()                     | The directory to write the upload.                                                                                                                              |
| file               | Function           | () => `upload_${random}.${ext}` | The name of the file in the directory. Can be a relative path, the directory structure will be created if it does not exist.                                    |
| maxPartSize        | number             | 3000000                         | The maximum upload size allowed (in bytes). If the size is exceeded a MaxPartSizeExceededError will be thrown.                                                  |
| filter             | Function           | OPTIONAL                        | A function you can write to prevent a file upload from being saved based on filename, content type, or field name. Return `false` and the file will be ignored. |

The function API for `file` and `directory` are the same. They accept an `object` and return a `string`. The object it accepts has `filename`, `name`, and `contentType` (all strings). The `string` returned is the path.

The `filter` function accepts an `object` and returns a `boolean` (or a promise that resolves to a `boolean`). The object it accepts has the `filename`, `name`, and `contentType` (all strings). The `boolean` returned is `true` if you want to handle that file stream.

---

## File: ./utils/unstable-create-memory-upload-handler.md

---

title: unstable_createMemoryUploadHandler
toc: false

---

# `unstable_createMemoryUploadHandler`

**Example:**

```tsx
export const action = async ({ request }: ActionFunctionArgs) => {
  const uploadHandler = unstable_createMemoryUploadHandler({
    maxPartSize: 500_000,
  });
  const formData = await unstable_parseMultipartFormData(request, uploadHandler);

  const file = formData.get('avatar');

  // file is a "File" (https://mdn.io/File) polyfilled for node
  // ... etc
};
```

**Options:** The only options supported are `maxPartSize` and `filter` which work the same as in `unstable_createFileUploadHandler` above. This API is not recommended for anything at scale, but is a convenient utility for simple use cases and as a fallback for another handler.
