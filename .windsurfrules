# Project rules

## Backend code generation

> When creating or updating backend code, please follow those rules:

### Versions
- NestJS 11

### Controllers
- No direct CRUD, use domain-driven use-cases.
- Document with Swagger, in English.
- Validate received data with `ValidationPipe` and `transform`
- Always returns DTOs.

### Exceptions
- Throw exception the more you can.
- Always be specific, error message must contain input parameters for easy debuging.
- Use NestJS or the framework exceptions when technical.
- Create custom exceptions when domain specific.

### Backend : Use-cases
- 

### Logging
- Avoid "logger.error()", throw Exception instead (because logger catchs exceptions).
- On use-cases: log `debug` the input, log `success` the output.

Loging use-case example:
```ts
  async execute(projectId: string, promptInstruction: string): Promise<Project> {
    this.logger.debug(`Updating Project Prompt`, this.constructor.name, {
      projectId,
      promptInstruction,
    });

    const project = await this.projectRepository.findById(projectId);

    if (project === null) {
      throw new NotFoundException(`Project with id ${projectId} not found`);
    }

    const updatedProject = await this.projectRepository.update(projectId, { promptInstruction });

    this.logger.success(`Project Prompt Updated`, this.constructor.name, {
      projectId,
      promptInstruction: updatedProject.prompt_instruction,
    });

    return updatedProject;
  }
```

### DTO
- Everything in subclass
- Prisma Model is imported with `Model` suffix (e.g `import { Prisma, User as UserModel } from '@prisma/client';`)
- Create and Update DTOs are always implementing Prisma's corresponding interface (e.g. `export class CreateUserDto implements Prisma.UserCreateInput`)
- - Document with Swagger (NestJS), in English.
- Only use DTO for creations, updates, no "output or response DTO"
- Map fields individually (e.g `this.id = user.id` in constructor), no `Object.assign` etc.
- Use `class-validator` and `Swagger` documentation with annotations on fields.
- DTOs always implements interfaces in `shared-types` to ensure frontend <-> backend type coherence.

Example of files structure:
```text
├── application
│   ├── create-project.use-case.ts
│   ├── get-project.use-case.ts
│   └── update-project-prompt.use-case.ts
├── domain
│   └── project.repository.interface.ts
├── infrastructure
│   └── prisma-project.repository.ts
├── presentation
│   ├── projects.controller.ts
│   └── project.dto.ts
└── projects.module.ts
```


- no `ValidationPipe` needed, `main.ts` uses `useGlobalPipes`.
- input is Domain object, output is Domain object too.
- call the use-cases which will handle domain logic.
- use domain mapper from current domain.
- use Swagger annotations the more you can to be details on API specs.

Example `projects/presentation/project.mapper.ts`:
```typescript
@ApiTags('Projects')
@Controller('projects')
export class ProjectsController {

  constructor(
    private readonly updateProjectPromptUseCase: UpdateProjectPromptUseCase,
    private readonly projectMapper: ProjectMapper,
  ) {}

  @Put('prompt')
  @ApiOperation({ summary: 'Update prompt instructions of a project.' })
  @ApiResponse({ status: 200, type: ProjectUpdate })
  async updateProjectPrompt(
    @Body()
    updateProjectPromptDto: ProjectUpdate,
  ): Promise<ProjectUpdate> {
    const project = await this.updateProjectPromptUseCase.execute(updateProjectPromptDto);

    return this.projectMapper.toDomain(project);
  }
}


```

- use Swagger annotations (`APIProperty` at least, propose more if relevant).
- extends validated type (also with `class-validator`) only with current properties using `PickType`.
- properties use `!` because no constructor.
- language in english.
- use `class-validator` annotations if data needs to be validation backend only.

Example:
```typescript
import { ProjectType } from '@le-journal/shared-types';
import { ApiProperty, PickType } from '@nestjs/swagger';
import { IsNotEmpty, IsString, Matches, MaxLength, MinLength } from 'class-validator';

const MIN_LENGTH = 10;
const MAX_LENGTH = 200;
const VALIDATION = /^[^<>{}]*$/;

export class ProjectUpdate extends PickType(ProjectType, ['id', 'promptInstruction']) {
  @ApiProperty({
    example: 'c123e456-789b-12d3-a456-426614174000',
    description: 'ID du projet',
  })
  id!: string;

  @ApiProperty({
    description: 'The instruction prompt for the project',
    example: 'Write a blog post about AI and its impact on society',
    minLength: MIN_LENGTH,
    maxLength: MAX_LENGTH,
  })
  @IsString()
  @IsNotEmpty()
  @MinLength(MIN_LENGTH, {
    message: `Prompt instruction must be at least ${MIN_LENGTH} characters long`,
  })
  @MaxLength(MAX_LENGTH, {
    message: `Prompt instruction must be at most ${MAX_LENGTH} characters long`,
  })
  @Matches(VALIDATION, {
    message: 'Prompt instruction cannot contain HTML tags or special characters like < > { }',
  })
  promptInstruction!: string;
}
```

## Logging Levels
- Use only 4 logging methods: debug(), log(), warn(), error()
- debug(): Use for technical details and development information
- log(): Use for important business events and successes
- warn(): Use for abnormal but non-critical situations
- error(): Use for exceptions and critical failures

## Context Structure
- Always provide service and method names
- Include metadata for business data
- Pass Error objects directly in error context
- Use correlationId for tracing related operations
- Structure all logs in JSON format

## Example: Error Logging
```typescript
this.logger.error('User creation failed', {
  service: 'UserService',
  method: 'createUser',
  metadata: {
    email: user.email,
    role: user.role
  },
  error: error
});
```

## Example: Business Event
```typescript
this.logger.log('Payment processed', {
  service: 'PaymentService',
  method: 'processPayment',
  correlationId: 'order-123',
  metadata: {
    orderId: order.id,
    amount: payment.amount
  }
});
```

- use NestJS dependency injection.
- import type from Prisma suffixed by "Model".
- implements [mapper.interface.ts](mdc:apps/backend/src/presentation/mapper.interface.ts) with <Domain, Model>

Example `projects/presentation/project.mapper.ts`:
```typescript
import { Injectable } from '@nestjs/common';
import { Project as ProjectModel } from '@prisma/client';

import { Project } from '../domain/project';

import { Mapper } from 'src/presentation/mapper.interface';

@Injectable()
export class ProjectMapper implements Mapper<Project, ProjectModel> {
  toModel(domain: Project): ProjectModel {
    return {
      id: domain.id,
      name: domain.name,
      slug: domain.slug,
      newsletter_alias: domain.newsletterAlias,
      project_number: domain.projectNumber,
      created_at: domain.createdAt,
      prompt_instruction: domain.promptInstruction,
      user_id: domain.userId,
    };
  }

  toDomain(model: ProjectModel): Project {
    return {
      id: model.id,
      name: model.name,
      slug: model.slug,
      newsletterAlias: model.newsletter_alias,
      projectNumber: model.project_number,
      createdAt: model.created_at,
      promptInstruction: model.prompt_instruction,
      userId: model.user_id,
    };
  }
}
```

Backend tests rules:
- Jest for testing.
- Integration tests must not create data directly (use seed.ts).
- No "retries".

Backend tests (integration):
- Always test controller to have the max coverrage.

Backend tests with data:
- Seed are used as fixtures, data already set up.
- Never call Prisma directly in tests, use repository if needed.

## Frontend : Components rules
- Apply the Smart/Dumb pattern: 
  - Smart components (stateful, using MobX stores)
  - Dumb components (pure UI).
- No default export for components.
- Export static `displayName` at the bottom.
- All actions, computations, and transformations (such as filtering, must be stored in variables at the top of the file (expect for className).
  - Do not overinterpret, e.g. this code in not necessary nor helpful `const shouldShowContent = hasArticles; const articles = email.articles;`

## Frontend : Files architecture
- Structure: Organize by feature in folders.
Example for a user profile component:
```text
user-profile/
| user-profile.component.tsx # minimal logic, only UI component
| user-profile-menu.component.tsx # minimal logic, only UI component
| user-profile.store.ts # for actions, computed, reactions...
| user-profile.hook.ts # if necessary
| user-profile.context.ts # if necessary, for providers
| user-profile.mock.ts # test data for UI
| user-profile.type.ts # for store types: state, actions...
```

## Frontend State Management (MobX)
- Use mobx-react-lite and makeAutoObservable.
- Use runInAction for async or reactive effects.
- Use computed properties for derived state and actions for modifications.
- Create a factory at the bottom of each store (e.g. `export const createProjectStore = (): ProjectStore => new ProjectStore();`)
- Inject the store into the parent component to facilitate state management.


- Remix only, no NextJS.
- Root imports with /~.
- Test with Vitest.
- Use Vite, not Webpack.
- ESLint with flat config. 
- Use versions in [package.json](mdc:apps/frontend/package.json).

- Loaders must be used in routes.
- Return plain objects instead of `json()`.


Language:
- English for everything.
- French only in UI (labels, texts...)

Sharing code:
- Place shared data types in `packages/shared-types`.
- One file per type, export everything from [index.ts](mdc:packages/shared-types/src/index.ts).

Simplified code:
- Use explicit constants instead of magic numbers.
- Write clear and simple conditions, avoid double negatives.
- Prioritize readable variable names, even if long.
- Simplify loops using map(), filter(), or reduce().

Type safe code:
- Always type function params and returns.

Feature focus code:
- Reflect business needs in the code.
- Avoid technical function names, favor domain language.
- Model objects closely to business concepts.

Sizes:
- Functions: Max 20-30 lines.
- Classes/Files: Max 200-300 lines.
- Folders: Max 7-10 files.

Responsability:
- One file per feature, split responsibility across files (SRP).

Comments:
- No comments by default.
- Comments only for complex logic or interfaces.

Forbidden:
- Anemic models (avoid trivial getId/setId).
- Function names with no actions (avoid `setUsers`, prefer `loadUsers`). 
- No interface prefix `IUser` or type suffix `UserType`. 

Lint & Error
- Follow @typescript-eslint/strict-boolean-expressions (avoid if(!obj)).
- Catch errors with catch(error: unknown | Error).
- On frontend, use apps/frontend/app/utils/api/error.ts to handle errors. 

- Use Node, never Express.
- Check all packages versions every time:
    - root monorepo: [package.json](mdc:package.json)
    - backend: [package.json](mdc:apps/backend/package.json)
    - frontend: [package.json](mdc:apps/frontend/package.json)
    - shared-types: [package.json](mdc:packages/shared-types/package.json)
- Ask before adding new packages.
- Use PNPM with the latest version.

- most of the validation is done here with `class-validator`
- this type is used "as-is" in frontend.
- this type is extended in backend's Domain models.
- for frontend, 'sub-types' can be created picking types from main type.

Example `packages/shared-types/src/project.type.ts`:
```typescript
import { PickType } from '@nestjs/mapped-types';
import { IsDate, IsEmail, IsNotEmpty, IsNumber, IsString } from 'class-validator';

export class ProjectType {
  @IsString()
  @IsNotEmpty()
  id!: string;

  @IsString()
  @IsNotEmpty()
  name!: string;

  @IsString()
  @IsNotEmpty()
  slug!: string;

  @IsString()
  @IsNotEmpty()
  userId!: string;

  @IsString()
  @IsNotEmpty()
  @IsEmail()
  newsletterAlias!: string;

  @IsNumber()
  @IsNotEmpty()
  projectNumber!: number;

  @IsDate()
  @IsNotEmpty()
  createdAt!: Date;

  @IsString()
  promptInstruction!: string;
}

export class ProjectPromptType extends PickType(ProjectType, ['id', 'promptInstruction']) {}
```

