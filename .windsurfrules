# Project rules

Backend API & Controllers
- No direct CRUD, use domain-driven use-cases.
- Document with Swagger (NestJS), in English.
- Each controller matches a specific use-case. 

Backend DTO
- Map fields individually (avoid Object.assign).
- Use DTO for validation and Swagger doc.
- Prefix Prisma imports (PrismaUser). 

Backend Repository
- Use DTO for create/update.
- No dedicated mapper, mapped-types allowed. 

Backend Tests
- Jest for testing.
- Integration tests must not create data directly (use seed.ts).
- Always test use-cases.
- Never call Prisma directly in tests. 
- No "retries" in test generation.

Backend Use-Cases
- Domain-focused logic, not simple CRUD.
- Prefer DTO instead of heavy ValueObjects. 

Frontend Components:
- Apply the Smart/Dumb pattern: 
    - Smart components (stateful, using MobX stores)
    - Dumb components (pure UI).
- Organize by feature in folders.
Example for a user profile component:
```text
user-profile/
| user-profile.component.tsx # minimal logic, only UI component
| user-profile-menu.component.tsx # minimal logic, only UI component
| user-profile.store.ts # for actions, computed, reactions...
| user-profile.hook.ts # if necessary
| user-profile.context.ts # if necessary, for providers
| user-profile.mock.ts # test data for UI
| user-profile.type.ts # for store types: state, actions...
```
- All actions, computations, and transformations (such as filtering, must be stored in variables at the top of the file (expect for className).
  - Do not overinterpret, e.g. this code in not necessary nor helpful `const shouldShowContent = hasArticles; const articles = email.articles;`

State Management (MobX)
- Use mobx-react-lite and makeAutoObservable.
- Use runInAction for async or reactive effects.
- Use computed properties for derived state and actions for modifications.
- Create a factory at the bottom of each store (e.g. `export const createProjectStore = (): ProjectStore => new ProjectStore();`)
- Inject the store into the parent component to facilitate state management.


- Remix only, no NextJS.
- Root imports with /~.
- Test with Vitest.
- Use Vite, not Webpack.
- ESLint with flat config. 

- Loaders must be used in routes.
- Return plain objects instead of `json()`.

Language:
- English for everything.
- French only in UI (labels, texts...)

Global Code Generation
- Strict TypeScript.
- Minimal file size.
- One file per feature, split responsibility across files (SRP).

Comments:
- No comments by default.
- Comments only for complex logic or interfaces.

Focus on domain code generation:
- Feature driven development (FDD).
- No anemic models (avoid trivial getId/setId).
- Function names follow user actions (avoid setSomething). 
- No interface prefix (IUser) or type suffix (UserType). 

Lint & Error
- Follow @typescript-eslint/strict-boolean-expressions (avoid if(!obj)).
- Catch errors with catch(error: unknown | Error).
- On frontend, use apps/frontend/app/utils/api/error.ts to handle errors. 

- Use Node, never Express.
- Check all packages versions every time:
    - npm
    - pnpm
    - yarn
- Ask before adding new packages.
- Use PNPM with the latest version. 

- Place shared data types in "packages/shared-types".
- One file per type, export everything from index.ts.

