# Project rules

- no `ValidationPipe` needed, `main.ts` uses `useGlobalPipes`.
- input is Domain object, output is Domain object too.
- call the use-cases which will handle domain logic.
- use domain mapper from current domain.
- use Swagger annotations the more you can to be details on API specs.

Example `projects/presentation/project.mapper.ts`:
```typescript
@ApiTags('Projects')
@Controller('projects')
export class ProjectsController {

  constructor(
    private readonly updateProjectPromptUseCase: UpdateProjectPromptUseCase,
    private readonly projectMapper: ProjectMapper,
  ) {}

  @Put('prompt')
  @ApiOperation({ summary: 'Update prompt instructions of a project.' })
  @ApiResponse({ status: 200, type: ProjectUpdate })
  async updateProjectPrompt(
    @Body()
    updateProjectPromptDto: ProjectUpdate,
  ): Promise<ProjectUpdate> {
    const project = await this.updateProjectPromptUseCase.execute(updateProjectPromptDto);

    return this.projectMapper.toDomain(project);
  }
}


```

- use Swagger annotations (`APIProperty` at least, propose more if relevant).
- extends validated type (also with `class-validator`) only with current properties using `PickType`.
- properties use `!` because no constructor.
- language in english.
- use `class-validator` annotations if data needs to be validation backend only.

Example:
```typescript
import { ProjectType } from '@le-journal/shared-types';
import { ApiProperty, PickType } from '@nestjs/swagger';
import { IsNotEmpty, IsString, Matches, MaxLength, MinLength } from 'class-validator';

const MIN_LENGTH = 10;
const MAX_LENGTH = 200;
const VALIDATION = /^[^<>{}]*$/;

export class ProjectUpdate extends PickType(ProjectType, ['id', 'promptInstruction']) {
  @ApiProperty({
    example: 'c123e456-789b-12d3-a456-426614174000',
    description: 'ID du projet',
  })
  id!: string;

  @ApiProperty({
    description: 'The instruction prompt for the project',
    example: 'Write a blog post about AI and its impact on society',
    minLength: MIN_LENGTH,
    maxLength: MAX_LENGTH,
  })
  @IsString()
  @IsNotEmpty()
  @MinLength(MIN_LENGTH, {
    message: `Prompt instruction must be at least ${MIN_LENGTH} characters long`,
  })
  @MaxLength(MAX_LENGTH, {
    message: `Prompt instruction must be at most ${MAX_LENGTH} characters long`,
  })
  @Matches(VALIDATION, {
    message: 'Prompt instruction cannot contain HTML tags or special characters like < > { }',
  })
  promptInstruction!: string;
}
```

- Libs: NestJS 11, RxJS 8 mandatory.
- Throw exception early with descriptive names and params.
- Create custom exceptions when domain specific.
- Focus on domain logic.

Example structure `src/features/projects`:
```text
├── application
│   ├── create-project.use-case.ts
│   ├── get-project.use-case.ts
│   └── update-project-prompt.use-case.ts
├── domain
│   ├── project-create.ts
│   ├── project-update.ts
│   ├── project.repository.interface.ts
│   └── project.ts
├── infrastructure
│   └── prisma-project.repository.ts
├── presentation
│   ├── project.mapper.ts
│   └── projects.controller.ts
└── projects.module.ts
```


## Logging Levels
- Use only 4 logging methods: debug(), log(), warn(), error()
- debug(): Use for technical details and development information
- log(): Use for important business events and successes
- warn(): Use for abnormal but non-critical situations
- error(): Use for exceptions and critical failures

## Context Structure
- Always provide service and method names
- Include metadata for business data
- Pass Error objects directly in error context
- Use correlationId for tracing related operations
- Structure all logs in JSON format

## Example: Error Logging
```typescript
this.logger.error('User creation failed', {
  service: 'UserService',
  method: 'createUser',
  metadata: {
    email: user.email,
    role: user.role
  },
  error: error
});
```

## Example: Business Event
```typescript
this.logger.log('Payment processed', {
  service: 'PaymentService',
  method: 'processPayment',
  correlationId: 'order-123',
  metadata: {
    orderId: order.id,
    amount: payment.amount
  }
});
```

- use NestJS dependency injection.
- import type from Prisma suffixed by "Model".
- implements [mapper.interface.ts](mdc:apps/backend/src/presentation/mapper.interface.ts) with <Domain, Model>

Example `projects/presentation/project.mapper.ts`:
```typescript
import { Injectable } from '@nestjs/common';
import { Project as ProjectModel } from '@prisma/client';

import { Project } from '../domain/project';

import { Mapper } from 'src/presentation/mapper.interface';

@Injectable()
export class ProjectMapper implements Mapper<Project, ProjectModel> {
  toModel(domain: Project): ProjectModel {
    return {
      id: domain.id,
      name: domain.name,
      slug: domain.slug,
      newsletter_alias: domain.newsletterAlias,
      project_number: domain.projectNumber,
      created_at: domain.createdAt,
      prompt_instruction: domain.promptInstruction,
      user_id: domain.userId,
    };
  }

  toDomain(model: ProjectModel): Project {
    return {
      id: model.id,
      name: model.name,
      slug: model.slug,
      newsletterAlias: model.newsletter_alias,
      projectNumber: model.project_number,
      createdAt: model.created_at,
      promptInstruction: model.prompt_instruction,
      userId: model.user_id,
    };
  }
}
```

Backend tests rules:
- Jest for testing.
- Integration tests must not create data directly (use seed.ts).
- No "retries".

Backend tests (integration):
- Always test controller to have the max coverrage.

Backend tests with data:
- Seed are used as fixtures, data already set up.
- Never call Prisma directly in tests, use repository if needed.

- Use observer from mobx-react-lite on React components to track state changes.
- Dump component, no logic, logics is in store [rule-frontend-store.mdc](mdc:.cursor/rules/rule-frontend-store.mdc) .
- No default export for components.
- Export static `displayName` at the bottom.
- const at the top.
- Separate with line jumb `hooks` and regular const.
- Early returns.
- Strong typing.
- Use ShadCN from `~/components/ui`.
- 

Example child component (`features/dashboard/custom-instructions/custom-instructions-confirmation.component.tsx`):
```typescript

```

Example main component (`features/dashboard/custom-instructions/custom-instructions.component.tsx`): 
```typescript
import { PROJECT_MAX_LENGTH, PROJECT_MIN_LENGTH } from '@le-journal/shared-types';
import { observer } from 'mobx-react-lite';
import { useRef, type FC } from 'react';

import { useDashboardStores } from '../dashboard.context';

import { Skeleton } from '~/components/ui/skeleton';
import { Textarea } from '~/components/ui/textarea';

export const CustomInstructions: FC = observer(() => {
  const formRef = useRef<HTMLFormElement>(null);
  const { dashboardStore } = useDashboardStores();

  const store = dashboardStore.customInstructions;
  const state = store.state;

  if (state === null || store.isLoading) {
    return <Skeleton className="h-[200px]" />;
  }

  return (
    <div className="mt-auto sticky bottom-0 bg-white border-t p-4">
      <label htmlFor="ai-customization" className="block text-sm font-medium text-gray-700 mb-2">
        Comment devrions-nous personnaliser votre score de newsletter ? Que souhaitez-vous voir plus
        ou moins ?
      </label>
      <form ref={formRef} onSubmit={store.save} className="space-y-4">
        <div className="flex space-x-4">
          <input type="hidden" name="id" value={state.id} />
          <Textarea
            name="promptInstruction"
            disabled={store.isSubmitting}
            value={state.promptInstruction}
            onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
              store.changeInstruction(e.target.value)
            }
            minLength={PROJECT_MIN_LENGTH}
            maxLength={PROJECT_MAX_LENGTH}
            className="flex-1"
            placeholder="Entrez vos préférences de personnalisation..."
          />
        </div>
      </form>
    </div>
  );
});

CustomInstructions.displayName = 'CustomInstructions';

```

- Remix only, no NextJS.
- Root imports with /~.
- Test with Vitest.
- Use Vite, not Webpack.
- ESLint with flat config. 
- Use versions in [package.json](mdc:apps/frontend/package.json).

- Loaders must be used in routes.
- Return plain objects instead of `json()`.

- Never use technical function (e.g. `setDialogOpen`), prefer user actions (`openDialog`, `closeDialog`).
- Always validate state before afting using [validator.ts](mdc:apps/frontend/app/lib/validator.ts) 
- Use `makeAutoObservable` in the store constructor.
- Wrap state mutations inside runInAction().
- Use `computed properties` for all derived values, even small (e.g., `instructionLength`).
- Ensure async functions use runInAction() when modifying state.
- Inject the store into the parent component for better state management.
- Separate logic (store) from UI (component).
- Implement [loadable.interface.ts](mdc:apps/frontend/app/interfaces/loadable.interface.ts) is component have a state loadable from API.

Interface Example `features/dashboard/custom-instructions/custom-instructions.type.ts`: 
```typescript
import type { ProjectPromptType } from '@le-journal/shared-types';

import type { Actionable, Statable } from '~/interfaces/component.interface';
import type { Loadable } from '~/interfaces/loadable.interface';

interface CustomInstructionsState extends Statable<ProjectPromptType> {
  isDialogOpen: boolean;
}

interface CustomInstructionsActions extends Actionable<ProjectPromptType> {
  openDialog: () => void;
  closeDialog: () => void;
}

export interface CustomInstructions
  extends CustomInstructionsState,
    CustomInstructionsActions,
    Loadable<ProjectPromptType> {}
```

Store Example `features/dashboard/custom-instructions/custom-instructions.store.ts`:
```typescript
import type { ProjectPromptType } from '@le-journal/shared-types';
import { makeAutoObservable, runInAction } from 'mobx';

import type { CustomInstructions } from './custom-instructions.type';

import type { Loadable } from '~/interfaces/loadable.interface';
import { clientFetch } from '~/lib/api-fetcher.client';
import { verify } from '~/lib/validator';

export class CustomInstructionsStore implements CustomInstructions, Loadable<ProjectPromptType> {
  state: ProjectPromptType | null = null;

  isDialogOpen = false;
  isLoading = true;
  isSubmitting = false;

  constructor() {
    makeAutoObservable(this);
  }

  init = (prompt: ProjectPromptType): void => {
    verify(prompt);

    runInAction(() => {
      this.state = prompt;
      this.isLoading = false;
    });
  };

  save = async (event: React.FormEvent<HTMLFormElement>): Promise<void> => {
    const updatedState = await clientFetch<ProjectPromptType>(event, this.state);

    this.init(updatedState);
  };

  changeInstruction = (instruction: string): void => {
    if (this.state === null) {
      throw new Error('State is null');
    }

    runInAction(() => {
      this.state!.promptInstruction = instruction;
    });
  };

  openDialog = (): void => {
    this.isDialogOpen = true;
  };

  closeDialog = (): void => {
    this.isDialogOpen = false;
  };

  get instructionLength(): number {
    return this.state?.promptInstruction.length ?? 0;
  }
}
```

Language:
- English for everything.
- French only in UI (labels, texts...)

Sharing code:
- Place shared data types in `packages/shared-types`.
- One file per type, export everything from [index.ts](mdc:packages/shared-types/src/index.ts).

Simplified code:
- Use explicit constants instead of magic numbers.
- Write clear and simple conditions, avoid double negatives.
- Prioritize readable variable names, even if long.
- Simplify loops using map(), filter(), or reduce().

Type safe code:
- Always type function params and returns.

Feature focus code:
- Reflect business needs in the code.
- Avoid technical function names, favor domain language.
- Model objects closely to business concepts.

Sizes:
- Functions: Max 20-30 lines.
- Classes/Files: Max 200-300 lines.
- Folders: Max 7-10 files.

Responsability:
- One file per feature, split responsibility across files (SRP).

Comments:
- No comments by default.
- Comments only for complex logic or interfaces.

Forbidden:
- Anemic models (avoid trivial getId/setId).
- Function names with no actions (avoid `setUsers`, prefer `loadUsers`). 
- No interface prefix `IUser` or type suffix `UserType`. 

Lint & Error
- Follow @typescript-eslint/strict-boolean-expressions (avoid if(!obj)).
- Catch errors with catch(error: unknown | Error).
- On frontend, use apps/frontend/app/utils/api/error.ts to handle errors. 

- Use Node, never Express.
- Check all packages versions every time:
    - root monorepo: [package.json](mdc:package.json)
    - backend: [package.json](mdc:apps/backend/package.json)
    - frontend: [package.json](mdc:apps/frontend/package.json)
    - shared-types: [package.json](mdc:packages/shared-types/package.json)
- Ask before adding new packages.
- Use PNPM with the latest version.

- most of the validation is done here with `class-validator`
- this type is used "as-is" in frontend.
- this type is extended in backend's Domain models.
- for frontend, 'sub-types' can be created picking types from main type.

Example `packages/shared-types/src/project.type.ts`:
```typescript
import { PickType } from '@nestjs/mapped-types';
import { IsDate, IsEmail, IsNotEmpty, IsNumber, IsString } from 'class-validator';

export class ProjectType {
  @IsString()
  @IsNotEmpty()
  id!: string;

  @IsString()
  @IsNotEmpty()
  name!: string;

  @IsString()
  @IsNotEmpty()
  slug!: string;

  @IsString()
  @IsNotEmpty()
  userId!: string;

  @IsString()
  @IsNotEmpty()
  @IsEmail()
  newsletterAlias!: string;

  @IsNumber()
  @IsNotEmpty()
  projectNumber!: number;

  @IsDate()
  @IsNotEmpty()
  createdAt!: Date;

  @IsString()
  promptInstruction!: string;
}

export class ProjectPromptType extends PickType(ProjectType, ['id', 'promptInstruction']) {}
```

